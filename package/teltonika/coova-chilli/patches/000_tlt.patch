diff --recursive --unified --new-file --no-dereference orig/.gitignore src/.gitignore
--- orig/.gitignore	2016-12-15 17:28:43.000000000 +0000
+++ src/.gitignore	1970-01-01 00:00:00.000000000 +0000
@@ -1,132 +0,0 @@
-# Object files
-*.o
-*.ko
-*.lo
-
-# Libraries
-*.lib
-*.a
-*.la
-
-# Shared objects (inc. Windows DLLs)
-*.dll
-*.so
-*.so.*
-*.dylib
-
-# Executables
-*.exe
-*.out
-*.app
-
-**/.deps
-**/.libs
-
-Makefile
-Makefile.in
-bstring/Makefile
-bstring/Makefile.in
-conf/Makefile
-conf/Makefile.in
-debian/Makefile
-debian/Makefile.in
-distro/Makefile
-distro/Makefile.in
-doc/Makefile
-doc/Makefile.in
-json/Makefile
-json/Makefile.in
-json/json_config.h
-json/json_config.h.in
-json/stamp-h2
-miniportal/Makefile
-miniportal/Makefile.in
-src/Makefile
-src/Makefile.in
-src/mssl/Makefile
-src/mssl/Makefile.in
-www/Makefile
-www/Makefile.in
-
-aclocal.m4
-compile
-conf/CoovaChilliLib.py
-conf/chilli
-conf/chilli.conf
-conf/defaults
-conf/down.sh
-conf/functions
-conf/newmulti.sh
-conf/up.sh
-conf/wpad.dat
-config.guess
-config.h
-config.h.in
-config.log
-config.status
-config.sub
-configure
-configure.status
-coova-doxygen
-depcomp
-distro/nethserver/coova-chilli.spec
-distro/redhat/coova-chilli.spec
-distro/suse/coova-chilli.spec
-doc/chilli-radius.5
-doc/chilli.8
-doc/chilli.conf.5
-doc/chilli_opt.1
-doc/chilli_proxy.1
-doc/chilli_query.1
-doc/chilli_radconfig.1
-doc/chilli_radsec.1
-doc/chilli_redir.1
-doc/chilli_response.1
-doc/chilli_rtmon.1
-doc/chilli_script.1
-install-sh
-libtool
-ltmain.sh
-m4/
-missing
-stamp-h1
-
-src/chilli
-src/chilli_opt
-src/chilli_query
-src/chilli_radconfig
-src/chilli_response
-src/chilli_proxy
-src/chilli_radsec
-src/chilli_redir
-src/chilli_rtmon
-src/chilli_script
-
-www/config.sh
-miniportal/config-local.sh
-miniportal/contact.chi
-miniportal/error.chi
-miniportal/functions.sh
-miniportal/login.chi
-miniportal/map.chi
-miniportal/payment.chi
-miniportal/payment.sh
-miniportal/register.chi
-miniportal/service.chi
-miniportal/status.chi
-miniportal/terms.chi
-miniportal/tos.chi
-miniportal/uam.sh
-miniportal/wispr.sh
-
-src/cmdline.[ch]
-src/cmdline.c.orig
-autom4te.cache
-
-debian/coova-chilli.debhelper.log
-debian/coova-chilli.postinst.debhelper
-debian/coova-chilli.postrm.debhelper
-debian/coova-chilli.prerm.debhelper
-debian/coova-chilli.substvars
-debian/coova-chilli/
-debian/files
diff --recursive --unified --new-file --no-dereference orig/.gitlab-ci.yml src/.gitlab-ci.yml
--- orig/.gitlab-ci.yml	1970-01-01 00:00:00.000000000 +0000
+++ src/.gitlab-ci.yml	2024-01-26 11:00:37.000000000 +0000
@@ -0,0 +1,20 @@
+include:
+  - project: teltonika/ci-templates
+    file:
+      - /templates/semgrep.yml
+
+workflow:
+  rules:
+    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
+    - if: $CI_PIPELINE_SOURCE == "web"
+    - if: $CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS
+      when: never
+    - if: $CI_COMMIT_BRANCH
+
+semgrep_errors:
+  extends: .semgrep_errors
+
+semgrep_info:
+  extends: .semgrep_info
+  needs:
+    - job: semgrep_errors
diff --recursive --unified --new-file --no-dereference orig/Makefile.am src/Makefile.am
--- orig/Makefile.am	2016-12-15 17:28:43.000000000 +0000
+++ src/Makefile.am	2024-01-26 11:00:37.000000000 +0000
@@ -9,3 +9,6 @@
 if WITH_MINIPORTAL
 SUBDIRS += miniportal
 endif
+#if WITH_UBUS
+#SUBDIRS += lchilli
+#endif
diff --recursive --unified --new-file --no-dereference orig/README.md src/README.md
--- orig/README.md	2016-12-15 17:28:43.000000000 +0000
+++ src/README.md	2024-01-26 11:00:37.000000000 +0000
@@ -27,3 +27,14 @@
   `make`
 
 More details about the build process and dependencies are covered in the [INSTALL file](/INSTALL)
+
+## UBUS Methods
+
+The following methods are exposed over `ubus`:
+
+**Object: chilli**
+
+Path | Procedure | Signature | Description
+--- | --- | --- | ---
+chilli | list | `{"ip":"String","mac":"String","sessionid":"String"}` | List sessions. Params: `ip` - ip address (optional), mac - mac address (optional), sessionid - session ID (optional).
+chilli | logout | `{"ip":"String","mac":"String","sessionid":"String"}` | Logoff active user. Params: `ip` - ip address (optional), mac - mac address (optional), sessionid - session ID (optional). At least one parameter required.
diff --recursive --unified --new-file --no-dereference orig/changelog src/changelog
--- orig/changelog	1970-01-01 00:00:00.000000000 +0000
+++ src/changelog	2024-01-26 11:00:37.000000000 +0000
@@ -0,0 +1,9 @@
+# 2019-12-19
+	*New
+		* SMS authentication added
+		* MAC based authentication added
+		* Signup method added
+		* Additional user scripts added
+		* New session param added "expirationtime"
+		* TOS requirement added
+		* Configurable url params added
diff --recursive --unified --new-file --no-dereference orig/conf/profiles/configs/cloud4wi src/conf/profiles/configs/cloud4wi
--- orig/conf/profiles/configs/cloud4wi	1970-01-01 00:00:00.000000000 +0000
+++ src/conf/profiles/configs/cloud4wi	2024-01-26 11:00:37.000000000 +0000
@@ -0,0 +1,33 @@
+config group
+	option name 'default'
+	
+config chilli
+	option enabled '0'
+	option net '192.168.2.0/24'
+	option uamlisten '192.168.2.254'
+	option dns1 '8.8.8.8'
+	option dns2 '8.8.4.4'
+	option uamlogoutip '1.0.0.0'
+	option radiusauthport '1812'
+	option radiusacctport '1813'
+	option uamport '3990'
+	option ipup '/etc/chilli/up.sh'
+	option ipdown '/etc/chilli/down.sh'
+	option dbpath '/var/hotspot.db'
+	option usersdbpath '/etc/chilli/users.db'
+	option _success 'uam'
+	option _mode 'radius'
+	option _landingpage 'ext'
+	option uamserver 'https://splashportal.cloud4wi.com?vendor=teltonika'
+	option radiusserver1 '54.247.117.188'
+	option radiusserver2 '79.125.111.180'
+	option uamdomainfile '/etc/chilli/uamdomains/uamdomainfile_cloud4wi'
+	option paramuamip 'nas_ip'
+	option paramuamport 'nas_port'
+	option paramcalled 'ap_mac'
+	option parammac 'client_mac'
+	option paramip 'client_ip'
+	option paramnasid 'identifer'
+	option paramuserurl 'redirect_url'
+	option param1 'version'
+	option param1value ''
diff --recursive --unified --new-file --no-dereference orig/conf/profiles/configs/default src/conf/profiles/configs/default
--- orig/conf/profiles/configs/default	1970-01-01 00:00:00.000000000 +0000
+++ src/conf/profiles/configs/default	2024-01-26 11:00:37.000000000 +0000
@@ -0,0 +1,19 @@
+config group
+	option name 'default'
+
+config chilli
+	option enabled '0'
+	option net '192.168.2.0/24'
+	option uamlisten '192.168.2.254'
+	option dns1 '8.8.8.8'
+	option dns2 '8.8.4.4'
+	option uamlogoutip '1.0.0.0'
+	option uamport '3990'
+	option ipup '/etc/chilli/up.sh'
+	option ipdown '/etc/chilli/down.sh'
+	option dbpath '/var/hotspot.db'
+	option usersdbpath '/etc/chilli/users.db'
+	option _mode 'local'
+	option _landingpage 'int'
+	option _success 'uam'
+	option _protocol 'http'
diff --recursive --unified --new-file --no-dereference orig/conf/profiles/configs/hotspotsystems src/conf/profiles/configs/hotspotsystems
--- orig/conf/profiles/configs/hotspotsystems	1970-01-01 00:00:00.000000000 +0000
+++ src/conf/profiles/configs/hotspotsystems	2024-01-26 11:00:37.000000000 +0000
@@ -0,0 +1,26 @@
+config group
+	option name 'default'
+	
+config chilli
+	option enabled '0'
+	option net '192.168.2.0/24'
+	option uamlisten '192.168.2.254'
+	option dns1 '8.8.8.8'
+	option dns2 '8.8.4.4'
+	option uamlogoutip '1.0.0.0'
+	option radiusauthport '1812'
+	option radiusacctport '1813'
+	option uamport '3990'
+	option ipup '/etc/chilli/up.sh'
+	option ipdown '/etc/chilli/down.sh'
+	option dbpath '/var/hotspot.db'
+	option usersdbpath '/etc/chilli/users.db'
+	option _success 'uam'
+	option _mode 'radius'
+	option _landingpage 'ext'
+	option uamdomainfile '/etc/chilli/uamdomains/uamdomainfile_hs
+	option uamserver 'https://customer.hotspotsystem.com/customer/hotspotlogin.php'
+	option uamsecret 'hotsys123'
+	option radiusserver1 'radius.hotspotsystem.com'
+	option radiusserver2 'radius2.hotspotsystem.com'
+	option radiussecret 'hotsys123'
diff --recursive --unified --new-file --no-dereference orig/conf/profiles/configs/purple src/conf/profiles/configs/purple
--- orig/conf/profiles/configs/purple	1970-01-01 00:00:00.000000000 +0000
+++ src/conf/profiles/configs/purple	2024-01-26 11:00:37.000000000 +0000
@@ -0,0 +1,31 @@
+config group
+	option name 'default'
+
+config chilli
+	option enabled '0'
+	option net '192.168.2.0/24'
+	option uamlisten '192.168.2.254'
+	option dns1 '8.8.8.8'
+	option dns2 '8.8.4.4'
+	option uamlogoutip '1.0.0.0'
+	option radiusauthport '1812'
+	option radiusacctport '1813'
+	option uamport '3990'
+	option ipup '/etc/chilli/up.sh'
+	option ipdown '/etc/chilli/down.sh'
+	option dbpath '/var/hotspot.db'
+	option usersdbpath '/etc/chilli/users.db'
+	option _success 'uam'
+	option _mode 'radius'
+	option _landingpage 'ext'
+	option _https '0'
+	option tos '0'
+	option trialusers '0'
+	option uamdomainfile '/etc/chilli/uamdomains/uamdomainfile_purple'
+	option uamserver 'https://purpleportal.net/access/'
+	option uamsecret 'uam175564uam'
+	option radiusserver1 'rad1-eu.venuewifi.net'
+	option radiusserver2 'rad2-eu.venuewifi.net'
+	option radiussecret '6n8!5ETGb^nd'
+	option radiusnasid 'guest'
+	option swapoctets '1'
diff --recursive --unified --new-file --no-dereference orig/conf/profiles/uamdomains/uamdomainfile_cloud4wi src/conf/profiles/uamdomains/uamdomainfile_cloud4wi
--- orig/conf/profiles/uamdomains/uamdomainfile_cloud4wi	1970-01-01 00:00:00.000000000 +0000
+++ src/conf/profiles/uamdomains/uamdomainfile_cloud4wi	2024-01-26 11:00:37.000000000 +0000
@@ -0,0 +1,5 @@
+cloud4wi.com
+facebook.com
+facebook.net
+flinkedin.com
+licdn.com
diff --recursive --unified --new-file --no-dereference orig/conf/profiles/uamdomains/uamdomainfile_hs src/conf/profiles/uamdomains/uamdomainfile_hs
--- orig/conf/profiles/uamdomains/uamdomainfile_hs	1970-01-01 00:00:00.000000000 +0000
+++ src/conf/profiles/uamdomains/uamdomainfile_hs	2024-01-26 11:00:37.000000000 +0000
@@ -0,0 +1,2 @@
+hotspotsystem.com
+facebook.com
diff --recursive --unified --new-file --no-dereference orig/conf/profiles/uamdomains/uamdomainfile_purple src/conf/profiles/uamdomains/uamdomainfile_purple
--- orig/conf/profiles/uamdomains/uamdomainfile_purple	1970-01-01 00:00:00.000000000 +0000
+++ src/conf/profiles/uamdomains/uamdomainfile_purple	2024-01-26 11:00:37.000000000 +0000
@@ -0,0 +1,5 @@
+purpleportal.net
+venuewifi.com
+cloudfront.net
+openweathermap.org
+stripe.com
diff --recursive --unified --new-file --no-dereference orig/conf/up.sh.in src/conf/up.sh.in
--- orig/conf/up.sh.in	2016-12-15 17:28:43.000000000 +0000
+++ src/conf/up.sh.in	2024-01-26 11:00:37.000000000 +0000
@@ -10,97 +10,45 @@
 
 ipt() {
     opt=$1; shift
-    echo "iptables -D $*" >> $UNDO_FILE
-    iptables $opt $*
+    echo "iptables --wait -D $*" >> $UNDO_FILE
+    iptables --wait $opt $*
 }
 
 ipt_in() {
     ipt -I INPUT -i $TUNTAP $*
 }
 
-run_up() {
-    if [ -n "$TUNTAP" ]
-    then
-        # ifconfig $TUNTAP mtu $MTU
+
+if [ -n "$TUNTAP" ]
+then
 	if [ "$KNAME" != "" ]
 	then
-	    ipt -I FORWARD -i $DHCPIF -m coova --name $KNAME -j ACCEPT 
-	    ipt -I FORWARD -o $DHCPIF -m coova --name $KNAME --dest -j ACCEPT
-	    ipt -I FORWARD -i $TUNTAP -j ACCEPT
-	    ipt -I FORWARD -o $TUNTAP -j ACCEPT
-	    [ -n "$DHCPLISTEN" ] && ifconfig $DHCPIF $DHCPLISTEN
+		[ -n "$DHCPLISTEN" ] && ifconfig $DHCPIF $DHCPLISTEN
 	else
-	    if [ "$LAYER3" != "1" ]
-	    then
-		ipt_in --dst $ADDR -j DROP
-		
-		[ -n "$UAMPORT" -a "$UAMPORT" != "0" ] && \
-		    ipt_in -p tcp -m tcp --dport $UAMPORT --dst $ADDR -j ACCEPT
-		
-		[ -n "$UAMUIPORT" -a "$UAMUIPORT" != "0" ] && \
-		    ipt_in -p tcp -m tcp --dport $UAMUIPORT --dst $ADDR -j ACCEPT
-		
-		[ -n "$HS_TCP_PORTS" ] && {
-		    for port in $HS_TCP_PORTS; do
-			ipt_in -p tcp -m tcp --dport $port --dst $ADDR -j ACCEPT
-		    done
-		}
+		IFS=' '
+		IFS=$' \t\n'
 
-		[ -n "$HS_UDP_PORTS" ] && {
-		    for port in $HS_UDP_PORTS; do
-			ipt_in -p udp -m udp --dport $port --dst $ADDR -j ACCEPT
-		    done
+		[ "$HS_LOCAL_DNS" = "on" ] && {
+			ipt -A PREROUTING -t nat -i $TUNTAP -p udp --dport 53 -j DNAT --to-destination $ADDR
 		}
 
-		ipt_in -p udp -d 255.255.255.255 --destination-port 67:68 -j ACCEPT
-		ipt_in -p udp -d $ADDR --destination-port 67:68 -j ACCEPT
-		ipt_in -p udp --dst $ADDR --dport 53 -j ACCEPT
-		ipt_in -p icmp --dst $ADDR -j ACCEPT
-		
+		ipt -I FORWARD -t mangle -p tcp -m tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu
+		ipt -I FORWARD -p tcp -m tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu
+
 		if [ "$ONLY8021Q" != "1" ]
 		then
-		    ipt -I INPUT -i $DHCPIF -j DROP
+			ipt -I FORWARD -o $DHCPIF -j DROP
+			ipt -A forwarding_rule -i $DHCPIF -j DROP
+		fi
+		if [ "$LAYER3" != "1" ]
+		then
+			if [ "$ONLY8021Q" != "1" ]
+			then
+				ipt -I INPUT -i $DHCPIF -j DROP
+			fi
 		fi
-	    fi
-	    
-	    if [ "$ONLY8021Q" != "1" ]
-	    then
-		ipt -I FORWARD -i $DHCPIF -j DROP
-		ipt -I FORWARD -o $DHCPIF -j DROP
-	    fi
-	    
-	    ipt -I FORWARD -i $TUNTAP -j ACCEPT
-	    ipt -I FORWARD -o $TUNTAP -j ACCEPT
-	    
-            # Help out conntrack to not get confused
-            # (stops masquerading from working)
-            #ipt -I PREROUTING -t raw -j NOTRACK -i $DHCPIF
-            #ipt -I OUTPUT -t raw -j NOTRACK -o $DHCPIF
-	    
-            # Help out MTU issues with PPPoE or Mesh
-	    ipt -I FORWARD -p tcp -m tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu
-	    ipt -I FORWARD -t mangle -p tcp -m tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu
-	    
-	    [ "$HS_LAN_ACCESS" != "on" -a "$HS_LAN_ACCESS" != "allow" ] && \
-		ipt -I FORWARD -i $TUNTAP \! -o $HS_WANIF -j DROP
-	    
-	    ipt -I FORWARD -i $TUNTAP -o $HS_WANIF -j ACCEPT
-	    
-	    [ "$HS_LOCAL_DNS" = "on" ] && \
-		ipt -I PREROUTING -t nat -i $TUNTAP -p udp --dport 53 -j DNAT --to-destination $ADDR
 	fi
-    fi
-
-    # site specific stuff optional
-    [ -e @ETCCHILLI@/ipup.sh ] && . @ETCCHILLI@/ipup.sh
-}
-
-
-FLOCK=$(which flock)
-if [ -n "$FLOCK" ] && [ -z "$LOCKED_FILE" ]
-then
-    export LOCKED_FILE=/tmp/.chilli-flock
-    flock -x $LOCKED_FILE -c "$0 $@"
-else
-    run_up
 fi
+
+# site specific stuff optional
+[ -e @ETCCHILLI@/ipup.sh ] && . @ETCCHILLI@/ipup.sh
diff --recursive --unified --new-file --no-dereference orig/configure.ac src/configure.ac
--- orig/configure.ac	2016-12-15 17:28:43.000000000 +0000
+++ src/configure.ac	2024-01-26 11:00:37.000000000 +0000
@@ -154,8 +154,17 @@
    AC_DEFINE(ENABLE_CHILLIQUERY,1,[Define to enable chilli_query])
 fi
 
+AC_ARG_ENABLE(ubus, [AS_HELP_STRING([--disable-ubus],[Disable ubus])],
+  enable_ubus=$enableval, enable_ubus=yes)
+
+if test x"$enable_ubus" = xyes; then
+   AC_DEFINE(ENABLE_UBUS,1,[Define to enable ubus])
+fi
+
 AM_CONDITIONAL(WITH_CHILLIQUERY, [test x"$enable_chilliquery" != xno])
 
+AM_CONDITIONAL(WITH_UBUS, [test x"$enable_ubus" != xno])
+
 AC_ARG_ENABLE(leakybucket, [AS_HELP_STRING([--disable-leakybucket],[disable use of leaky bucket shaping])], 
   enable_leakybucket=$enableval, enable_leakybucket=yes)
 
@@ -206,7 +215,7 @@
 fi
 
 AC_ARG_ENABLE(json, [AS_HELP_STRING([--enable-json],[Enable support for JSON])], 
-  enable_json=$enableval, enable_json=no)
+  enable_json=$enableval, enable_json=yes)
 
 if test x"$enable_json" = xyes; then
    AC_DEFINE(ENABLE_JSON,1,[Define to enable Chilli JSON])
@@ -396,6 +405,9 @@
 AC_ARG_WITH([cyassl],
  [AS_HELP_STRING([--with-cyassl], [enable support for cyassl])],[],[with_cyassl=no])
 
+AC_ARG_WITH([cyassl],
+ [AS_HELP_STRING([--with-cyassl], [enable support for cyassl])],[],[with_cyassl=no])
+
 AS_IF([test x"$with_cyassl" != xno],
   [AC_CHECK_LIB([cyassl], [CyaSSL_Init],
               [AC_SUBST([LIBSSL], ["-lcyassl"])
@@ -598,6 +610,24 @@
 
 AM_CONDITIONAL(WITH_CHILLIREDIR, [test x"$enable_chilliredir" = xyes])
 
+AC_ARG_ENABLE(database, [AS_HELP_STRING([--enable-database],[Enable support sqlite database])],
+  enable_database=$enableval, enable_database=no)
+
+if test x"$enable_database" = xyes; then
+   AC_DEFINE(ENABLE_DATABASE,1,[Define to enable sqlite database])
+fi
+
+AM_CONDITIONAL(WITH_DATABASE, [test x"$enable_database" = xyes])
+
+AC_ARG_ENABLE(gsm, [AS_HELP_STRING([--enable-gsm],[Enable gsm support])],
+  enable_gsm=$enableval, enable_gsm=no)
+
+if test x"$enable_gsm" = xyes; then
+   AC_DEFINE(ENABLE_GSM,1,[Define to enable gsm support])
+fi
+
+AM_CONDITIONAL(WITH_GSM, [test x"$enable_gsm" = xyes])
+
 AC_ARG_ENABLE(chilliscript, [AS_HELP_STRING([--enable-chilliscript],[Enable support for chilli_script helper])], 
   enable_chilliscript=$enableval, enable_chilliscript=no)
 
@@ -830,7 +860,7 @@
 AM_CONDITIONAL(WITH_CONFIG, [test x"$enable_config" = xyes])
 
 AC_SUBST(sysconfdir)
-AC_CONFIG_FILES([Makefile 
+AC_CONFIG_FILES([Makefile
 		 bstring/Makefile 
 		 conf/Makefile
 		 debian/Makefile
diff --recursive --unified --new-file --no-dereference orig/doc/attributes src/doc/attributes
--- orig/doc/attributes	2016-12-15 17:28:43.000000000 +0000
+++ src/doc/attributes	2024-01-26 11:00:37.000000000 +0000
@@ -8,7 +8,7 @@
 Service-Type      :     6 : Integer : X : - : X : - : - : Set to Login (1) for normal authentication requests.  The Access-Accept message from the radius server for configuration management messages must also be set to Administrative-User.
 Framed-IP-Address : 	8 : IPaddr  : X : X : X : - : - : IP address of the user, which is configurable during MAC authentication in the Access-Accept.
 Framed-IP-Netmask : 	9 : IPaddr  : - : X : - : - : - : IP netmask of the user, which is configurable during MAC authentication in the Access-Accept.
-Filter-ID         :    11 : String  : - : X : - : X : X : Filter ID pass on to scripts possibly. 
+Filter-ID         :    11 : String  : - : X : - : X : X : Filter ID pass on to scripts possibly.
 Reply-Message     :    18 : String  : - : X : - : - : - : Reason of reject if present.
 State             :    24 : String  : X : X : - : - : - : Sent to chilli in Access-Accept or Access-Challenge. Used transparently in subsequent Access-Request.
 Class             :    25 : String  : - : X : X : - : - : Copied transparently by chilli from Access-Accept to Accounting-Request.
diff --recursive --unified --new-file --no-dereference orig/doc/chilli_query.1.in src/doc/chilli_query.1.in
--- orig/doc/chilli_query.1.in	2016-12-15 17:28:43.000000000 +0000
+++ src/doc/chilli_query.1.in	2024-01-26 11:00:37.000000000 +0000
@@ -115,6 +115,10 @@
 Sets the max output data limit of the session.
 
 .TP
+.BI warningoctets " <number-of-bytes>"
+Sets the data threshold for the session over which an SMS warning is sent.
+
+.TP
 .BI maxbwup " <bandwidth>"
 Sets the max up bandwidth of the session.
 
diff --recursive --unified --new-file --no-dereference orig/json/linkhash.c src/json/linkhash.c
--- orig/json/linkhash.c	2016-12-15 17:28:43.000000000 +0000
+++ src/json/linkhash.c	2024-01-26 11:00:37.000000000 +0000
@@ -52,15 +52,6 @@
 	return 0;
 }
 
-void lh_abort(const char *msg, ...)
-{
-	va_list ap;
-	va_start(ap, msg);
-	vprintf(msg, ap);
-	va_end(ap);
-	exit(1);
-}
-
 static unsigned long lh_ptr_hash(const void *k)
 {
 	/* CAW: refactored to be 64bit nice */
diff --recursive --unified --new-file --no-dereference orig/json/linkhash.h src/json/linkhash.h
--- orig/json/linkhash.h	2016-12-15 17:28:43.000000000 +0000
+++ src/json/linkhash.h	2024-01-26 11:00:37.000000000 +0000
@@ -294,21 +294,6 @@
 extern int lh_table_length(struct lh_table *t);
 
 /**
- * Prints a message to <code>stdout</code>,
- * then exits the program with an exit code of <code>1</code>.
- *
- * @param msg Message format string, like for <code>printf</code>.
- * @param ... Format args.
- *
- * @deprecated Since it is not a good idea to exit the entire program
- * 	because of an internal library failure, json-c will no longer
- * 	use this function internally.
- * 	However, because its interface is public, it will remain part of
- * 	the API on the off chance of legacy software using it externally.
- */
-void lh_abort(const char *msg, ...);
-
-/**
  * Resizes the specified table.
  *
  * @param t Pointer to table to resize.
diff --recursive --unified --new-file --no-dereference orig/src/Makefile.am src/src/Makefile.am
--- orig/src/Makefile.am	2016-12-15 17:28:43.000000000 +0000
+++ src/src/Makefile.am	2024-01-26 11:00:37.000000000 +0000
@@ -12,34 +12,35 @@
 tun.h ippool.h md5.h redir.h dhcp.h iphash.h \
 radius_wispr.h radius_coovachilli.h ssl.h dns.h net.h \
 pkt.h conn.h lookup.h chilli_limits.h cmdline.h debug.h \
-radius_pkt.h ../bstring/bstrlib.h ../config.h system.h 
+radius_pkt.h ../bstring/bstrlib.h ../config.h system.h \
+ sqlite.h users.h
 
 lib_LTLIBRARIES = libchilli.la
 sbin_PROGRAMS = \
-chilli chilli_response chilli_radconfig chilli_opt 
+chilli chilli_response chilli_radconfig chilli_opt
 
 suid_programs =
 
 libchilli_la_SOURCES = \
 chilli.c tun.c ippool.c radius.c md5.c redir.c dhcp.c \
 iphash.c lookup.c system.h util.c options.c statusfile.c conn.c sig.c \
-garden.c dns.c session.c pkt.c chksum.c net.c safe.c
+garden.c dns.c session.c pkt.c chksum.c net.c safe.c sqlite.c users.c
 
 AM_CFLAGS = -D_GNU_SOURCE -Wall -Werror -fno-builtin -fno-strict-aliasing \
   -fomit-frame-pointer -funroll-loops -pipe -I$(top_builddir)/bstring \
  -DDEFCHILLICONF='"$(sysconfdir)/chilli.conf"'\
  -DDEFPIDFILE='"$(localstatedir)/run/chilli.pid"'\
  -DDEFSTATEDIR='"$(localstatedir)/run"'\
- -DSBINDIR='"$(sbindir)"' 
+ -DSBINDIR='"$(sbindir)"'
 
 chilli_SOURCES= main.c
-chilli_radconfig_SOURCES = main-radconfig.c 
-chilli_response_SOURCES = main-response.c 
-chilli_query_SOURCES = main-query.c 
-chilli_opt_SOURCES = main-opt.c 
+chilli_radconfig_SOURCES = main-radconfig.c
+chilli_response_SOURCES = main-response.c
+chilli_query_SOURCES = main-query.c
+chilli_opt_SOURCES = main-opt.c
 
-libchilli_la_LIBADD = $(top_builddir)/bstring/libbstring.la 
-LDADD = libchilli.la ${LIBRT} $(top_builddir)/bstring/libbstring.la ${LIBJSON}
+libchilli_la_LIBADD = $(top_builddir)/bstring/libbstring.la -lsqlite3 -luci -ltlt_uci
+LDADD = libchilli.la ${LIBRT} $(top_builddir)/bstring/libbstring.la ${LIBJSON} -lsqlite3
 
 if WITH_MINICONFIG
 chilli_opt_SOURCES += cmdline.mini.c
@@ -54,7 +55,7 @@
 if WITH_JSONLIB
 AM_CFLAGS += -I$(top_builddir)/json
 libchilli_la_LIBADD += $(top_builddir)/json/libjson.la 
-LDADD += $(top_builddir)/json/libjson.la 
+LDADD += $(top_builddir)/json/libjson.la
 endif
 
 if WITH_EWTAPI
@@ -75,6 +76,8 @@
 endif
 
 if WITH_OPENSSL
+libchilli_la_SOURCES += passwd_md5crypt.c passwd_shacrypt.c
+chilliinclude_HEADERS += passwd_md5crypt.h passwd_shacrypt.h
 libchilli_la_LIBADD += ${LIBSSL}
 LDADD += ${LIBSSL}
 endif
@@ -93,6 +96,25 @@
 endif
 endif
 
+if WITH_GSM
+libchilli_la_SOURCES += gsm.c
+chilliinclude_HEADERS += gsm.h
+libchilli_la_LIBADD += -lgsm -lgsm_utils
+LDADD += -lgsm
+endif
+
+if WITH_DATABASE
+libchilli_la_SOURCES += database.c
+chilliinclude_HEADERS += database.h
+endif
+
+if WITH_UBUS
+chilliinclude_HEADERS += ubus.h
+libchilli_la_SOURCES += ubus.c
+libchilli_la_LIBADD += -lubox -lubus
+LDADD += -lubox -lubus
+endif
+
 if WITH_AVL
 libchilli_la_SOURCES += avl/avl.c avl/avl.h avl/list.h \
 avl/common_types.h avl/container_of.h
diff --recursive --unified --new-file --no-dereference orig/src/chilli.c src/src/chilli.c
--- orig/src/chilli.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/chilli.c	2024-01-26 11:00:37.000000000 +0000
@@ -20,10 +20,13 @@
 
 #include "chilli.h"
 #include "bstrlib.h"
+#include "ubus.h"
 #ifdef ENABLE_MODULES
 #include "chilli_module.h"
 #endif
 
+
+
 struct tun_t *tun;                /* TUN instance            */
 struct ippool_t *ippool;          /* Pool of IP addresses */
 struct radius_t *radius;          /* Radius client instance */
@@ -42,6 +45,9 @@
 struct app_conn_t *lastusedconn=0;  /* Last used in linked list */
 struct app_conn_t admin_session;
 
+struct ubus_context *g_ubus_event_ctx; /* Ubus for sending events
+                                          about connected/disconnected clients */
+
 struct timespec mainclock;
 time_t checktime;
 time_t rereadtime;
@@ -80,6 +86,8 @@
 static pid_t redir_pid = 0;
 #endif
 
+
+
 typedef struct child {
   pid_t pid;
   uint8_t type;
@@ -214,7 +222,7 @@
   while ((read = getline(&line, &len, fp)) != -1) {
     if (!memcmp(line, name, strlen(name))) {
       int i;
-      if (sscanf(line+strlen(name)+1, "%d %s", &i, buffer) == 2) {
+      if (sscanf(line+strlen(name)+1, "%d %128s", &i, buffer) == 2) {
 	ret = i;
 	if (buffer[0] == 'm') ret *= 1000;
 	else if (buffer[0] == 'g') ret *= 1000000;
@@ -463,7 +471,7 @@
 #ifdef HAVE_LIBRT
   struct timespec ts;
 #if defined(CLOCK_MONOTONIC)
-  clockid_t cid = CLOCK_MONOTONIC;
+  clockid_t cid = _options.testtime ? CLOCK_REALTIME : CLOCK_MONOTONIC;
 #else
   clockid_t cid = CLOCK_REALTIME;
 #endif
@@ -818,6 +826,7 @@
   set_env("COOVACHILLI_MAX_INPUT_OCTETS", VAL_ULONG64, &appconn->s_params.maxinputoctets, 0);
   set_env("COOVACHILLI_MAX_OUTPUT_OCTETS", VAL_ULONG64, &appconn->s_params.maxoutputoctets, 0);
   set_env("COOVACHILLI_MAX_TOTAL_OCTETS", VAL_ULONG64, &appconn->s_params.maxtotaloctets, 0);
+  set_env("COOVACHILLI_WARNING_OCTETS", VAL_ULONG64, &appconn->s_params.warningoctets, 0);
   set_env("INPUT_OCTETS", VAL_ULONG64, &appconn->s_state.input_octets, 0);
   set_env("OUTPUT_OCTETS", VAL_ULONG64, &appconn->s_state.output_octets, 0);
   set_env("INPUT_PACKETS", VAL_ULONG64, &appconn->s_state.input_packets, 0);
@@ -1037,6 +1046,7 @@
 
 static int dnprot_terminate(struct app_conn_t *appconn) {
   appconn->s_state.authenticated = 0;
+  send_ubus_event(g_ubus_event_ctx, CHILLI_EVENT_DISCONNECT, appconn, NULL);
 #ifdef ENABLE_SESSIONSTATE
   appconn->s_state.session_state = 0;
 #endif
@@ -1085,7 +1095,25 @@
   return 0;
 }
 
+#ifdef ENABLE_GSM
+int send_warning_sms(uint64_t used, uint64_t warning, uint64_t limit, char *direction, char *phone)
+{
+	if (!limit || used < warning) {
+		// Only return 0 on successful SMS send.
+		return -1;
+	}
+
+	char sms_text[256] = { 0 };
+	float left	   = (used > limit) ? 0 : (float)(limit - used) / 1000000.f;
+
+	sprintf(sms_text, WARNING_FMT, direction, left, "MB");
+	syslog(LOG_INFO, "%s(%d): Sending SMS: %s\n", __FUNCTION__, __LINE__, sms_text);
 
+	chilli_send_sms_async(phone, sms_text, _options.modemid);
+
+	return 0;
+}
+#endif
 
 /* Check for:
  * - Session-Timeout
@@ -1104,12 +1132,50 @@
   interimtime = mainclock_diffu(conn->s_state.interim_time);
 
   if (conn->s_state.authenticated == 1) {
+#ifdef ENABLE_GSM
+#if(_debug_ > 1)
+	  if (conn->s_params.maxinputoctets > conn->s_state.input_octets)
+		  syslog(LOG_INFO, "warning_sent_download %d | download used %.1f left %.1f",
+			 conn->s_state.warning_sent_download, (float)conn->s_state.input_octets / 1000000.f,
+			 (float)(conn->s_params.maxinputoctets - conn->s_state.input_octets) / 1000000.f);
+	  if (conn->s_params.maxoutputoctets > conn->s_state.output_octets)
+		  syslog(LOG_INFO, "  warning_sent_upload %d |   upload used %.1f left %.1f",
+			 conn->s_state.warning_sent_upload, (float)conn->s_state.output_octets / 1000000.f,
+			 (float)(conn->s_params.maxoutputoctets - conn->s_state.output_octets) / 1000000.f);
+#endif
+
+	  if (conn->s_params.warningoctets > 0 && !conn->s_state.warning_sent_download &&
+	      !send_warning_sms(conn->s_state.input_octets, conn->s_params.warningoctets,
+				 conn->s_params.maxinputoctets, "download", conn->s_state.redir.phone)) {
+		  conn->s_state.warning_sent_download = 1;
+	  }
+
+	  if (conn->s_params.warningoctets > 0 && !conn->s_state.warning_sent_upload &&
+	      !send_warning_sms(conn->s_state.output_octets, conn->s_params.warningoctets,
+				 conn->s_params.maxoutputoctets, "upload", conn->s_state.redir.phone)) {
+		  conn->s_state.warning_sent_upload = 1;
+	  }
+#endif
+
     if ((conn->s_params.sessiontimeout) &&
 	(sessiontime > conn->s_params.sessiontimeout)) {
 #ifdef ENABLE_SESSIONSTATE
       conn->s_state.session_state =
           RADIUS_VALUE_COOVACHILLI_SESSION_TIMEOUT_REACHED;
 #endif
+      conn->s_state.terminate_cause_ui = RADIUS_VALUE_COOVACHILLI_SESSION_TIMEOUT_REACHED;
+      terminate_appconn(conn, RADIUS_TERMINATE_CAUSE_SESSION_TIMEOUT);
+    }
+    else if (conn->s_params.expiration &&
+			 (conn->s_state.redir.auth_mode == AUTH_DYN_USER ||
+			  conn->s_state.redir.auth_mode == AUTH_SMS_USER) &&
+			 (sessiontime + conn->s_state.redir.user_time > conn->s_params.expiration))
+    {
+#ifdef ENABLE_SESSIONSTATE
+      conn->s_state.session_state =
+          RADIUS_VALUE_COOVACHILLI_SESSION_TIMEOUT_REACHED;
+#endif
+      conn->s_state.terminate_cause_ui = RADIUS_VALUE_COOVACHILLI_SESSION_USER_EXPIRED;
       terminate_appconn(conn, RADIUS_TERMINATE_CAUSE_SESSION_TIMEOUT);
     }
     else if ((conn->s_params.sessionterminatetime) &&
@@ -1118,6 +1184,8 @@
       conn->s_state.session_state =
           RADIUS_VALUE_COOVACHILLI_SESSION_LOGOUT_TIME_REACHED;
 #endif
+      conn->s_state.terminate_cause_ui =
+              RADIUS_VALUE_COOVACHILLI_SESSION_LOGOUT_TIME_REACHED;
       terminate_appconn(conn, RADIUS_TERMINATE_CAUSE_SESSION_TIMEOUT);
     }
     else if ((conn->s_params.idletimeout) &&
@@ -1126,6 +1194,8 @@
       conn->s_state.session_state =
           RADIUS_VALUE_COOVACHILLI_SESSION_IDLE_TIMEOUT_REACHED;
 #endif
+      conn->s_state.terminate_cause_ui =
+              RADIUS_VALUE_COOVACHILLI_SESSION_IDLE_TIMEOUT_REACHED;
       terminate_appconn(conn, RADIUS_TERMINATE_CAUSE_IDLE_TIMEOUT);
     }
     else if ((conn->s_params.maxinputoctets) &&
@@ -1134,6 +1204,8 @@
       conn->s_state.session_state =
           RADIUS_VALUE_COOVACHILLI_SESSION_IN_DATALIMIT_REACHED;
 #endif
+      conn->s_state.terminate_cause_ui =
+              RADIUS_VALUE_COOVACHILLI_SESSION_IN_DATALIMIT_REACHED;
       terminate_appconn(conn, RADIUS_TERMINATE_CAUSE_SESSION_TIMEOUT);
     }
     else if ((conn->s_params.maxoutputoctets) &&
@@ -1142,6 +1214,8 @@
       conn->s_state.session_state =
           RADIUS_VALUE_COOVACHILLI_SESSION_OUT_DATALIMIT_REACHED;
 #endif
+      conn->s_state.terminate_cause_ui =
+              RADIUS_VALUE_COOVACHILLI_SESSION_OUT_DATALIMIT_REACHED;
       terminate_appconn(conn, RADIUS_TERMINATE_CAUSE_SESSION_TIMEOUT);
     }
     else if ((conn->s_params.maxtotaloctets) &&
@@ -1151,6 +1225,8 @@
       conn->s_state.session_state =
           RADIUS_VALUE_COOVACHILLI_SESSION_TOTAL_DATALIMIT_REACHED;
 #endif
+      conn->s_state.terminate_cause_ui =
+              RADIUS_VALUE_COOVACHILLI_SESSION_TOTAL_DATALIMIT_REACHED;
       terminate_appconn(conn, RADIUS_TERMINATE_CAUSE_SESSION_TIMEOUT);
     }
     else if ((conn->s_params.interim_interval) &&
@@ -1172,7 +1248,57 @@
 
       acct_req(ACCT_USER, conn, RADIUS_STATUS_TYPE_INTERIM_UPDATE);
     }
+#ifdef ENABLE_DATABASE
+      if (conn->s_params.sessiontimeout) {
+          uint32_t sessiontime_total = conn->s_history.sessiontime + sessiontime;
+
+          if (sessiontime_total > conn->s_params.sessiontimeout){
+#ifdef ENABLE_SESSIONSTATE
+              conn->s_state.session_state =
+            RADIUS_VALUE_COOVACHILLI_SESSION_TIMEOUT_REACHED;
+#endif
+               conn->s_state.terminate_cause_ui =
+            	RADIUS_VALUE_COOVACHILLI_SESSION_TIMEOUT_REACHED;
+              terminate_appconn(conn, RADIUS_TERMINATE_CAUSE_SESSION_TIMEOUT);
+              return;
+          }
+
+      }
+      if (conn->s_params.maxinputoctets) {
+          uint64_t maxinputoctets_total = conn->s_state.input_octets + conn->s_history.input_octets;
+
+          if (maxinputoctets_total > conn->s_params.maxinputoctets) {
+#ifdef ENABLE_SESSIONSTATE
+              conn->s_state.session_state =
+                RADIUS_VALUE_COOVACHILLI_SESSION_IN_DATALIMIT_REACHED;
+#endif
+              conn->s_state.terminate_cause_ui =
+                RADIUS_VALUE_COOVACHILLI_SESSION_IN_DATALIMIT_REACHED;
+              terminate_appconn(conn, RADIUS_TERMINATE_CAUSE_SESSION_TIMEOUT);
+              return;
+          }
+      }
+      if (conn->s_params.maxoutputoctets){
+          uint64_t maxoutputoctets_total = conn->s_state.output_octets + conn->s_history.output_octets;
+
+          if (maxoutputoctets_total > conn->s_params.maxoutputoctets) {
+#ifdef ENABLE_SESSIONSTATE
+              conn->s_state.session_state =
+                RADIUS_VALUE_COOVACHILLI_SESSION_OUT_DATALIMIT_REACHED;
+#endif
+              conn->s_state.terminate_cause_ui =
+                RADIUS_VALUE_COOVACHILLI_SESSION_OUT_DATALIMIT_REACHED;
+              terminate_appconn(conn, RADIUS_TERMINATE_CAUSE_SESSION_TIMEOUT);
+              return;
+          }
+      }
+#endif //ENABLE_DATABASE
+  }
+#if(_debug_ > 1)
+  else {
+  	syslog(LOG_INFO, "Not authenticated");
   }
+#endif
 #ifdef ENABLE_GARDENACCOUNTING
   interimtime = mainclock_diffu(conn->s_state.garden_interim_time);
   if (_options.uamgardendata &&
@@ -1206,6 +1332,11 @@
     session_interval(&admin_session);
   }
 
+#ifdef ENABLE_DATABASE
+  sqlite3 *db;
+  db = dbopen();
+#endif
+
   for (conn = firstusedconn; conn; conn=conn->next) {
     if (conn->inuse != 0) {
       if (
@@ -1216,6 +1347,10 @@
 	syslog(LOG_WARNING, "No downlink protocol");
 	continue;
       }
+#ifdef ENABLE_DATABASE
+      if (db && conn->s_state.authenticated)
+        dbupdate(db, conn);
+#endif
       session_interval(conn);
     }
   }
@@ -1229,6 +1364,10 @@
     }
   }
 
+#ifdef ENABLE_DATABASE
+    dbclose(db);
+#endif
+
   return 0;
 }
 
@@ -1796,6 +1935,7 @@
       switch(type) {
 #ifdef ENABLE_GARDENACCOUNTING
         case ACCT_GARDEN:
+             syslog(LOG_INFO, "ACCT_GARDEN set to zeros");
           snprintf(conn->s_state.garden_sessionid,
                         sizeof(conn->s_state.garden_sessionid),
                         "UAM-%s-%.8x%.8x", inet_ntoa(conn->hisip),
@@ -1813,6 +1953,9 @@
           conn->s_state.output_packets = 0;
           conn->s_state.input_octets = 0;
           conn->s_state.output_octets = 0;
+#ifdef ENABLE_DATABASE
+          dbsession_state(conn);
+#endif
           break;
       }
       break;
@@ -1838,7 +1981,7 @@
   /*
    *  Return if there is no RADIUS accounting for this session.
    */
-  if (conn->s_params.flags & NO_ACCOUNTING)
+  if ((conn->s_params.flags & NO_ACCOUNTING) || _options.localusers || _options.smsusers || _options.macusers)
     return 0;
 
   /*
@@ -2324,6 +2467,8 @@
   if (!(appconn->s_params.flags & REQUIRE_UAM_AUTH)) {
     /* This is the one and only place state is switched to authenticated */
     appconn->s_state.authenticated = 1;
+    appconn->s_state.terminate_cause_ui = 0;
+    send_ubus_event(g_ubus_event_ctx, CHILLI_EVENT_CONNECT, appconn, dhcpconn);
 
 #ifdef ENABLE_SESSIONSTATE
     appconn->s_state.session_state =
@@ -2352,12 +2497,15 @@
 
     /* if (!(appconn->s_params.flags & IS_UAM_REAUTH))*/
     acct_req(ACCT_USER, appconn, RADIUS_STATUS_TYPE_START);
-
+#ifdef ENABLE_DATABASE
+      dbconup(appconn);
+#endif
     /* Run connection up script */
     if (_options.conup && !(appconn->s_params.flags & NO_SCRIPT)) {
- if (_options.debug)
-     syslog(LOG_DEBUG, "%s(%d): Calling connection up script: %s\n", __FUNCTION__, __LINE__, _options.conup);
-      runscript(appconn, _options.conup, 0, 0);
+        if (_options.debug)
+            syslog(LOG_DEBUG, "%s(%d): Calling connection up script: %s\n",
+                   __FUNCTION__, __LINE__, _options.conup);
+        runscript(appconn, _options.conup, 0, 0);
     }
   }
 
@@ -3050,6 +3198,7 @@
     appconn->s_state.input_octets = 0;
     appconn->s_state.output_packets = 0;
     appconn->s_state.output_octets = 0;
+     syslog(LOG_INFO, "location set to zeros");
 
     acct_req(ACCT_USER, appconn, RADIUS_STATUS_TYPE_START);
   }
@@ -3926,7 +4075,6 @@
 }
 
 void session_param_defaults(struct session_params *params) {
-
   if (_options.defsessiontimeout && !params->sessiontimeout)
     params->sessiontimeout = _options.defsessiontimeout;
 
@@ -3941,6 +4089,52 @@
 
   if (_options.definteriminterval && !params->interim_interval)
     params->interim_interval = _options.definteriminterval;
+
+  if (_options.defmaxdownload && !params->maxinputoctets)
+    params->maxinputoctets = _options.defmaxdownload;
+
+  if (_options.defmaxupload && !params->maxoutputoctets)
+    params->maxoutputoctets = _options.defmaxupload;
+
+  if (_options.defwarning && !params->warningoctets)
+    params->warningoctets = _options.defwarning;
+
+  if (_options.deflimitperiod && !params->period)
+    params->period = _options.deflimitperiod;
+
+  if (_options.deflimitstart && !params->start)
+    params->start = _options.deflimitstart;
+
+  if (_options.defexpirationtime && !params->expiration)
+    params->expiration = _options.defexpirationtime;
+}
+
+void session_params_dyn(struct session_params *params) {
+    params->sessiontimeout = _options.dynsessiontimeout;
+    params->idletimeout = _options.dynidletimeout;
+    params->bandwidthmaxdown = _options.dynbandwidthmaxdown;
+    params->bandwidthmaxup = _options.dynbandwidthmaxup;
+    params->interim_interval = _options.dyninteriminterval;
+    params->maxinputoctets = _options.dynmaxdownload;
+    params->maxoutputoctets = _options.dynmaxupload;
+    params->warningoctets = _options.dynwarning;
+    params->period = _options.dynlimitperiod;
+    params->start = _options.dynlimitstart;
+    params->expiration = _options.dynexpirationtime;
+}
+
+void session_params_trial(struct session_params *params) {
+  params->sessiontimeout = _options.trialsessiontimeout;
+  params->idletimeout = _options.trialidletimeout;
+  params->bandwidthmaxdown = _options.trialbandwidthmaxdown;
+  params->bandwidthmaxup = _options.trialbandwidthmaxup;
+  params->interim_interval = _options.trialinteriminterval;
+  params->maxinputoctets = _options.trialmaxdownload;
+  params->maxoutputoctets = _options.trialmaxupload;
+  params->warningoctets = _options.trialwarning;
+  params->period = _options.triallimitperiod;
+  params->start = _options.triallimitstart;
+  params->expiration = _options.trialexpirationtime;
 }
 
 void
@@ -4044,6 +4238,14 @@
   else if (!reconfig)
     params->maxtotaloctets = 0;
 
+  /* Warning octets */
+  if (!radius_getattr(pack, &attr, RADIUS_ATTR_VENDOR_SPECIFIC,
+		      RADIUS_VENDOR_COOVACHILLI,
+		      RADIUS_ATTR_COOVACHILLI_WARNING_OCTETS, 0))
+    params->warningoctets = ntohl(attr->v.i);
+  else if (!reconfig)
+    params->warningoctets = 0;
+
 
   /* Max input gigawords */
   if (!radius_getattr(pack, &attr, RADIUS_ATTR_VENDOR_SPECIFIC,
@@ -5279,20 +5481,23 @@
 }
 #endif
 
-#ifdef ENABLE_CHILLIQUERY
-static char *state2name(int authstate) {
-  switch(authstate) {
-    case DHCP_AUTH_NONE:   return "none";
-    case DHCP_AUTH_DROP:   return "drop";
-    case DHCP_AUTH_PASS:   return "pass";
-    case DHCP_AUTH_DNAT:   return "dnat";
-    case DHCP_AUTH_SPLASH: return "splash";
+#if defined(ENABLE_CHILLIQUERY) || defined(ENABLE_UBUS)
+char *state2name(int authstate) {
+	switch(authstate) {
+	case DHCP_AUTH_NONE:   return "none";
+	case DHCP_AUTH_DROP:   return "drop";
+	case DHCP_AUTH_PASS:   return "pass";
+	case DHCP_AUTH_DNAT:   return "dnat";
+	case DHCP_AUTH_SPLASH: return "splash";
 #ifdef ENABLE_LAYER3
-    case DHCP_AUTH_ROUTER: return "layer2";
+	case DHCP_AUTH_ROUTER: return "layer2";
 #endif
-    default:               return "unknown";
-  }
+	default:               return "unknown";
+	}
 }
+#endif
+
+#ifdef ENABLE_CHILLIQUERY
 
 int chilli_getinfo(struct app_conn_t *appconn, bstring b, int fmt) {
   uint32_t sessiontime = 0;
@@ -5374,6 +5579,11 @@
                       appconn->s_params.maxtotaloctets, _options.swapoctets);
         bconcat(b, tmp);
 
+        /* adding: warning-octets */
+        bassignformat(tmp, " %lld",
+                      appconn->s_params.warningoctets);
+        bconcat(b, tmp);
+
 #ifdef ENABLE_LEAKYBUCKET
         /* adding: max-bandwidth-up max-bandwidth-down */
         if (appconn->s_state.bucketupsize) {
@@ -5553,10 +5763,12 @@
       appconn->s_params.maxinputoctets =
       appconn->s_params.maxoutputoctets =
       appconn->s_params.maxtotaloctets =
+      appconn->s_params.warningoctets =
       appconn->s_params.sessiontimeout = 0;
   appconn->s_params.idletimeout = 0;
   appconn->s_params.interim_interval = 0;
   appconn->s_params.sessionterminatetime = 0;
+  appconn->s_params.expiration = 0;
 }
 
 int terminate_appconn(struct app_conn_t *appconn, int terminate_cause) {
@@ -5580,10 +5792,14 @@
       }
     }
 #endif
+#ifdef  ENABLE_DATABASE
+      dbconupdate(appconn);
+#endif
 
     if (_options.condown && !(appconn->s_params.flags & NO_SCRIPT)) {
       if (_options.debug)
         syslog(LOG_DEBUG, "%s(%d): Calling connection down script: %s\n", __FUNCTION__, __LINE__, _options.condown);
+
       runscript(appconn, _options.condown, 0, 0);
     }
 
@@ -5622,6 +5838,8 @@
 
   appconn = (struct app_conn_t*) conn->peer;
 
+  send_ubus_event(g_ubus_event_ctx, CHILLI_EVENT_DISCONNECT, appconn, NULL);
+
   return session_disconnect(appconn, conn, term_cause);
 }
 
@@ -6143,9 +6361,12 @@
         appconn->s_state.session_state =
             RADIUS_VALUE_COOVACHILLI_SESSION_USER_LOGOUT_URL;
 #endif
+        appconn->s_state.terminate_cause_ui =
+                RADIUS_VALUE_COOVACHILLI_SESSION_USER_LOGOUT_URL;
         terminate_appconn(appconn, RADIUS_TERMINATE_CAUSE_USER_REQUEST);
         appconn->s_params.sessiontimeout = 0;
         appconn->s_params.idletimeout = 0;
+        appconn->s_params.expiration = 0;
       }
 
       appconn->uamabort = 0;
@@ -6191,57 +6412,75 @@
   return 0;
 }
 
-#if defined(ENABLE_CHILLIQUERY) || defined(ENABLE_CLUSTER)
-static struct app_conn_t * find_app_conn(struct cmdsock_request *req,
-                                         int *has_criteria) {
-  struct app_conn_t *appconn = 0;
-  struct dhcp_conn_t *dhcpconn = 0;
+#if defined(ENABLE_CHILLIQUERY) || defined(ENABLE_CLUSTER) || defined(ENABLE_UBUS)
+struct app_conn_t * find_app_conn(struct cmdsock_request *req,
+								  int *has_criteria) {
+	struct app_conn_t *appconn = 0;
+	struct dhcp_conn_t *dhcpconn = 0;
+
+	if (req->ip.s_addr) {
+		appconn = dhcp_get_appconn_ip(0, &req->ip);
+		if (has_criteria)
+			*has_criteria = 1;
+	} 
 
-  if (req->ip.s_addr) {
-    appconn = dhcp_get_appconn_ip(0, &req->ip);
-    if (has_criteria)
-      *has_criteria = 1;
-  } else {
+	if (!appconn) {
 #ifdef ENABLE_LAYER3
-    if (!_options.layer3)
+		if (!_options.layer3)
 #endif
-      if (req->mac[0]||req->mac[1]||req->mac[2]||
-	  req->mac[3]||req->mac[4]||req->mac[5]) {
-	dhcp_hashget(dhcp, &dhcpconn, req->mac);
-	if (has_criteria)
-	  *has_criteria = 1;
-      }
-  }
+		if (req->mac[0]||req->mac[1]||req->mac[2]||
+			req->mac[3]||req->mac[4]||req->mac[5]) {
+			dhcp_hashget(dhcp, &dhcpconn, req->mac);
+			if (has_criteria)
+				*has_criteria = 1;
+		}
+	}
 
-  if (!appconn && dhcpconn
+	if (!appconn && dhcpconn
 #ifdef ENABLE_LAYER3
-      && !_options.layer3
+		&& !_options.layer3
 #endif
-      )
-    appconn = (struct app_conn_t *) dhcpconn->peer;
+			)
+		appconn = (struct app_conn_t *) dhcpconn->peer;
 
-  if (!appconn && req->d.sess.sessionid[0] != 0) {
-    struct app_conn_t *aconn = firstusedconn;
-    if (has_criteria)
-      *has_criteria = 1;
-    while (aconn) {
-      if (!strcmp(aconn->s_state.sessionid, req->d.sess.sessionid)) {
-	appconn = aconn;
-	break;
-      }
-      aconn = aconn->next;
-    }
-  }
+	if (!appconn && req->d.sess.sessionid[0] != 0) {
+		struct app_conn_t *aconn = firstusedconn;
+		if (has_criteria)
+			*has_criteria = 1;
+		while (aconn) {
+			if (!strcmp(aconn->s_state.sessionid, req->d.sess.sessionid)) {
+				appconn = aconn;
+				break;
+			}
+			aconn = aconn->next;
+		}
+	}
 
-  if (appconn && !appconn->inuse) {
-    if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): appconn not in use!", __FUNCTION__, __LINE__);
-    return 0;
-  }
+	if (appconn && !appconn->inuse) {
+		if (_options.debug)
+			syslog(LOG_DEBUG, "%s(%d): appconn not in use!", __FUNCTION__, __LINE__);
+		return 0;
+	}
 
-  return appconn;
+	return appconn;
 }
+#endif
+
+int find_active_user(char *username)
+{
+  struct app_conn_t *appconn = firstusedconn;
+  int match = 0;
+  while (appconn) { 
+    if (strcmp(appconn->s_state.redir.username, username) == 0 && appconn->s_state.authenticated == 1) {
+      match = 1;
+      break;
+    }
+    appconn = appconn->next;
+  }
+  return match;
+} 
 
+#if defined(ENABLE_CHILLIQUERY) || defined(ENABLE_CLUSTER)
 int chilli_cmd(struct cmdsock_request *req, bstring s, int sock) {
 
 #ifdef HAVE_NETFILTER_COOVA
@@ -6482,6 +6721,14 @@
             bconcat(s, tmp);
           }
 
+          if (appconn->s_params.warningoctets) {
+            bassignformat(tmp,
+                          "%20s: %lld\n",
+                          "warning octets in",
+                          appconn->s_params.warningoctets);
+            bconcat(s, tmp);
+          }
+
 #ifdef ENABLE_GARDENACCOUNTING
           if (_options.uamgardendata) {
             bassignformat(tmp,
@@ -7070,6 +7317,17 @@
 }
 #endif
 
+#ifdef ENABLE_UBUS
+static int ubus_sock_accept(void *ctx, int sock)
+{
+  struct ubus_context *uctx = (struct ubus_context *)ctx;
+
+  ubus_handle_event(uctx);
+
+  return 0;
+}
+#endif
+
 #if XXX_IO_DAEMON
 int chilli_io(int fd_ctrl_r, int fd_ctrl_w, int fd_pkt_r, int fd_pkt_w) {
   int maxfd = 0;
@@ -7467,6 +7725,11 @@
       exit(1);
     }
 
+    g_ubus_event_ctx = ubus_connect(NULL);
+    if (!g_ubus_event_ctx) {
+      syslog(LOG_ERR, "Failed to set up ubus for event sending");
+    }
+
     dhcp_set_cb_request(dhcp, cb_dhcp_request);
     dhcp_set_cb_connect(dhcp, cb_dhcp_connect);
     dhcp_set_cb_disconnect(dhcp, cb_dhcp_disconnect);
@@ -7547,6 +7810,14 @@
       return -1;
     }
 #endif
+#ifdef ENABLE_UBUS
+    ubus_ctx = ubus_connect(NULL);
+	if (!ubus_ctx) {
+		syslog(LOG_ERR, "Failed to connect to ubus, exiting...");
+	}
+#endif
+
+
 
     if (_options.radsec) {
 #ifdef ENABLE_CHILLIRADSEC
@@ -7714,10 +7985,25 @@
 #ifdef ENABLE_CHILLIQUERY
     net_select_reg(&sctx, cmdsock, SELECT_READ,
                    (select_callback)cmdsock_accept, 0, cmdsock);
+
+#endif
+#ifdef ENABLE_UBUS
+    net_select_reg(&sctx, ubus_ctx->sock.fd, SELECT_READ,
+                   (select_callback)ubus_sock_accept, ubus_ctx, ubus_ctx->sock.fd);
+    chilli_ubus_add_obj(ubus_ctx);
+    
+    /* subscribe to hostapd to listen for dissasoc calls. */
+    chilli_ubus_subscribe_hostapd(ubus_ctx, _options);
+
 #endif
 
     mainclock_tick();
-    while (keep_going) {
+#ifdef ENABLE_DATABASE
+    syslog(LOG_INFO, "[%s] Checking data base %s", __FUNCTION__, sqlite3_libversion());
+    dbcheck_table();
+#endif
+
+  while (keep_going) {
 
       if (reload_config) {
 
@@ -7821,6 +8107,10 @@
 
     syslog(LOG_INFO, "CoovaChilli shutting down");
 
+    if (g_ubus_event_ctx) {
+      ubus_free(g_ubus_event_ctx);
+    }
+
     if (_options.seskeepalive) {
 #ifdef ENABLE_BINSTATFILE
       if (printstatus() != 0)
@@ -7863,6 +8153,10 @@
 #ifdef ENABLE_CHILLIQUERY
     cmdsock_shutdown();
 #endif
+#ifdef ENABLE_UBUS
+	chilli_ubus_remove_obj(ubus_ctx);	//Workaround (?) Protection from Huawei
+    ubus_free(ubus_ctx);
+#endif
 
 #ifdef ENABLE_CHILLIREDIR
     if (redir_pid > 0) {
diff --recursive --unified --new-file --no-dereference orig/src/chilli.h src/src/chilli.h
--- orig/src/chilli.h	2016-12-15 17:28:43.000000000 +0000
+++ src/src/chilli.h	2024-01-26 11:00:37.000000000 +0000
@@ -35,11 +35,26 @@
 #include "net.h"
 #include "md5.h"
 #include "dns.h"
+#include "sqlite.h"
+#include "ubus.h"
+#ifdef  ENABLE_DATABASE
+#include "database.h"
+#endif
+#include "users.h"
+#include "gsm.h"
+#ifdef HAVE_OPENSSL
+#include "passwd_md5crypt.h"
+#include "passwd_shacrypt.h"
+#endif
 
 #ifndef HAVE_STRLCPY
 extern size_t strlcpy(char *dst, const char *src, size_t dsize);
 #endif
 
+#ifdef ENABLE_UBUS
+  struct ubus_context *ubus_ctx;
+#endif
+
 /*#define XXX_IO_DAEMON 1*/
 
 /* Authtype defs */
@@ -70,6 +85,8 @@
 #define DEBUG_REDIR       8
 #define DEBUG_CONF       16
 
+#define WARNING_FMT "You're about to reach your %s data limit, %.1f %s left.\n"
+
 /* Struct information for each connection */
 struct app_conn_t {
 
@@ -102,6 +119,11 @@
 
   struct session_params s_params;         /* Session parameters */
   struct session_state  s_state;          /* Session state */
+#ifdef ENABLE_DATABASE
+  struct session_history s_history;		/*Session history*/
+#endif
+
+
 
 #ifdef HAVE_PATRICIA
   patricia_tree_t *ptree;
@@ -212,6 +234,8 @@
 struct app_conn_t * chilli_connect_layer3(struct in_addr *src, struct dhcp_conn_t *conn);
 #endif
 
+int find_active_user(char *username);
+
 int chilli_getconn(struct app_conn_t **conn, uint32_t ip,
 		   uint32_t nasip, uint32_t nasport);
 
@@ -256,12 +280,24 @@
 
 void session_param_defaults(struct session_params *params);
 
+void session_params_dyn(struct session_params *params);
+
+void session_params_trial(struct session_params *params);
+
 int dnprot_accept(struct app_conn_t *appconn);
 
 int dnprot_reject(struct app_conn_t *appconn);
 
 int get_urlparts(char *src, char *host, int hostsize, int *port, int *uripos);
 
+int bstrtocstr(bstring src, char *dst, unsigned int len);
+
+int bescape_str(bstring src, bstring dst);
+
+int escape_cstr(char *src, char *dst);
+
+int besc_strtocstr(bstring src, char *dst, unsigned int len);
+
 int cmdsock_init();
 
 int cmdsock_port_init();
@@ -320,6 +356,12 @@
 int chilli_getconn_byroute(struct app_conn_t **conn, int idx);
 #endif
 
+
+struct app_conn_t * find_app_conn(struct cmdsock_request *req, int *has_criteria);
+char *state2name(int authstate);
+int has_dhcp(void);
+
+
 uint8_t* chilli_called_station(struct session_state *state);
 
 int chilli_cmd(struct cmdsock_request *req, bstring s, int sock);
diff --recursive --unified --new-file --no-dereference orig/src/cmdline.ggo src/src/cmdline.ggo
--- orig/src/cmdline.ggo	2016-12-15 17:28:43.000000000 +0000
+++ src/src/cmdline.ggo	2024-01-26 11:00:37.000000000 +0000
@@ -166,6 +166,36 @@
 option "defbandwidthmaxdown" - "Default WISPr-Bandwidth-Max-Down if not returned by RADIUS" long default="0" no
 option "defbandwidthmaxup" - "Default WISPr-Bandwidth-Max-Up if not returned by RADIUS" long default="0" no
 option "definteriminterval" - "Default interim-interval for accounting if not returned by RADIUS" int default="300" no
+option "defmaxdownload" - "Default CoovaChilli-Max-Input-Octets if not returned by RADIUS" long default="0" no
+option "defmaxupload" - "Default CoovaChilli-Max-Output-Octets if not returned by RADIUS" long default="0" no
+option "defwarning" - "Default CoovaChilli-Warning-Octets if not returned by RADIUS" long default="0" no
+option "deflimitperiod" - "Default period for data limit calculations" int default="0" no
+option "deflimitstart" - "Default start point for data limit calculations" int default="0" no
+option "defexpirationtime" - "Default expiration time for dynamically allocated ussers" long default="0" no
+
+option "dynsessiontimeout" - "Dynamically created user session-timeout if not returned by RADIUS" long default="0" no
+option "dynidletimeout" - "Dynamically created user idle-timeout if not returned by RADIUS" int default="0" no
+option "dynbandwidthmaxdown" - "Dynamically created user WISPr-Bandwidth-Max-Down if not returned by RADIUS" long default="0" no
+option "dynbandwidthmaxup" - "Dynamically created user WISPr-Bandwidth-Max-Up if not returned by RADIUS" long default="0" no
+option "dyninteriminterval" - "Dynamically created user interim-interval for accounting if not returned by RADIUS" int default="300" no
+option "dynmaxdownload" - "Dynamically created user CoovaChilli-Max-Input-Octets if not returned by RADIUS" long default="0" no
+option "dynmaxupload" - "Dynamically created user CoovaChilli-Max-Output-Octets if not returned by RADIUS" long default="0" no
+option "dynwarning" - "Dynamically created user CoovaChilli-Warning-Octets if not returned by RADIUS" long default="0" no
+option "dynlimitperiod" - "Dynamically created user period for data limit calculations" int default="0" no
+option "dynlimitstart" - "Dynamically created user start point for data limit calculations" int default="0" no
+option "dynexpirationtime" - "Expiration time for dynamically allocated ussers" long default="0" no
+
+option "trialsessiontimeout" - "Trial session session-timeout if not returned by RADIUS" long default="0" no
+option "trialidletimeout" - "Trial session idle-timeout if not returned by RADIUS" int default="0" no
+option "trialbandwidthmaxdown" - "Trial session WISPr-Bandwidth-Max-Down if not returned by RADIUS" long default="0" no
+option "trialbandwidthmaxup" - "Trial session WISPr-Bandwidth-Max-Up if not returned by RADIUS" long default="0" no
+option "trialinteriminterval" - "Trial session interim-interval for accounting if not returned by RADIUS" int default="300" no
+option "trialmaxdownload" - "Trial session CoovaChilli-Max-Input-Octets if not returned by RADIUS" long default="0" no
+option "trialmaxupload" - "Trial session CoovaChilli-Max-Output-Octets if not returned by RADIUS" long default="0" no
+option "trialwarning" - "Trial session CoovaChilli-Warning-Octets if not returned by RADIUS" long default="0" no
+option "triallimitperiod" - "Trial session period for data limit calculations" int default="0" no
+option "triallimitstart" - "Trial session start point for data limit calculations" int default="0" no
+option "trialexpirationtime" - "Trial session expiration time" long default="0" no
 
 option "bwbucketupsize" - "Define the up-bound 'leaky bucket' size" int default="0" no
 option "bwbucketdnsize" - "Define the down-bound 'leaky bucket' size" int default="0" no
@@ -295,3 +325,34 @@
 option "ipv6mode" - "IPv6 mode is either 6and4 (default), 4to6, or 6to4" string no
 option "ipv6only" - "Enable IPv6-Only" flag off
 
+#Custom options
+option "successuserurl" - "Do not return to the UAM server on success, original url instead" flag  off
+option "successurlcustom" - "Return to the custom URL on success. Overwrites 'successuserurl' option" string no
+option "dbpath" - "Path to the statistics database" string no
+option "usersdbpath" - "Path to the users database" string no
+option "smsusers"    - "Enable SMS OTP for authentication" flag   off
+option "duplicateusers"    - "Enable same SMS OTP for more than one user" flag	off
+option "macusers"    - "Enable mac users for authentication" flag   off
+option "trialusers"    - "Enable trial logins" flag   off
+option "macpass"    - "Protects MAC users with password" string no
+option "registerusers"    - "Enable signup to create new users" flag   off
+option "modemid" - "GSM modem id" string no
+option "usersignup"     - "Script to run after user has been created" string no
+option "tos"    - "Enable Terms Of Service requirement" flag   off
+
+option "paramuamip"     - "Overwrites uamip parameter name" string no
+option "paramuamport"     - "Overwrites uamport parameter name" string no
+option "paramcalled"     - "Overwrites called parameter name" string no
+option "parammac"     - "Overwrites mac parameter name" string no
+option "paramip"     - "Overwrites ip parameter name" string no
+option "paramnasid"     - "Overwrites nasid parameter name" string no
+option "paramsessionid"     - "Overwrites sessionid parameter name" string no
+option "paramuserurl"     - "Overwrites userurl parameter name" string no
+option "paramchallenge"     - "Overwrites challenge parameter name" string no
+option "param1"     - "Adds custom parameter to redirect url" string no
+option "param1value"     - "The value of custom parameter" string no
+option "param2"     - "Adds custom parameter to redirect url" string no
+option "param2value"     - "The value of custom parameter" string no
+
+option "testtime"    - "Disables CLOCK_MONOTONIC and use CLOCK_REALTIME instead" flag   off
+
diff --recursive --unified --new-file --no-dereference orig/src/cmdsock.c src/src/cmdsock.c
--- orig/src/cmdsock.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/cmdsock.c	2024-01-26 11:00:37.000000000 +0000
@@ -47,7 +47,7 @@
 	cmdsock = -1;
       } else {
 	if (_options.uid) {
-	  if (chown(_options.cmdsocket, _options.uid, _options.gid)) {
+	  if (fchown(cmdsock, _options.uid, _options.gid)) {
 	    syslog(LOG_ERR, "%d could not chown() %s",
                    errno, _options.cmdsocket);
 	  }
diff --recursive --unified --new-file --no-dereference orig/src/database.c src/src/database.c
--- orig/src/database.c	1970-01-01 00:00:00.000000000 +0000
+++ src/src/database.c	2024-01-26 11:00:37.000000000 +0000
@@ -0,0 +1,324 @@
+#include "chilli.h"
+
+static int _seletc_callback(void *str_session, int argc, char **argv, char **azColName) {
+    struct db_session_state *p_str_session = (struct db_session_state *)str_session;
+
+    if (argc > 0) {
+        p_str_session->input_packets = argv[0] ? strtol(argv[0], NULL, 0) : 0;
+        p_str_session->output_packets = argv[1] ? strtol(argv[1], NULL, 0) : 0;
+        p_str_session->input_octets = argv[2] ? strtol(argv[2], NULL, 0) : 0;
+        p_str_session->output_octets = argv[3] ? strtol(argv[3], NULL, 0) : 0;
+        p_str_session->sessiontime = argv[4] ? strtol(argv[4], NULL, 0) : 0;
+
+    }
+
+    return DB_SUCCESS;
+}
+
+static int dbsession_data(struct session_params *s_params, char *username, uint8_t *hismac,
+        struct db_session_state * db_state){
+    int ret;
+    char *sql;
+    char *err = 0;
+    sqlite3 *db;
+    time_t timestamp_now = mainclock_wall();
+    struct tm *time_now;
+    int start_wday, wday;
+
+    if (_options.debug)
+        syslog(LOG_INFO, "[%s] Trying to get sesions state %ld", __FUNCTION__, (long) timestamp_now);
+
+    time_now = localtime(&timestamp_now);
+    time_now->tm_min = 0;
+    time_now->tm_sec = 0;
+
+    switch (s_params->period)
+    {
+        case PERIOD_MONTH:
+            if (s_params->start > time_now->tm_mday)
+                time_now->tm_mon--;
+
+            time_now->tm_mday = s_params->start;
+            time_now->tm_hour = 0;
+
+            break;
+        case PERIOD_WEEK:
+            start_wday = s_params->start == 0 ? 7 : s_params->start;
+            wday = time_now->tm_wday == 0 ? 7 : time_now->tm_wday;
+
+            if (time_now->tm_wday != s_params->start){
+                if (start_wday > wday)
+                    time_now->tm_mday -= (7 - start_wday - wday);
+                else
+                    time_now->tm_mday -= wday -start_wday;
+            }
+
+            time_now->tm_hour = 0;
+
+            break;
+        case PERIOD_DAY:
+            if (s_params->start > time_now->tm_hour)
+                time_now->tm_mday--;
+
+            time_now->tm_hour = s_params->start;
+
+            break;
+    }
+
+    db = dbopen();
+    asprintf(&sql, "SELECT SUM(input_packets) AS input_packets, SUM(output_packets) AS output_packets," \
+                   "SUM(input_octets) AS input_octets, SUM(output_octets) AS output_octets," \
+                   " SUM(sessiontime) AS sessiontime FROM "TABLE_NAME \
+                   " WHERE start_time >= %"PRId64" AND username = '%s';", (uint64_t) mktime(time_now), username);
+    if (_options.debug)
+        syslog(LOG_INFO, "[%s] SQL: %s", __FUNCTION__ , sql);
+
+    ret = sqlite3_exec(db, sql, _seletc_callback, db_state, &err);
+    if (ret){
+        syslog(LOG_INFO, "[%s] SQL error: %s\n", __FUNCTION__, err);
+        sqlite3_free(err);
+    }
+
+    dbclose(db);
+    free(sql);
+
+    return ret;
+}
+
+sqlite3 *dbopen(void) {
+    sqlite3 *db;
+    int ret;
+
+    ret = sqlite3_open(_options.dbpath, &db);
+    if (ret)
+        syslog(LOG_INFO, "[%s] Can't open database: %s", __FUNCTION__ , sqlite3_errmsg(db));
+
+    return db;
+}
+
+int dbclose(sqlite3 *db){
+    return sqlite3_close(db);
+}
+
+int dbexec(sqlite3 *db, char *sql, int (*callback)(void*,int,char**,char**)){
+    int ret;
+    char *err = 0;
+
+    ret = sqlite3_exec(db, sql, callback, 0, &err);
+    if (ret){
+        syslog(LOG_INFO, "[%s] SQL error: %s\n", __FUNCTION__, err);
+        sqlite3_free(err);
+    }
+
+    return ret;
+}
+
+int dbprepare(sqlite3 *db, char *sql){
+    sqlite3_stmt *stmt;
+    int ret;
+
+    ret = sqlite3_prepare_v2(db, sql, -1, &stmt, NULL);
+    if (ret) {
+        syslog(LOG_INFO, "SQL error: %s\n", sqlite3_errmsg(db));
+        goto out;
+    }
+
+    ret = sqlite3_step(stmt);
+    if (ret){
+        syslog(LOG_INFO, "SQL error: %s\n", sqlite3_errmsg(db));
+        goto out;
+    }
+
+    out:
+    return ret;
+}
+
+int dbcreate_table(sqlite3 *db){
+    int ret;
+    char *sql;
+
+    sql = "CREATE TABLE "TABLE_NAME"("
+      "id               INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE," \
+      "start_time       TIMESTAMP NOT NULL," \
+      "last_update      TIMESTAMP," \
+      "mac              VARCHAR(32)," \
+      "ip               VARCHAR(16)," \
+      "username         VARCHAR(64)," \
+      "sessiontime      BIGINT NOT NULL DEFAULT 0," \
+      "idletime         BIGINT NOT NULL DEFAULT 0," \
+      "input_octets     BIGINT NOT NULL DEFAULT 0," \
+      "output_octets    BIGINT NOT NULL DEFAULT 0," \
+      "input_packets    BIGINT NOT NULL DEFAULT 0," \
+      "output_packets   BIGINT NOT NULL DEFAULT 0," \
+      "session          BOOLEAN NOT NULL DEFAULT 0," \
+      "ifname           VARCHAR(16)," \
+      "sessionid        VARCHAR(33)," \
+      "terminate_cause  BIGINT NOT NULL DEFAULT 0," \
+      "custom           VARCHAR(64)," \
+      "authmode         VARCHAR(64));";
+    ret = dbexec(db, sql, NULL);
+
+    return ret;
+}
+
+int dbwrite(sqlite3 *db, struct app_conn_t *conn){
+    int ret;
+    char *sql = NULL;
+    time_t time_now;
+    struct session_state s_state;
+
+    time_now = mainclock_wall();
+    s_state = conn->s_state;
+
+    asprintf(&sql, INSERT_FMT, (uint64_t)time_now, MAC_ARG(conn->hismac),
+             inet_ntoa(conn->hisip), s_state.redir.username, s_state.authenticated,
+#ifdef ENABLE_MULTILAN
+			 app_conn_idx(conn) ? _options.moreif[app_conn_idx(conn)-1].dhcpif : _options.dhcpif,
+#else
+			 _options.dhcpif,
+#endif
+             s_state.sessionid, conn->s_state.redir.auth_mode);
+    if (_options.debug)
+        syslog(LOG_INFO, "[%s] SQL: %s", __FUNCTION__ , sql);
+
+    ret = dbexec(db, sql, NULL);
+
+    free(sql);
+    return ret;
+}
+
+int dbupdate(sqlite3 *db, struct app_conn_t *conn){
+    int ret;
+    char *sql = NULL;
+    uint64_t time_now, idletime, sessiontime;
+    struct session_state s_state;
+
+    s_state = conn->s_state;
+    time_now = mainclock_wall();
+    idletime = mainclock_diffu(s_state.last_up_time);
+    sessiontime = mainclock_diffu(s_state.start_time);
+    asprintf(&sql, UPDATE_FMT, time_now, idletime, sessiontime,
+             s_state.input_octets, s_state.output_octets, s_state.input_packets,
+             s_state.output_packets, s_state.authenticated, s_state.terminate_cause_ui,
+			 MAC_ARG(conn->hismac), 1, s_state.sessionid);
+
+    if (_options.debug)
+        syslog(LOG_INFO, "[%s] SQL: %s", __FUNCTION__ , sql);
+    ret = dbexec(db, sql, NULL);
+    free(sql);
+
+    return ret;
+}
+
+int dbtable_exists(sqlite3 *db){
+    int ret;
+    int count = 0;
+    char *sql;
+    sqlite3_stmt *stmt;
+
+    sql = "SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name='"TABLE_NAME"';";
+    ret = sqlite3_prepare_v2(db, sql, -1, &stmt, 0);
+    if (ret != SQLITE_OK) {
+        syslog(LOG_INFO, "[%s] SQL error: %s", __FUNCTION__ , sqlite3_errmsg(db));
+        return DB_FAIL;
+    }
+
+    if ((ret = sqlite3_step(stmt)) == SQLITE_ROW)
+        count = sqlite3_column_int(stmt, 0);
+
+    sqlite3_finalize(stmt);
+
+    return (count == 0) ? DB_FAIL : DB_SUCCESS;
+}
+
+int dbcheck_table(void){
+    sqlite3 *db;
+    int ret = -1;
+
+    db = dbopen();
+    if (dbtable_exists(db) == DB_FAIL)
+        ret = dbcreate_table(db);
+
+    dbclose(db);
+
+    return ret;
+}
+
+int dbconup(struct app_conn_t *conn){
+    sqlite3 *db;
+    int ret = -1;
+
+    db = dbopen();
+    if (db != NULL) {
+        ret = dbwrite(db, conn);
+        dbclose(db);
+    }
+
+    return ret;
+}
+
+int dbconupdate(struct app_conn_t *conn){
+    sqlite3 *db;
+    int ret = -1;
+
+    db = dbopen();
+    if (db) {
+        ret = dbupdate(db, conn);
+        dbclose(db);
+    }
+
+    return ret;
+}
+
+int dbcheck_session(struct redir_conn_t *conn){
+    int ret = ACCESS_ACCEPTED;
+    uint64_t sessiontime, start_time;
+    struct db_session_state db_state;
+
+    if (strlen(conn->s_state.redir.username) == 0)
+        return 0;
+
+    dbsession_data(&conn->s_params, conn->s_state.redir.username, conn->hismac, &db_state);
+
+    if (_options.debug)
+        syslog(LOG_INFO, "[%s] input_octets %lld, output_octets %lld,  sessiontime %d", __FUNCTION__,
+               db_state.input_octets, db_state.output_octets, db_state.sessiontime);
+
+    if (conn->s_params.maxinputoctets &&
+        conn->s_params.maxinputoctets < db_state.input_octets)
+        ret = ACCESS_DENIED_DATA;
+    else if (conn->s_params.maxoutputoctets &&
+             conn->s_params.maxoutputoctets < db_state.output_octets)
+        ret = ACCESS_DENIED_DATA;
+    else if (conn->s_params.sessiontimeout) {
+        start_time = mainclock_now() - db_state.sessiontime;
+        sessiontime = mainclock_diffu(start_time);
+        if (conn->s_params.sessiontimeout < sessiontime)
+            ret = ACCESS_DENIED_TIME;
+    }
+
+    return ret;
+}
+
+int dbsession_state(struct app_conn_t *conn){
+    int ret;
+    struct db_session_state db_state;
+
+    if (strlen(conn->s_state.redir.username) == 0)
+        return 0;
+
+    ret = dbsession_data(&conn->s_params, conn->s_state.redir.username, conn->hismac, &db_state);
+
+    if (!ret){
+        if (_options.debug)
+        syslog(LOG_INFO, "[%s] input_octets %lld, output_octets %lld,  sessiontime %d", __FUNCTION__,
+               db_state.input_octets, db_state.output_octets, db_state.sessiontime);
+        conn->s_history.input_packets = db_state.input_packets;
+        conn->s_history.output_packets = db_state.output_packets;
+        conn->s_history.input_octets = db_state.input_octets;
+        conn->s_history.output_octets = db_state.output_octets;
+        conn->s_history.sessiontime = db_state.sessiontime;
+    }
+
+    return ret;
+}
diff --recursive --unified --new-file --no-dereference orig/src/database.h src/src/database.h
--- orig/src/database.h	1970-01-01 00:00:00.000000000 +0000
+++ src/src/database.h	2024-01-26 11:00:37.000000000 +0000
@@ -0,0 +1,41 @@
+//
+// Created by darius on 19.5.23.
+//
+
+#ifndef RUTX_DATABASE_H
+#define RUTX_DATABASE_H
+
+#define DB_SUCCESS 0
+#define DB_FAIL 1
+
+
+#define TABLE_NAME "statistics"
+#define INSERT_FMT "INSERT INTO "TABLE_NAME" (start_time, mac, ip, username, session, ifname, sessionid," \
+        "authmode) VALUES (%"PRId64", '"MAC_FMT"', '%s', '%s', %d, '%s', '%s', '%d');"
+#define UPDATE_FMT "UPDATE "TABLE_NAME \
+                 " SET last_update = %"PRId64", idletime = %"PRId64", sessiontime = %"PRId64", input_octets = %lld," \
+                 " output_octets = %lld, input_packets = %lld, output_packets = %lld, session = %d," \
+                 " terminate_cause = %d" \
+                 " WHERE mac = '"MAC_FMT"' AND session = %d AND sessionid = '%s';"
+
+struct db_session_state {
+    uint64_t input_octets;
+    uint64_t output_octets;
+    uint64_t input_packets;
+    uint64_t output_packets;
+    uint32_t sessiontime;
+};
+
+sqlite3 *dbopen(void);
+int dbclose(sqlite3 *db);
+int dbexec(sqlite3 *db, char *sql, int (*callback)(void*,int,char**,char**));
+int dbcreate_table(sqlite3 *db);
+int dbwrite(sqlite3 *db, struct app_conn_t *appconn);
+int dbupdate(sqlite3 *db, struct app_conn_t *appconn);
+int dbcheck_table(void);
+int dbconup(struct app_conn_t *conn);
+int dbconupdate(struct app_conn_t *conn);
+int dbsession_state(struct app_conn_t *conn);
+int dbcheck_session(struct redir_conn_t *conn);
+
+#endif //RUTX_DATABASE_H
diff --recursive --unified --new-file --no-dereference orig/src/dhcp.c src/src/dhcp.c
--- orig/src/dhcp.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/dhcp.c	2024-01-26 11:00:37.000000000 +0000
@@ -1073,8 +1073,8 @@
   if (getenv("NFQUEUE_IN") && getenv("NFQUEUE_OUT")) {
     int q1 = 0, q2 = 1;
     char *e;
-    if ((e = getenv("NFQUEUE_IN"))) q1 = atoi(e);
-    if ((e = getenv("NFQUEUE_OUT"))) q2 = atoi(e);
+    if ((e = getenv("NFQUEUE_IN"))) q1 = strtol(e, NULL, 0);
+    if ((e = getenv("NFQUEUE_OUT"))) q2 = strtol(e, NULL, 0);
     if (net_open_nfqueue(&dhcp->qif_in, q1, nfqueue_cb_in) == -1) {
       return -1;
     }
@@ -3760,7 +3760,7 @@
    */
   if (!dhcp_hashget(this, &conn, pack_ethh->src)) {
 
-    if (_options.debug)
+    if (_options.debug > 2)
       syslog(LOG_DEBUG, "%s(%d): Address found", __FUNCTION__, __LINE__);
 
     ourip.s_addr = conn->ourip.s_addr;
@@ -4119,8 +4119,9 @@
         if (appconn) {
           if (appconn->s_state.authenticated) {
             terminate_appconn(appconn, RADIUS_TERMINATE_CAUSE_USER_REQUEST);
-            if (_options.debug)
-              syslog(LOG_DEBUG, "%s(%d): Dropping session due to request for auto-logout ip", __FUNCTION__, __LINE__);
+            char str[INET_ADDRSTRLEN] = {0};
+            inet_ntop(AF_INET, &(appconn->hisip), str, INET_ADDRSTRLEN);
+            syslog(LOG_INFO, "Dropping session due to request for auto-logout from username=%s IP=%s", appconn->s_state.redir.username, str);
             appconn->uamexit = 1;
           }
         }
diff --recursive --unified --new-file --no-dereference orig/src/garden.c src/src/garden.c
--- orig/src/garden.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/garden.c	2024-01-26 11:00:37.000000000 +0000
@@ -478,7 +478,7 @@
   if (p3 == NULL)
      return 0;
 
-  strcpy(p3, s);
+  strncpy(p3, s, strlen(s));
   p1 = p3;
 
   if (_options.debug)
@@ -506,7 +506,7 @@
 	struct protoent *proto = getprotobyname(p1);
 
 	if (!proto && !strchr(p1, '.'))
-	  proto = getprotobynumber(atoi(p1));
+	  proto = getprotobynumber(strtol(p1, NULL, 0));
 
 	if (proto)
 	  pnum = proto->p_proto;
@@ -531,7 +531,7 @@
     {
       char *e = strchr(p1, '#');
       if (e) {
-	int add = atoi(e+1);
+	int add = strtol(e+1, NULL, 0);
 	pt.expiry = mainclock_now() + add;
 	*e = 0;
       }
@@ -540,7 +540,7 @@
 
     /* look for an optional port */
     if ((t = strchr(p1, ':'))) {
-      pt.port = atoi(t+1);
+      pt.port = strtol(t+1, NULL, 0);
       *t = 0;
     }
 
diff --recursive --unified --new-file --no-dereference orig/src/gsm.c src/src/gsm.c
--- orig/src/gsm.c	1970-01-01 00:00:00.000000000 +0000
+++ src/src/gsm.c	2024-01-26 11:00:37.000000000 +0000
@@ -0,0 +1,61 @@
+
+#ifdef HAVE_SYSLOG_H
+#include <syslog.h>
+#endif
+
+#include "system.h"
+#include <libgsm.h>
+#include <libgsm_utils.h>
+
+#include "gsm.h"
+
+chilli_gsm_t chilli_send_sms(const char *phone, const char *msg,
+		const char *modem_id)
+{
+	struct ubus_context *ubus;
+	lgsm_structed_info_t data = { 0 };
+	int ret = CHILLI_GSM_ERR;
+	int modem_num;
+
+	ubus = ubus_connect(NULL);
+	if (!ubus) {
+		return CHILLI_GSM_ERR;
+	}
+
+	if ((modem_num = lgsmu_modem_id_to_num(ubus, modem_id)) < 0) {
+		syslog(LOG_ERR, "Unable to get modem '%s' number", modem_id);
+
+		goto out;
+	}
+
+	if (lgsm_send_sms(ubus, phone, msg, &data, modem_num) == LGSM_SUCCESS) {
+		ret = CHILLI_GSM_OK;
+	} else {
+		syslog(LOG_ERR, "Unable to send SMS message to %s", phone);
+	}
+
+out:
+	ubus_free(ubus);
+	handle_gsm_structed_info_free(&data);
+
+	return ret;
+}
+
+chilli_gsm_t chilli_send_sms_async(const char *phone, const char *msg,
+		const char *modem_id)
+{
+	int status;
+
+	if ((status = fork()) < 0) {
+		syslog(LOG_ERR, "%s: fork() returned -1!", strerror(errno));
+		return CHILLI_GSM_ERR;
+	}
+
+	if (status > 0) { /* Parent */
+		return CHILLI_GSM_OK;
+	}
+
+	chilli_send_sms(phone, msg, modem_id);
+
+	exit(0);
+}
diff --recursive --unified --new-file --no-dereference orig/src/gsm.h src/src/gsm.h
--- orig/src/gsm.h	1970-01-01 00:00:00.000000000 +0000
+++ src/src/gsm.h	2024-01-26 11:00:37.000000000 +0000
@@ -0,0 +1,20 @@
+
+#ifndef RUTX_GSM_H
+#define RUTX_GSM_H
+
+#include <libgsm.h>
+
+#define GSM_DEFAULT_USB_ID "3-1"
+
+typedef enum {
+    CHILLI_GSM_OK,
+    CHILLI_GSM_ERR
+} chilli_gsm_t;
+
+chilli_gsm_t chilli_send_sms(const char *phone, const char *msg,
+		const char *modem_id);
+chilli_gsm_t chilli_send_sms_async(const char *phone, const char *msg,
+		const char *modem_id);
+
+#endif //RUTX_GSM_H
+
diff --recursive --unified --new-file --no-dereference orig/src/linux/xt_coova.c src/src/linux/xt_coova.c
--- orig/src/linux/xt_coova.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/linux/xt_coova.c	2024-01-26 11:00:37.000000000 +0000
@@ -323,7 +323,7 @@
 		goto out;
 	}
 	t->refcnt = 1;
-	strcpy(t->name, info->name);
+	strncpy(t->name, info->name, strlen(info->name));
 	INIT_LIST_HEAD(&t->lru_list);
 	for (i = 0; i < ip_list_hash_size; i++)
 		INIT_LIST_HEAD(&t->iphash[i]);
diff --recursive --unified --new-file --no-dereference orig/src/main-opt.c src/src/main-opt.c
--- orig/src/main-opt.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/main-opt.c	2024-01-26 11:00:37.000000000 +0000
@@ -20,6 +20,8 @@
 
 #define MAIN_FILE
 
+#include <libgsm_utils.h>
+
 #include "cmdline.h"
 #include "system.h"
 #include "chilli.h"
@@ -63,6 +65,9 @@
 #ifdef ENABLE_CHILLIQUERY
     "ENABLE_CHILLIQUERY "
 #endif
+#ifdef ENABLE_UBUS
+"ENABLE_UBUS "
+#endif
 #ifdef ENABLE_CHILLIPROXY
     "ENABLE_CHILLIPROXY "
 #endif
@@ -255,6 +260,12 @@
 #ifdef USING_POLL
     "USING_POLL "
 #endif
+#ifdef  ENABLE_DATABASE
+    "ENABLE_DATABASE "
+#endif
+#ifdef  ENABLE_GSM
+    "ENABLE_GSM "
+#endif
 #ifdef EX_OPT_FEATURES
 #include EX_OPT_FEATURES
 #endif
@@ -435,6 +446,51 @@
   _options.defbandwidthmaxdown = args_info.defbandwidthmaxdown_arg;
   _options.defbandwidthmaxup = args_info.defbandwidthmaxup_arg;
   _options.defidletimeout = args_info.defidletimeout_arg;
+  _options.defmaxdownload = args_info.defmaxdownload_arg;
+  _options.defmaxupload = args_info.defmaxupload_arg;
+  _options.defwarning = args_info.defwarning_arg;
+  _options.deflimitperiod = args_info.deflimitperiod_arg;
+  _options.deflimitstart = args_info.deflimitstart_arg;
+  _options.defexpirationtime = args_info.defexpirationtime_arg;
+
+  if (args_info.dynsessiontimeout_orig) {
+    _options.dynsessiontimeout = (uint64_t)strtol(args_info.dynsessiontimeout_orig, NULL, 0);
+  }
+  if (args_info.dynbandwidthmaxdown_orig) {
+    _options.dynbandwidthmaxdown = (uint64_t)strtol(args_info.dynbandwidthmaxdown_orig, NULL, 0);
+  }
+  if (args_info.dynbandwidthmaxup_orig) {
+    _options.dynbandwidthmaxup = (uint64_t)strtol(args_info.dynbandwidthmaxup_orig, NULL, 0);
+  }
+  if (args_info.dynmaxdownload_orig) {
+    _options.dynmaxdownload = (uint64_t)strtol(args_info.dynmaxdownload_orig, NULL, 0);
+  }
+  if (args_info.dynwarning_orig) {
+    _options.dynwarning = (uint64_t)strtol(args_info.dynwarning_orig, NULL, 0);
+  }
+  if (args_info.dynmaxupload_orig) {
+    _options.dynmaxupload = (uint64_t)strtol(args_info.dynmaxupload_orig, NULL, 0);
+  }
+  if (args_info.dynexpirationtime_orig) {
+    _options.dynexpirationtime = (uint64_t)strtol(args_info.dynexpirationtime_orig, NULL, 0);
+  }
+  _options.dyninteriminterval = args_info.dyninteriminterval_arg;
+  _options.dynidletimeout = args_info.dynidletimeout_arg;
+  _options.dynlimitperiod = args_info.dynlimitperiod_arg;
+  _options.dynlimitstart = args_info.dynlimitstart_arg;
+
+  _options.trialsessiontimeout = args_info.trialsessiontimeout_arg;
+  _options.trialinteriminterval = args_info.trialinteriminterval_arg;
+  _options.trialbandwidthmaxdown = args_info.trialbandwidthmaxdown_arg;
+  _options.trialbandwidthmaxup = args_info.trialbandwidthmaxup_arg;
+  _options.trialidletimeout = args_info.trialidletimeout_arg;
+  _options.trialmaxdownload = args_info.trialmaxdownload_arg;
+  _options.trialmaxupload = args_info.trialmaxupload_arg;
+  _options.trialwarning = args_info.trialwarning_arg;
+  _options.triallimitperiod = args_info.triallimitperiod_arg;
+  _options.triallimitstart = args_info.triallimitstart_arg;
+  _options.trialexpirationtime = args_info.dynexpirationtime_arg;
+
   _options.radiusnasporttype = args_info.radiusnasporttype_arg;
   _options.radiusauthport = args_info.radiusauthport_arg;
   _options.radiusacctport = args_info.radiusacctport_arg;
@@ -469,6 +525,7 @@
   _options.dhcp_broadcast = args_info.dhcpbroadcast_flag;
   _options.dhcpgwport = args_info.dhcpgatewayport_arg;
   _options.noc2c = args_info.noc2c_flag;
+  _options.noc2c = args_info.noc2c_flag;
   _options.tcpwin = args_info.tcpwin_arg;
   _options.tcpmss = args_info.tcpmss_arg;
   _options.max_clients = args_info.maxclients_arg;
@@ -481,6 +538,7 @@
   _options.redirurl = args_info.redirurl_flag;
   _options.statusfilesave = args_info.statusfilesave_flag;
   _options.dhcpnotidle = args_info.dhcpnotidle_flag;
+  _options.successuserurl = args_info.successuserurl_flag;
 #if(_debug_ && !defined(ENABLE_CHILLIREDIR))
   if (_options.redir)
     syslog(LOG_ERR, "chilli_redir not implemented. build with --enable-chilliredir");
@@ -1205,7 +1263,7 @@
 
     syslog(LOG_DEBUG, "Macallowed #%d: %s", numargs, args_info.macallowed_arg[numargs]);
 
-    strcpy(p3, args_info.macallowed_arg[numargs]);
+    strncpy(p3, args_info.macallowed_arg[numargs], strlen(args_info.macallowed_arg[numargs]));
     p1 = p3;
     if ((p2 = strchr(p1, ','))) {
       *p2 = '\0';
@@ -1317,7 +1375,7 @@
 	char s[256];
 
 	if (sscanf(args_info.extadmvsa_arg[numargs],
-		   "%u,%u:%s", &i[0], &i[1], s) == 3) {
+		   "%u,%u:%256s", &i[0], &i[1], s) == 3) {
 	  char *idx = strchr(s, ':');
 	  _options.extadmvsa[numargs].attr_vsa = i[0];
 	  _options.extadmvsa[numargs].attr = i[1];
@@ -1329,7 +1387,7 @@
                     idx + 1, sizeof(_options.extadmvsa[numargs].data));
 	  }
 	} else if (sscanf(args_info.extadmvsa_arg[numargs],
-			  "%u:%s", &i[0], s) == 2) {
+			  "%u:%256s", &i[0], s) == 2) {
 	  char *idx = strchr(s, ':');
 	  _options.extadmvsa[numargs].attr = i[0];
 	  if (idx) *idx = 0;
@@ -1409,6 +1467,43 @@
   _options.locationupdate = STRDUP(args_info.locationupdate_arg);
 #endif
   _options.nochallenge = args_info.nochallenge_flag;
+  _options.successurlcustom = STRDUP(args_info.successurlcustom_arg);
+  _options.dbpath = STRDUP(args_info.dbpath_arg);
+  _options.usersdbpath = STRDUP(args_info.usersdbpath_arg);
+  _options.smsusers = args_info.smsusers_flag;
+  _options.duplicateusers = args_info.duplicateusers_flag;
+  _options.macusers = args_info.macusers_flag;
+  _options.trialusers = args_info.trialusers_flag;
+  _options.usersignup = STRDUP(args_info.usersignup_arg);
+  _options.macpass = STRDUP(args_info.macpass_arg);
+  _options.tos = args_info.tos_flag;
+  _options.registerusers = args_info.registerusers_flag;
+
+  _options.paramuamip = STRDUP(args_info.paramuamip_arg);
+  _options.paramuamport = STRDUP(args_info.paramuamport_arg);
+  _options.paramcalled  = STRDUP(args_info.paramcalled_arg);
+  _options.parammac = STRDUP(args_info.parammac_arg);
+  _options.paramip = STRDUP(args_info.paramip_arg);
+  _options.paramnasid = STRDUP(args_info.paramnasid_arg);
+  _options.paramsessionid = STRDUP(args_info.paramsessionid_arg);
+  _options.paramuserurl = STRDUP(args_info.paramuserurl_arg);
+  _options.paramchallenge = STRDUP(args_info.paramchallenge_arg);
+  _options.param1 = STRDUP(args_info.param1_arg);
+  _options.param1value = STRDUP(args_info.param1value_arg);
+  _options.param2  = STRDUP(args_info.param2_arg);
+  _options.param2value = STRDUP(args_info.param2value_arg);
+
+  _options.testtime = args_info.testtime_flag;
+#ifdef ENABLE_GSM
+  _options.modemid = STRDUP(args_info.modemid_arg);
+  if (!_options.modemid) {
+  	struct ubus_context *ubus;
+  	if ((ubus = ubus_connect(NULL))) {
+  		_options.modemid = STRDUP(lgsmu_get_default_modem_id(ubus));
+  		ubus_shutdown(ubus);
+  	}
+  }
+#endif
 #ifdef EX_OPT_MAIN
 #include EX_OPT_MAIN
 #endif
diff --recursive --unified --new-file --no-dereference orig/src/main-proxy.c src/src/main-proxy.c
--- orig/src/main-proxy.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/main-proxy.c	2024-01-26 11:00:37.000000000 +0000
@@ -325,7 +325,7 @@
 	    switch(attrs[i].t) {
               case 0: /*integer*/
                 {
-                  uint32_t v = (uint32_t) atoi(ptr+strlen(attrs[i].n));
+                  uint32_t v = (uint32_t) strtol(ptr+strlen(attrs[i].n), NULL, 0);
                   if (v > 0) {
                     radius_addattr(radius, &req->radius_res, attrs[i].a, attrs[i].v, attrs[i].va, v, NULL, 0);
 #if(_debug_)
diff --recursive --unified --new-file --no-dereference orig/src/main-query.c src/src/main-query.c
--- orig/src/main-query.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/main-query.c	2024-01-26 11:00:37.000000000 +0000
@@ -150,6 +150,11 @@
     sizeof(request.d.sess.params.maxoutputoctets),
     &request.d.sess.params.maxoutputoctets,
     "Max output octets (bytes)", 0, 0 },
+  { "warningoctets",
+    CMDSOCK_FIELD_INTEGER,
+    sizeof(request.d.sess.params.warningoctets),
+    &request.d.sess.params.warningoctets,
+    "Data amount over which an SMS warning is sent (bytes)", 0, 0 },
   { "maxbwup",
     CMDSOCK_FIELD_INTEGER,
     sizeof(request.d.sess.params.bandwidthmaxup),
@@ -323,16 +328,16 @@
           case CMDSOCK_FIELD_INTEGER:
             switch(args[i].length) {
               case 1:
-                *((uint8_t *)args[i].field) |= (uint8_t)atoi(argv[argidx+1]);
+                *((uint8_t *)args[i].field) |= (uint8_t)strtol(argv[argidx+1], NULL, 0);
                 break;
               case 2:
-                *((uint16_t *)args[i].field) |= (uint16_t)atoi(argv[argidx+1]);
+                *((uint16_t *)args[i].field) |= (uint16_t)strtol(argv[argidx+1], NULL, 0);
                 break;
               case 4:
-                *((uint32_t *)args[i].field) |= (uint32_t)atol(argv[argidx+1]);
+                *((uint32_t *)args[i].field) |= (uint32_t)strtol(argv[argidx+1], NULL, 0);
                 break;
               case 8:
-                *((uint64_t *)args[i].field) |= (uint64_t)atol(argv[argidx+1]);
+                *((uint64_t *)args[i].field) |= (uint64_t)strtol(argv[argidx+1], NULL, 0);
                 break;
             }
             break;
@@ -425,7 +430,7 @@
   int query_timeout = QUERY_TIMEOUT;
 
   if ((query_timeout_env = getenv("QUERY_TIMEOUT"))) {
-    query_timeout = atoi(query_timeout_env);
+    query_timeout = strtol(query_timeout_env, NULL, 0);
   }
 
   set_signal(SIGALRM, timeout_alarm);
@@ -459,7 +464,7 @@
     } else if (!strcmp(argv[argidx], "-p")) {
       argidx++;
       if (argidx >= argc) return usage(argv[0]);
-      peerid = atoi(argv[argidx++]);
+      peerid = strtol(argv[argidx++], NULL, 0);
 #endif
     } else if (!strcmp(argv[argidx], "-json")) {
       request.options |= CMDSOCK_OPT_JSON;
@@ -467,7 +472,7 @@
     } else if (!strcmp(argv[argidx], "-P")) {
       argidx++;
       if (argidx >= argc) return usage(argv[0]);
-      cmdsockport = atoi(argv[argidx++]);
+      cmdsockport = strtol(argv[argidx++], NULL, 0);
     }
   }
 
@@ -548,7 +553,7 @@
               request.mac[i] = temp[i];
 
             argidx++;
-            request.d.sess.params.routeidx = atoi(argv[argidx]);
+            request.d.sess.params.routeidx = strtol(argv[argidx], NULL, 0);
 
             if (request.type != CMDSOCK_ROUTE_GW)
               request.type = CMDSOCK_ROUTE_SET;
diff --recursive --unified --new-file --no-dereference orig/src/main-redir.c src/src/main-redir.c
--- orig/src/main-redir.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/main-redir.c	2024-01-26 11:00:37.000000000 +0000
@@ -396,7 +396,7 @@
 	    if (!strncasecmp(hdr, "content-length:", 15)) {
 	      char c = hdr[l];
 	      hdr[l] = 0;
-	      clen = req->clen = atoi(hdr+15);
+	      clen = req->clen = strtol(hdr+15, NULL, 0);
 	      syslog(LOG_DEBUG, "Detected Content Length %d", req->clen);
 	      hdr[l] = c;
 	    } else if (!strncasecmp(hdr, "content-type:", 13)) {
@@ -676,7 +676,7 @@
 
     if ((p = strchr(httpreq->host, ':'))) {
       *p++ = 0;
-      port = atoi(p);
+      port = strtol(p, NULL, 0);
     }
 
     if (conn_setup(&req->conn, httpreq->host, port,
diff --recursive --unified --new-file --no-dereference orig/src/main-response.c src/src/main-response.c
--- orig/src/main-response.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/main-response.c	2024-01-26 11:00:37.000000000 +0000
@@ -97,7 +97,7 @@
     return usage(argv[0]);
 
   if (argc == 5)
-    chap_ident = atoi(argv[idx+4]);
+    chap_ident = strtol(argv[idx+4], NULL, 0);
 
   /* challenge - argv 1 */
   if (strlen(argv[idx+1]) >= sizeof(buffer))
diff --recursive --unified --new-file --no-dereference orig/src/main-rtmon.c src/src/main-rtmon.c
--- orig/src/main-rtmon.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/main-rtmon.c	2024-01-26 11:00:37.000000000 +0000
@@ -70,7 +70,7 @@
     } else if (strcmp(argv[i], "-file")==0) {
       chilli_conf = argv[i+1];
     } else if (strcmp(argv[i], "-pid")==0) {
-      chilli_pid = atoi(argv[i+1]);
+      chilli_pid = strtol(argv[i+1], NULL, 0);
     }
   }
 
diff --recursive --unified --new-file --no-dereference orig/src/main.c src/src/main.c
--- orig/src/main.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/main.c	2024-01-26 11:00:37.000000000 +0000
@@ -83,14 +83,14 @@
 
 #if defined(__linux__)
   if ((ev = getenv("CHILLI_PRIORITY")) != NULL) {
-    if (setpriority(PRIO_PROCESS, getpid(), atoi(ev))) {
+    if (setpriority(PRIO_PROCESS, getpid(), strtol(ev, NULL, 0))) {
       perror("setpriority");
     }
   }
 
 #ifdef __NR_ioprio_set
   if ((ev = getenv("CHILLI_IOPRIO_RT")) != NULL) {
-    if (syscall(__NR_ioprio_set, IOPRIO_WHO_PROCESS, getpid(), atoi(ev) | IOPRIO_CLASS_RT << IOPRIO_CLASS_SHIFT) == -1) {
+    if (syscall(__NR_ioprio_set, IOPRIO_WHO_PROCESS, getpid(), strtol(ev, NULL, 0) | IOPRIO_CLASS_RT << IOPRIO_CLASS_SHIFT) == -1) {
       perror("ioprio_set");
     }
   }
diff --recursive --unified --new-file --no-dereference orig/src/ms_chap.c src/src/ms_chap.c
--- orig/src/ms_chap.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/ms_chap.c	2024-01-26 11:00:37.000000000 +0000
@@ -96,18 +96,19 @@
   des_key[6] = Get7Bits(key, 42);
   des_key[7] = Get7Bits(key, 49);
 
-  des_set_odd_parity((des_cblock *)des_key);
+  DES_set_odd_parity((DES_cblock *)des_key);
 }
 
 static void /* IN 8 octets IN 7 octest OUT 8 octets */
 DesEncrypt(u_char *clear, u_char *key, u_char *cipher)
 {
-  des_cblock		des_key;
-  des_key_schedule	key_schedule;
+	DES_cblock des_key;
+	DES_key_schedule key_schedule;
 
-  MakeKey(key, des_key);
-  des_set_key(&des_key, key_schedule);
-  des_ecb_encrypt((des_cblock *)clear, (des_cblock *)cipher, key_schedule, 1);
+	MakeKey(key, des_key);
+	DES_set_key(&des_key, &key_schedule);
+	DES_ecb_encrypt((DES_cblock *)clear, (DES_cblock *)cipher,
+			&key_schedule, 1);
 }
 
 #define LENGTH 20
diff --recursive --unified --new-file --no-dereference orig/src/mssl/httpsClient.c src/src/mssl/httpsClient.c
--- orig/src/mssl/httpsClient.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/mssl/httpsClient.c	2024-01-26 11:00:37.000000000 +0000
@@ -156,7 +156,7 @@
 	  err_exit("Out of memory");
 	break;
       case 'p':
-	if(!(port=atoi(optarg)))
+	if(!(port=strtol(optarg, NULL, 0)))
 	  err_exit("Bogus port specified");
 	break;
       case 's':
diff --recursive --unified --new-file --no-dereference orig/src/net.c src/src/net.c
--- orig/src/net.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/net.c	2024-01-26 11:00:37.000000000 +0000
@@ -939,7 +939,8 @@
   if (len < 0) {
     switch (errno) {
       case EWOULDBLOCK:
-        syslog(LOG_ERR, "%s: packet dropped due to congestion", strerror(errno));
+        if (_options.debug)
+          syslog(LOG_ERR, "%s: packet dropped due to congestion", strerror(errno));
         break;
 
 #ifdef ENETDOWN
@@ -960,7 +961,9 @@
 #endif
     }
 
-    syslog(LOG_ERR, "%s: net_write_eth(fd=%d, len=%zu) failed", strerror(errno), netif->fd, dlen);
+    if (_options.debug)
+      syslog(LOG_ERR, "%s: net_write_eth(fd=%d, len=%zu) failed", strerror(errno), netif->fd, dlen);
+
     return -1;
   }
 
diff --recursive --unified --new-file --no-dereference orig/src/net.h src/src/net.h
--- orig/src/net.h	2016-12-15 17:28:43.000000000 +0000
+++ src/src/net.h	2024-01-26 11:00:37.000000000 +0000
@@ -177,6 +177,7 @@
   struct pollfd pfds[MAX_SELECT];
 #endif
 #else
+  char padding[2]; // add padding to separate src and prot
   int maxfd;
   fd_set rfds, wfds, efds;
   struct timeval idleTime;
@@ -191,6 +192,7 @@
   uint8_t hwtype;
   uint8_t hwaddr[PKT_ETH_ALEN];
   char devname[IFNAMSIZ+1];
+  char padding[2]; // add padding to separate src and prot
   int devflags;
   int ifindex;
   int mtu;
@@ -251,6 +253,7 @@
   nat_t *nat;
 #endif
 
+  char padding2[2]; // add padding to separate src and prot
   select_ctx *sctx;
 
   uint8_t flags;
diff --recursive --unified --new-file --no-dereference orig/src/options.c src/src/options.c
--- orig/src/options.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/options.c	2024-01-26 11:00:37.000000000 +0000
@@ -371,6 +371,29 @@
       return 0;
   }
 
+  if (!option_s_l(bt, &o.successurlcustom)) return 0;
+  if (!option_s_l(bt, &o.dbpath)) return 0;
+  if (!option_s_l(bt, &o.usersdbpath)) return 0;
+  if (!option_s_l(bt, &o.usersignup)) return 0;
+  if (!option_s_l(bt, &o.macpass)) return 0;
+  if (!option_s_l(bt, &o.paramuamip)) return 0;
+  if (!option_s_l(bt, &o.paramuamport)) return 0;
+  if (!option_s_l(bt, &o.paramcalled)) return 0;
+  if (!option_s_l(bt, &o.parammac)) return 0;
+  if (!option_s_l(bt, &o.paramip)) return 0;
+  if (!option_s_l(bt, &o.paramnasid)) return 0;
+  if (!option_s_l(bt, &o.paramsessionid)) return 0;
+  if (!option_s_l(bt, &o.paramuserurl)) return 0;
+  if (!option_s_l(bt, &o.paramchallenge)) return 0;
+  if (!option_s_l(bt, &o.param1)) return 0;
+  if (!option_s_l(bt, &o.param1value)) return 0;
+  if (!option_s_l(bt, &o.param2)) return 0;
+  if (!option_s_l(bt, &o.param2value)) return 0;
+
+#ifdef ENABLE_GSM
+  if (!option_s_l(bt, &o.modemid)) return 0;
+#endif
+
 #ifdef EX_OPTIONS_LOAD
 #include EX_OPTIONS_LOAD
 #endif
@@ -571,6 +594,28 @@
       return 0;
   }
 
+  if (!option_s_s(bt, &o.successurlcustom)) return 0;
+  if (!option_s_s(bt, &o.dbpath)) return 0;
+  if (!option_s_s(bt, &o.usersdbpath)) return 0;
+  if (!option_s_s(bt, &o.usersignup)) return 0;
+  if (!option_s_s(bt, &o.macpass)) return 0;
+  if (!option_s_s(bt, &o.paramuamip)) return 0;
+  if (!option_s_s(bt, &o.paramuamport)) return 0;
+  if (!option_s_s(bt, &o.paramcalled)) return 0;
+  if (!option_s_s(bt, &o.parammac)) return 0;
+  if (!option_s_s(bt, &o.paramip)) return 0;
+  if (!option_s_s(bt, &o.paramnasid)) return 0;
+  if (!option_s_s(bt, &o.paramsessionid)) return 0;
+  if (!option_s_s(bt, &o.paramuserurl)) return 0;
+  if (!option_s_s(bt, &o.paramchallenge)) return 0;
+  if (!option_s_s(bt, &o.param1)) return 0;
+  if (!option_s_s(bt, &o.param1value)) return 0;
+  if (!option_s_s(bt, &o.param2)) return 0;
+  if (!option_s_s(bt, &o.param2value)) return 0;
+#ifdef ENABLE_GSM
+  if (!option_s_s(bt, &o.modemid)) return 0;
+#endif
+
 #ifdef EX_OPTIONS_SAVE
 #include EX_OPTIONS_SAVE
 #endif
diff --recursive --unified --new-file --no-dereference orig/src/options.h src/src/options.h
--- orig/src/options.h	2016-12-15 17:28:43.000000000 +0000
+++ src/src/options.h	2024-01-26 11:00:37.000000000 +0000
@@ -188,6 +188,8 @@
   uint16_t forcedns2_port;        /* Port to force DNS to */
 #endif
 
+
+
   /* booleans */
   uint8_t layer3;                   /* Layer3 only support */
   uint8_t allowdyn:1;               /* Allow dynamic address allocation */
@@ -240,6 +242,7 @@
   uint8_t uamauthedallowed:1;
   uint8_t postauth_proxyssl:1;
   uint8_t nochallenge:1;
+  uint8_t successuserurl:1;         /* Do not return to the UAM server on success, original url instead */
 
 #ifdef USING_MMAP
   uint8_t mmapring:1;
@@ -338,6 +341,36 @@
   uint64_t defbandwidthmaxup;
   uint32_t defidletimeout;
   uint16_t definteriminterval;
+  uint64_t defmaxdownload;
+  uint64_t defmaxupload;
+  uint64_t defwarning;
+  uint16_t deflimitperiod;
+  uint16_t deflimitstart;
+  uint64_t defexpirationtime;
+
+  uint64_t dynsessiontimeout;
+  uint64_t dynbandwidthmaxdown;
+  uint64_t dynbandwidthmaxup;
+  uint32_t dynidletimeout;
+  uint16_t dyninteriminterval;
+  uint64_t dynmaxdownload;
+  uint64_t dynmaxupload;
+  uint64_t dynwarning;
+  uint16_t dynlimitperiod;
+  uint16_t dynlimitstart;
+  uint64_t dynexpirationtime;
+
+    uint64_t trialsessiontimeout;
+    uint64_t trialbandwidthmaxdown;
+    uint64_t trialbandwidthmaxup;
+    uint32_t trialidletimeout;
+    uint16_t trialinteriminterval;
+    uint64_t trialmaxdownload;
+    uint64_t trialmaxupload;
+    uint64_t trialwarning;
+    uint16_t triallimitperiod;
+    uint16_t triallimitstart;
+    uint64_t trialexpirationtime;
 
   uint32_t challengetimeout;
   uint32_t challengetimeout2;
@@ -426,6 +459,37 @@
   char *moddir;
 #endif
 
+  char *successurlcustom;
+  char *dbpath;
+  char *usersdbpath;
+  char * usersignup;                /* Script to run after user has been created */
+  char * macpass;
+#ifdef ENABLE_GSM
+  char *modemid;
+#endif
+  uint8_t smsusers:1;
+  uint8_t macusers:1;
+  uint8_t trialusers:1;
+  uint8_t registerusers:1;
+  uint8_t tos:1;
+  uint8_t duplicateusers:1;
+
+  char *paramuamip;
+  char *paramuamport;
+  char *paramcalled;
+  char *parammac;
+  char *paramip;
+  char *paramnasid;
+  char *paramsessionid;
+  char *paramuserurl;
+  char *paramchallenge;
+  char *param1;
+  char *param1value;
+  char *param2;
+  char *param2value;
+
+  uint8_t testtime:1;
+
   char * _data; /* actual data buffer for loaded options */
 };
 
diff --recursive --unified --new-file --no-dereference orig/src/passwd_md5crypt.c src/src/passwd_md5crypt.c
--- orig/src/passwd_md5crypt.c	1970-01-01 00:00:00.000000000 +0000
+++ src/src/passwd_md5crypt.c	2024-01-26 11:00:37.000000000 +0000
@@ -0,0 +1,293 @@
+#include "chilli.h"
+#include <assert.h>
+#include <openssl/rand.h>
+#include <openssl/evp.h>
+
+#define MD5_CTX MD5_CTX_OpenSSL
+#include <openssl/md5.h>
+#undef MD5_CTX
+
+static unsigned const char cov_2char[64] = {
+	/* from crypto/des/fcrypt.c */
+	0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
+	0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A,
+	0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55,
+	0x56, 0x57, 0x58, 0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,
+	0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71,
+	0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A
+};
+
+static const char ascii_dollar[] = { 0x24, 0x00 };
+
+size_t OPENSSL_strlcpy(char *dst, const char *src, size_t size)
+{
+	size_t l = 0;
+	for (; size > 1 && *src; size--) {
+		*dst++ = *src++;
+		l++;
+	}
+	if (size)
+		*dst = CH_ZERO;
+	return l + strlen(src);
+}
+
+size_t OPENSSL_strlcat(char *dst, const char *src, size_t size)
+{
+	size_t l = 0;
+	for (; size > 0 && *dst; size--, dst++)
+		l++;
+	return l + OPENSSL_strlcpy(dst, src, size);
+}
+
+/*
+ * MD5-based password algorithm (should probably be available as a library
+ * function; then the static buffer would not be acceptable). For magic
+ * string "1", this should be compatible to the MD5-based BSD password
+ * algorithm. For 'magic' string "apr1", this is compatible to the MD5-based
+ * Apache password algorithm. (Apparently, the Apache password algorithm is
+ * identical except that the 'magic' string was changed -- the laziest
+ * application of the NIH principle I've ever encountered.)
+ */
+char *md5crypt(const char *passwd, const char *magic, const char *salt)
+{
+	/* "$apr1$..salt..$.......md5hash..........\0" */
+	static char out_buf[6 + 9 + 24 + 2];
+	unsigned char buf[MD5_DIGEST_LENGTH];
+	char ascii_magic[5]; /* "apr1" plus '\0' */
+	char ascii_salt[9]; /* Max 8 chars plus '\0' */
+	char *ascii_passwd = NULL;
+	char *salt_out;
+	int n;
+	unsigned int i;
+	EVP_MD_CTX *md = NULL, *md2 = NULL;
+	size_t passwd_len, salt_len, magic_len;
+
+	passwd_len = strlen(passwd);
+
+	out_buf[0] = 0;
+	magic_len  = strlen(magic);
+	OPENSSL_strlcpy(ascii_magic, magic, sizeof(ascii_magic));
+#ifdef CHARSET_EBCDIC
+	if ((magic[0] & 0x80) != 0) /* High bit is 1 in EBCDIC alnums */
+		ebcdic2ascii(ascii_magic, ascii_magic, magic_len);
+#endif
+
+	/* The salt gets truncated to 8 chars */
+	OPENSSL_strlcpy(ascii_salt, salt, sizeof(ascii_salt));
+	salt_len = strlen(ascii_salt);
+#ifdef CHARSET_EBCDIC
+	ebcdic2ascii(ascii_salt, ascii_salt, salt_len);
+#endif
+
+#ifdef CHARSET_EBCDIC
+	ascii_passwd = OPENSSL_strdup(passwd);
+	if (ascii_passwd == NULL)
+		return NULL;
+	ebcdic2ascii(ascii_passwd, ascii_passwd, passwd_len);
+	passwd = ascii_passwd;
+#endif
+
+	if (magic_len > 0) {
+		OPENSSL_strlcat(out_buf, ascii_dollar, sizeof(out_buf));
+
+		if (magic_len > 4) /* assert it's  "1" or "apr1" */
+			goto err;
+
+		OPENSSL_strlcat(out_buf, ascii_magic, sizeof(out_buf));
+		OPENSSL_strlcat(out_buf, ascii_dollar, sizeof(out_buf));
+	}
+
+	OPENSSL_strlcat(out_buf, ascii_salt, sizeof(out_buf));
+
+	if (strlen(out_buf) > 6 + 8) /* assert "$apr1$..salt.." */
+		goto err;
+
+	salt_out = out_buf;
+	if (magic_len > 0)
+		salt_out += 2 + magic_len;
+
+	if (salt_len > 8)
+		goto err;
+
+	md = EVP_MD_CTX_new();
+	if (md == NULL || !EVP_DigestInit_ex(md, EVP_md5(), NULL) ||
+	    !EVP_DigestUpdate(md, passwd, passwd_len))
+		goto err;
+
+	if (magic_len > 0)
+		if (!EVP_DigestUpdate(md, ascii_dollar, 1) ||
+		    !EVP_DigestUpdate(md, ascii_magic, magic_len) ||
+		    !EVP_DigestUpdate(md, ascii_dollar, 1))
+			goto err;
+
+	if (!EVP_DigestUpdate(md, ascii_salt, salt_len))
+		goto err;
+
+	md2 = EVP_MD_CTX_new();
+	if (md2 == NULL || !EVP_DigestInit_ex(md2, EVP_md5(), NULL) ||
+	    !EVP_DigestUpdate(md2, passwd, passwd_len) ||
+	    !EVP_DigestUpdate(md2, ascii_salt, salt_len) ||
+	    !EVP_DigestUpdate(md2, passwd, passwd_len) ||
+	    !EVP_DigestFinal_ex(md2, buf, NULL))
+		goto err;
+
+	for (i = passwd_len; i > sizeof(buf); i -= sizeof(buf)) {
+		if (!EVP_DigestUpdate(md, buf, sizeof(buf)))
+			goto err;
+	}
+	if (!EVP_DigestUpdate(md, buf, i))
+		goto err;
+
+	n = passwd_len;
+	while (n) {
+		if (!EVP_DigestUpdate(md, (n & 1) ? "\0" : passwd, 1))
+			goto err;
+		n >>= 1;
+	}
+	if (!EVP_DigestFinal_ex(md, buf, NULL))
+		return NULL;
+
+	for (i = 0; i < 1000; i++) {
+		if (!EVP_DigestInit_ex(md2, EVP_md5(), NULL))
+			goto err;
+		if (!EVP_DigestUpdate(
+			    md2, (i & 1) ? (unsigned const char *)passwd : buf,
+			    (i & 1) ? passwd_len : sizeof(buf)))
+			goto err;
+		if (i % 3) {
+			if (!EVP_DigestUpdate(md2, ascii_salt, salt_len))
+				goto err;
+		}
+		if (i % 7) {
+			if (!EVP_DigestUpdate(md2, passwd, passwd_len))
+				goto err;
+		}
+		if (!EVP_DigestUpdate(
+			    md2, (i & 1) ? buf : (unsigned const char *)passwd,
+			    (i & 1) ? sizeof(buf) : passwd_len))
+			goto err;
+		if (!EVP_DigestFinal_ex(md2, buf, NULL))
+			goto err;
+	}
+	EVP_MD_CTX_free(md2);
+	EVP_MD_CTX_free(md);
+	md2 = NULL;
+	md  = NULL;
+
+	{
+		/* transform buf into output string */
+		unsigned char buf_perm[sizeof(buf)];
+		int dest, source;
+		char *output;
+
+		/* silly output permutation */
+		for (dest = 0, source = 0; dest < 14;
+		     dest++, source   = (source + 6) % 17)
+			  buf_perm[dest] = buf[source];
+		buf_perm[14] = buf[5];
+		buf_perm[15] = buf[11];
+#ifndef PEDANTIC /* Unfortunately, this generates a "no \
+                  * effect" warning */
+		assert(16 == sizeof(buf_perm));
+#endif
+
+		output = salt_out + salt_len;
+		// assert(output == out_buf + strlen(out_buf));
+		if (output != out_buf + strlen(out_buf))
+			return NULL;
+
+		*output++ = ascii_dollar[0];
+
+		for (i = 0; i < 15; i += 3) {
+			*output++ = cov_2char[buf_perm[i + 2] & 0x3f];
+			*output++ = cov_2char[((buf_perm[i + 1] & 0xf) << 2) |
+					      (buf_perm[i + 2] >> 6)];
+			*output++ = cov_2char[((buf_perm[i] & 3) << 4) |
+					      (buf_perm[i + 1] >> 4)];
+			*output++ = cov_2char[buf_perm[i] >> 2];
+		}
+		assert(i == 15);
+		*output++ = cov_2char[buf_perm[i] & 0x3f];
+		*output++ = cov_2char[buf_perm[i] >> 6];
+		*output	  = 0;
+		assert(strlen(out_buf) < sizeof(out_buf));
+#ifdef CHARSET_EBCDIC
+		ascii2ebcdic(out_buf, out_buf, strlen(out_buf));
+#endif
+	}
+
+	return out_buf;
+
+err:
+	OPENSSL_free(ascii_passwd);
+	EVP_MD_CTX_free(md2);
+	EVP_MD_CTX_free(md);
+	return NULL;
+}
+
+int make_md5_salt(char **salt_p)
+{
+	if (salt_p == NULL)
+		return -1;
+
+	size_t saltlen = 8;
+	size_t i;
+
+	*salt_p = malloc(saltlen + 1);
+
+	if (RAND_bytes((unsigned char *)*salt_p, saltlen) <= 0)
+		return -1;
+
+	for (i = 0; i < saltlen; i++)
+		(*salt_p)[i] = cov_2char[(*salt_p)[i] & 0x3f]; /* 6 bits */
+	(*salt_p)[i] = 0;
+
+	return 0;
+}
+
+char *hash_md5_with_salt(char *password, char *salt)
+{
+	if (password != NULL && salt != NULL)
+		return strdup(md5crypt(password, "1", salt));
+
+	return NULL;
+}
+
+char *hash_md5(char *password)
+{
+	char *salt = NULL;
+	if (!make_md5_salt(&salt)) {
+		char *hashed = hash_md5_with_salt(password, salt);
+		free(salt);
+		return hashed;
+	}
+
+	return NULL;
+}
+
+// char *extract_salt(char *hash)
+// {
+// 	size_t i	    = 0;
+// 	int salt_offset	    = 0;
+// 	int separator_count = 0;
+// 	char *salt	    = malloc(strlen(hash) + 1);
+
+// 	if (!salt)
+// 		return NULL;
+
+// 	for (; i < strlen(hash); i++) {
+// 		if (separator_count == 1) {
+// 			salt_offset = i + 1;
+// 		} else if (separator_count == 2) {
+// 			salt[i - salt_offset] = hash[i];
+// 		} else if (separator_count >= 3) {
+// 			salt[i - salt_offset - 1] = '\0';
+// 			return salt;
+// 		}
+// 		if (hash[i] == '$')
+// 			separator_count++;
+// 	}
+
+// 	free(salt);
+// 	return NULL;
+// }
diff --recursive --unified --new-file --no-dereference orig/src/passwd_md5crypt.h src/src/passwd_md5crypt.h
--- orig/src/passwd_md5crypt.h	1970-01-01 00:00:00.000000000 +0000
+++ src/src/passwd_md5crypt.h	2024-01-26 11:00:37.000000000 +0000
@@ -0,0 +1,11 @@
+#ifndef PASSWD_MD5CRYPT_H__
+#define PASSWD_MD5CRYPT_H__
+
+#define CH_ZERO		'\0'
+
+int make_md5_salt(char **salt_p);
+char *hash_md5_with_salt(char *password, char *salt);
+char *hash_md5(char *password);
+// char *extract_salt(char *hash);
+
+#endif /* passwd_md5crypt.h */
diff --recursive --unified --new-file --no-dereference orig/src/passwd_shacrypt.c src/src/passwd_shacrypt.c
--- orig/src/passwd_shacrypt.c	1970-01-01 00:00:00.000000000 +0000
+++ src/src/passwd_shacrypt.c	2024-01-26 11:00:37.000000000 +0000
@@ -0,0 +1,406 @@
+#include <assert.h>
+#include <openssl/rand.h>
+#include <openssl/evp.h>
+#include <openssl/sha.h>
+#include <string.h>
+
+#include "passwd_shacrypt.h"
+
+static const unsigned char cov_2char[64] = {
+    /* from crypto/des/fcrypt.c */
+    0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35,
+    0x36, 0x37, 0x38, 0x39, 0x41, 0x42, 0x43, 0x44,
+    0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C,
+    0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54,
+    0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x61, 0x62,
+    0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A,
+    0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72,
+    0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A
+};
+
+static const char ascii_dollar[] = { 0x24, 0x00 };
+
+/*
+ * SHA based password algorithm, describe by Ulrich Drepper here:
+ * https://www.akkadia.org/drepper/SHA-crypt.txt
+ * (note that it's in the public domain)
+ */
+static char *shacrypt(const char *passwd, const char *magic, const char *salt)
+{
+    /* Prefix for optional rounds specification.  */
+    static const char rounds_prefix[] = "rounds=";
+    /* Maximum salt string length.  */
+# define SALT_LEN_MAX 16
+    /* Default number of rounds if not explicitly specified.  */
+# define ROUNDS_DEFAULT 5000
+    /* Minimum number of rounds.  */
+# define ROUNDS_MIN 1000
+    /* Maximum number of rounds.  */
+# define ROUNDS_MAX 999999999
+
+    /* "$6$rounds=<N>$......salt......$...shahash(up to 86 chars)...\0" */
+    static char out_buf[3 + 17 + 17 + 86 + 1];
+    unsigned char buf[SHA512_DIGEST_LENGTH];
+    unsigned char temp_buf[SHA512_DIGEST_LENGTH];
+    size_t buf_size = 0;
+    char ascii_magic[2];
+    char ascii_salt[17];          /* Max 16 chars plus '\0' */
+    char *ascii_passwd = NULL;
+    size_t n;
+    EVP_MD_CTX *md = NULL, *md2 = NULL;
+    const EVP_MD *sha = NULL;
+    size_t passwd_len, salt_len, magic_len;
+    unsigned int rounds = ROUNDS_DEFAULT;        /* Default */
+    char rounds_custom = 0;
+    char *p_bytes = NULL;
+    char *s_bytes = NULL;
+    char *cp = NULL;
+
+    passwd_len = strlen(passwd);
+    magic_len = strlen(magic);
+
+    /* assert it's "5" or "6" */
+    if (magic_len != 1)
+        return NULL;
+
+    switch (magic[0]) {
+    case '5':
+        sha = EVP_sha256();
+        buf_size = 32;
+        break;
+    case '6':
+        sha = EVP_sha512();
+        buf_size = 64;
+        break;
+    default:
+        return NULL;
+    }
+
+    if (strncmp(salt, rounds_prefix, sizeof(rounds_prefix) - 1) == 0) {
+        const char *num = salt + sizeof(rounds_prefix) - 1;
+        char *endp;
+        unsigned long int srounds = strtoul (num, &endp, 10);
+        if (*endp == '$') {
+            salt = endp + 1;
+            if (srounds > ROUNDS_MAX)
+                rounds = ROUNDS_MAX;
+            else if (srounds < ROUNDS_MIN)
+                rounds = ROUNDS_MIN;
+            else
+                rounds = (unsigned int)srounds;
+            rounds_custom = 1;
+        } else {
+            return NULL;
+        }
+    }
+
+    OPENSSL_strlcpy(ascii_magic, magic, sizeof(ascii_magic));
+#ifdef CHARSET_EBCDIC
+    if ((magic[0] & 0x80) != 0)    /* High bit is 1 in EBCDIC alnums */
+        ebcdic2ascii(ascii_magic, ascii_magic, magic_len);
+#endif
+
+    /* The salt gets truncated to 16 chars */
+    OPENSSL_strlcpy(ascii_salt, salt, sizeof(ascii_salt));
+    salt_len = strlen(ascii_salt);
+#ifdef CHARSET_EBCDIC
+    ebcdic2ascii(ascii_salt, ascii_salt, salt_len);
+#endif
+
+#ifdef CHARSET_EBCDIC
+    ascii_passwd = OPENSSL_strdup(passwd);
+    if (ascii_passwd == NULL)
+        return NULL;
+    ebcdic2ascii(ascii_passwd, ascii_passwd, passwd_len);
+    passwd = ascii_passwd;
+#endif
+
+    out_buf[0] = 0;
+    OPENSSL_strlcat(out_buf, ascii_dollar, sizeof(out_buf));
+    OPENSSL_strlcat(out_buf, ascii_magic, sizeof(out_buf));
+    OPENSSL_strlcat(out_buf, ascii_dollar, sizeof(out_buf));
+    if (rounds_custom) {
+        char tmp_buf[80]; /* "rounds=999999999" */
+        sprintf(tmp_buf, "rounds=%u", rounds);
+#ifdef CHARSET_EBCDIC
+        /* In case we're really on a ASCII based platform and just pretend */
+        if (tmp_buf[0] != 0x72)  /* ASCII 'r' */
+            ebcdic2ascii(tmp_buf, tmp_buf, strlen(tmp_buf));
+#endif
+        OPENSSL_strlcat(out_buf, tmp_buf, sizeof(out_buf));
+        OPENSSL_strlcat(out_buf, ascii_dollar, sizeof(out_buf));
+    }
+    OPENSSL_strlcat(out_buf, ascii_salt, sizeof(out_buf));
+
+    /* assert "$5$rounds=999999999$......salt......" */
+    if (strlen(out_buf) > 3 + 17 * rounds_custom + salt_len)
+        goto err;
+
+    md = EVP_MD_CTX_new();
+    if (md == NULL
+        || !EVP_DigestInit_ex(md, sha, NULL)
+        || !EVP_DigestUpdate(md, passwd, passwd_len)
+        || !EVP_DigestUpdate(md, ascii_salt, salt_len))
+        goto err;
+
+    md2 = EVP_MD_CTX_new();
+    if (md2 == NULL
+        || !EVP_DigestInit_ex(md2, sha, NULL)
+        || !EVP_DigestUpdate(md2, passwd, passwd_len)
+        || !EVP_DigestUpdate(md2, ascii_salt, salt_len)
+        || !EVP_DigestUpdate(md2, passwd, passwd_len)
+        || !EVP_DigestFinal_ex(md2, buf, NULL))
+        goto err;
+
+    for (n = passwd_len; n > buf_size; n -= buf_size) {
+        if (!EVP_DigestUpdate(md, buf, buf_size))
+            goto err;
+    }
+    if (!EVP_DigestUpdate(md, buf, n))
+        goto err;
+
+    n = passwd_len;
+    while (n) {
+        if (!EVP_DigestUpdate(md,
+                              (n & 1) ? buf : (const unsigned char *)passwd,
+                              (n & 1) ? buf_size : passwd_len))
+            goto err;
+        n >>= 1;
+    }
+    if (!EVP_DigestFinal_ex(md, buf, NULL))
+        goto err;
+
+    /* P sequence */
+    if (!EVP_DigestInit_ex(md2, sha, NULL))
+        goto err;
+
+    for (n = passwd_len; n > 0; n--)
+        if (!EVP_DigestUpdate(md2, passwd, passwd_len))
+            goto err;
+
+    if (!EVP_DigestFinal_ex(md2, temp_buf, NULL))
+        goto err;
+
+    if ((p_bytes = OPENSSL_zalloc(passwd_len)) == NULL)
+        goto err;
+    for (cp = p_bytes, n = passwd_len; n > buf_size; n -= buf_size, cp += buf_size)
+        memcpy(cp, temp_buf, buf_size);
+    memcpy(cp, temp_buf, n);
+
+    /* S sequence */
+    if (!EVP_DigestInit_ex(md2, sha, NULL))
+        goto err;
+
+    for (n = 16 + buf[0]; n > 0; n--)
+        if (!EVP_DigestUpdate(md2, ascii_salt, salt_len))
+            goto err;
+
+    if (!EVP_DigestFinal_ex(md2, temp_buf, NULL))
+        goto err;
+
+    if ((s_bytes = OPENSSL_zalloc(salt_len)) == NULL)
+        goto err;
+    for (cp = s_bytes, n = salt_len; n > buf_size; n -= buf_size, cp += buf_size)
+        memcpy(cp, temp_buf, buf_size);
+    memcpy(cp, temp_buf, n);
+
+    for (n = 0; n < rounds; n++) {
+        if (!EVP_DigestInit_ex(md2, sha, NULL))
+            goto err;
+        if (!EVP_DigestUpdate(md2,
+                              (n & 1) ? (const unsigned char *)p_bytes : buf,
+                              (n & 1) ? passwd_len : buf_size))
+            goto err;
+        if (n % 3) {
+            if (!EVP_DigestUpdate(md2, s_bytes, salt_len))
+                goto err;
+        }
+        if (n % 7) {
+            if (!EVP_DigestUpdate(md2, p_bytes, passwd_len))
+                goto err;
+        }
+        if (!EVP_DigestUpdate(md2,
+                              (n & 1) ? buf : (const unsigned char *)p_bytes,
+                              (n & 1) ? buf_size : passwd_len))
+                goto err;
+        if (!EVP_DigestFinal_ex(md2, buf, NULL))
+                goto err;
+    }
+    EVP_MD_CTX_free(md2);
+    EVP_MD_CTX_free(md);
+    md2 = NULL;
+    md = NULL;
+    OPENSSL_free(p_bytes);
+    OPENSSL_free(s_bytes);
+    p_bytes = NULL;
+    s_bytes = NULL;
+
+    cp = out_buf + strlen(out_buf);
+    *cp++ = ascii_dollar[0];
+
+# define b64_from_24bit(B2, B1, B0, N)                                   \
+    do {                                                                \
+        unsigned int w = ((B2) << 16) | ((B1) << 8) | (B0);             \
+        int i = (N);                                                    \
+        while (i-- > 0)                                                 \
+            {                                                           \
+                *cp++ = cov_2char[w & 0x3f];                            \
+                w >>= 6;                                                \
+            }                                                           \
+    } while (0)
+
+    switch (magic[0]) {
+    case '5':
+        b64_from_24bit (buf[0], buf[10], buf[20], 4);
+        b64_from_24bit (buf[21], buf[1], buf[11], 4);
+        b64_from_24bit (buf[12], buf[22], buf[2], 4);
+        b64_from_24bit (buf[3], buf[13], buf[23], 4);
+        b64_from_24bit (buf[24], buf[4], buf[14], 4);
+        b64_from_24bit (buf[15], buf[25], buf[5], 4);
+        b64_from_24bit (buf[6], buf[16], buf[26], 4);
+        b64_from_24bit (buf[27], buf[7], buf[17], 4);
+        b64_from_24bit (buf[18], buf[28], buf[8], 4);
+        b64_from_24bit (buf[9], buf[19], buf[29], 4);
+        b64_from_24bit (0, buf[31], buf[30], 3);
+        break;
+    case '6':
+        b64_from_24bit (buf[0], buf[21], buf[42], 4);
+        b64_from_24bit (buf[22], buf[43], buf[1], 4);
+        b64_from_24bit (buf[44], buf[2], buf[23], 4);
+        b64_from_24bit (buf[3], buf[24], buf[45], 4);
+        b64_from_24bit (buf[25], buf[46], buf[4], 4);
+        b64_from_24bit (buf[47], buf[5], buf[26], 4);
+        b64_from_24bit (buf[6], buf[27], buf[48], 4);
+        b64_from_24bit (buf[28], buf[49], buf[7], 4);
+        b64_from_24bit (buf[50], buf[8], buf[29], 4);
+        b64_from_24bit (buf[9], buf[30], buf[51], 4);
+        b64_from_24bit (buf[31], buf[52], buf[10], 4);
+        b64_from_24bit (buf[53], buf[11], buf[32], 4);
+        b64_from_24bit (buf[12], buf[33], buf[54], 4);
+        b64_from_24bit (buf[34], buf[55], buf[13], 4);
+        b64_from_24bit (buf[56], buf[14], buf[35], 4);
+        b64_from_24bit (buf[15], buf[36], buf[57], 4);
+        b64_from_24bit (buf[37], buf[58], buf[16], 4);
+        b64_from_24bit (buf[59], buf[17], buf[38], 4);
+        b64_from_24bit (buf[18], buf[39], buf[60], 4);
+        b64_from_24bit (buf[40], buf[61], buf[19], 4);
+        b64_from_24bit (buf[62], buf[20], buf[41], 4);
+        b64_from_24bit (0, 0, buf[63], 2);
+        break;
+    default:
+        goto err;
+    }
+    *cp = '\0';
+#ifdef CHARSET_EBCDIC
+    ascii2ebcdic(out_buf, out_buf, strlen(out_buf));
+#endif
+
+    return out_buf;
+
+ err:
+    EVP_MD_CTX_free(md2);
+    EVP_MD_CTX_free(md);
+    OPENSSL_free(p_bytes);
+    OPENSSL_free(s_bytes);
+    OPENSSL_free(ascii_passwd);
+    return NULL;
+}
+
+int make_sha512_salt(char **salt_p)
+{
+	if (salt_p == NULL)
+		return -1;
+
+	size_t saltlen = 16;
+	size_t i;
+
+	*salt_p = malloc(saltlen + 1);
+
+	if (RAND_bytes((unsigned char *)*salt_p, saltlen) <= 0)
+		return -1;
+
+	for (i = 0; i < saltlen; i++)
+		(*salt_p)[i] = cov_2char[(*salt_p)[i] & 0x3f]; /* 6 bits */
+	(*salt_p)[i] = 0;
+
+	return 0;
+}
+
+char *hash_sha512_with_salt(char *password, char *salt)
+{
+	if (password != NULL && salt != NULL)
+		return strdup(shacrypt(password, "6", salt));
+
+	return NULL;
+}
+
+char *hash_sha512(char *password)
+{
+	char *salt = NULL;
+	if (!make_sha512_salt(&salt)) {
+		char *hashed = hash_sha512_with_salt(password, salt);
+		free(salt);
+		return hashed;
+	}
+
+	return NULL;
+}
+
+char *extract_salt(char *hash)
+{
+	size_t i	    = 0;
+	int salt_offset	    = 0;
+	int separator_count = 0;
+	char *salt	    = malloc(strlen(hash) + 1);
+
+	if (!salt)
+		return NULL;
+
+	for (; i < strlen(hash); i++) {
+		if (separator_count == 1) {
+			salt_offset = i + 1;
+		} else if (separator_count == 2) {
+			salt[i - salt_offset] = hash[i];
+		} else if (separator_count >= 3) {
+			salt[i - salt_offset - 1] = '\0';
+			return salt;
+		}
+		if (hash[i] == '$')
+			separator_count++;
+	}
+
+	free(salt);
+	return NULL;
+}
+
+hash_type get_hash_type(char *hash) {
+	hash_type hash_type = HASH_NULL;
+	size_t i	    = 0;
+	int hash_id_offset	    = 0;
+	int separator_count = 0;
+	char *hash_id	    = malloc(strlen(hash) + 1);
+
+	if (!hash_id)
+		return HASH_NULL;
+
+	for (; i < strlen(hash); i++) {
+		if (separator_count == 1 && hash[i] != '$') {
+			hash_id[i - hash_id_offset] = hash[i];
+		} else {
+			hash_id[i - hash_id_offset] = '\0';
+			hash_id_offset++;
+		}
+		if (hash[i] == '$') {
+			separator_count++;
+		}
+	}
+
+	if (!strcmp(hash_id, "1")) {
+		hash_type = HASH_MD5;
+	} else if (!strcmp(hash_id, "6")) {
+		hash_type = HASH_SHA512;
+	}
+
+	free(hash_id);
+	return hash_type;
+}
diff --recursive --unified --new-file --no-dereference orig/src/passwd_shacrypt.h src/src/passwd_shacrypt.h
--- orig/src/passwd_shacrypt.h	1970-01-01 00:00:00.000000000 +0000
+++ src/src/passwd_shacrypt.h	2024-01-26 11:00:37.000000000 +0000
@@ -0,0 +1,18 @@
+#ifndef PASSWD_SHA512CRYPT_H__
+#define PASSWD_SHA512CRYPT_H__
+
+#define CH_ZERO		'\0'
+
+typedef enum {
+	HASH_MD5,
+	HASH_SHA512,
+	HASH_NULL
+} hash_type;
+
+int make_sha512_salt(char **salt_p);
+char *hash_sha512_with_salt(char *password, char *salt);
+char *hash_sha512(char *password);
+char *extract_salt(char *hash);
+hash_type get_hash_type(char *hash);
+
+#endif /* passwd_sha512crypt.h */
diff --recursive --unified --new-file --no-dereference orig/src/patricia.c src/src/patricia.c
--- orig/src/patricia.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/patricia.c	2024-01-26 11:00:37.000000000 +0000
@@ -264,7 +264,7 @@
 #endif /* HAVE_IPV6 */
 
   if ((cp = strchr (string, '/')) != NULL) {
-    bitlen = atol (cp + 1);
+    bitlen = strtol(cp + 1, NULL, 0);
     /* *cp = '\0'; */
     /* copy the string to save. Avoid destroying the string */
     assert (cp - string < MAXLINE);
diff --recursive --unified --new-file --no-dereference orig/src/radius.h src/src/radius.h
--- orig/src/radius.h	2016-12-15 17:28:43.000000000 +0000
+++ src/src/radius.h	2024-01-26 11:00:37.000000000 +0000
@@ -202,9 +202,9 @@
   struct in_addr addr0;
   struct in_addr addr1;
   char secret[RADIUS_SECRETSIZE];
-  size_t secretlen;
   uint16_t authport;
   uint16_t acctport;
+  size_t secretlen;
 };
 
 struct radius_t {
@@ -224,6 +224,8 @@
 
   struct in_addr hisaddr0;       /* Server address */
   struct in_addr hisaddr1;       /* Server address */
+  /* Padding to separate secret from preceding field */
+  char padding1[2];
   char secret[RADIUS_SECRETSIZE];/* Shared secret */
   size_t secretlen;              /* Length of sharet secret */
 
@@ -241,11 +243,15 @@
   uint16_t proxyport;            /* Proxy port to listen to */
   struct in_addr proxyaddr;      /* Proxy client address */
   struct in_addr proxymask;      /* Proxy client mask */
+  /* Padding to separate proxysecret from preceding field */
+  char padding2[2];
   char proxysecret[RADIUS_SECRETSIZE]; /* Proxy secret */
   size_t proxysecretlen;            /* Length of sharet secret */
 #endif
 
   unsigned char nas_hwaddr[6];   /* Hardware address of NAS */
+  /* Padding to separate debug from preceding field */
+  char padding3[2];
   int debug;                     /* Print debug messages */
 
   int (*cb_ind)       (struct radius_t *radius, struct radius_packet_t *pack,
diff --recursive --unified --new-file --no-dereference orig/src/radius_coovachilli.h src/src/radius_coovachilli.h
--- orig/src/radius_coovachilli.h	2016-12-15 17:28:43.000000000 +0000
+++ src/src/radius_coovachilli.h	2024-01-26 11:00:37.000000000 +0000
@@ -84,6 +84,7 @@
 #define RADIUS_ATTR_COOVACHILLI_OTHER_OUTPUT_OCTETS       85 /* integer */
 #define RADIUS_ATTR_COOVACHILLI_OTHER_INPUT_GIGAWORDS     86 /* integer */
 #define RADIUS_ATTR_COOVACHILLI_OTHER_OUTPUT_GIGAWORDS    87 /* integer */
+#define	RADIUS_ATTR_COOVACHILLI_WARNING_OCTETS            88 /* integer */
 
 #define RADIUS_VALUE_COOVACHILLI_NAS_VIEWPOINT             1
 #define RADIUS_VALUE_COOVACHILLI_CLIENT_VIEWPOINT          2
@@ -100,5 +101,6 @@
 #define RADIUS_VALUE_COOVACHILLI_SESSION_OUT_DATALIMIT_REACHED    15
 #define RADIUS_VALUE_COOVACHILLI_SESSION_TOTAL_DATALIMIT_REACHED  16
 #define RADIUS_VALUE_COOVACHILLI_SESSION_LOCATION_CHANGE          17
+#define RADIUS_VALUE_COOVACHILLI_SESSION_USER_EXPIRED	          18
 
 #endif	/* !_RADIUS_COOVACHILLI_H */
diff --recursive --unified --new-file --no-dereference orig/src/redir.c src/src/redir.c
--- orig/src/redir.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/redir.c	2024-01-26 11:00:37.000000000 +0000
@@ -22,6 +22,7 @@
 #include "chilli.h"
 #ifdef ENABLE_MODULES
 #include "chilli_module.h"
+#include "chilli_module.h"
 #endif
 #ifdef ENABLE_EWTAPI
 #include "ewt.h"
@@ -32,7 +33,7 @@
 
 static int termstate = REDIR_TERM_INIT;    /* When we were terminated */
 
-char credits[] =
+const char credits[] =
     "<H1>CoovaChilli " VERSION "</H1>"
     "<p>Copyright 2002-2005 Mondru AB</p>"
     "<p>Copyright 2006-2012 David Bird (Coova Technologies)</p>"
@@ -202,16 +203,6 @@
   bcatcstr(s, "P3P: CP=\"IDC DSP COR ADM DEVi TAIi PSA PSD IVAi IVDi CONi HIS OUR IND CNT\"\r\n");
 }
 
-static int bstrtocstr(bstring src, char *dst, unsigned int len) {
-  if (!src || src->slen == 0) {
-    dst[0] = 0;
-    return 0;
-  }
-
-  strlcpy(dst, (char*)src->data, len);
-  return 0;
-}
-
 /* Encode src as urlencoded and place null terminated result in dst */
 int redir_urlencode(bstring src, bstring dst) {
   char x[3];
@@ -412,21 +403,22 @@
 }
 
 static void bstring_buildurl(bstring str, struct redir_conn_t *conn,
-			     struct redir_t *redir, char *redir_url, char *resp,
+			     struct redir_t *redir, char *redir_url, const char *resp,
 			     long int timeleft, char* hexchal, char* uid,
 			     char* userurl, char* reply, char* redirurl,
 			     uint8_t *hismac, struct in_addr *hisip, char *amp) {
   bstring bt = bfromcstr("");
   bstring bt2 = bfromcstr("");
 
-  bassignformat(str, "%s%sres=%s%suamip=%s%suamport=%d",
-		redir_url, strchr(redir_url, '?') ? amp : "?", resp, amp,
-		inet_ntoa(redir->addr), amp,
-		redir->port);
+  bassignformat(str, "%s%sres=%s%s%s=%s%s%s=%d",
+                redir_url, strchr(redir_url, '?') ? amp : "?", resp, amp,
+                _options.paramuamip ? _options.paramuamip : "uamip", inet_ntoa(redir->addr),
+                amp, _options.paramuamport ? _options.paramuamport : "uamport", redir->port);
 
   if (!_options.nochallenge && hexchal) {
     bcatcstr(str, amp);
-    bassignformat(bt, "challenge=%s", hexchal);
+    bassignformat(bt, "%s=%s", _options.paramchallenge ? _options.paramchallenge : "challenge",
+                  hexchal);
     bconcat(str, bt);
     bassigncstr(bt,"");
   }
@@ -440,28 +432,68 @@
       sessiontime = timenow - starttime;
 
       bcatcstr(str, amp);
-      bassignformat(bt, "starttime=%ld", (long) starttime);
+      bassignformat(bt, "starttime=%" PRId64, (uint64_t) starttime);
       bconcat(str, bt);
       bcatcstr(str, amp);
-      bassignformat(bt, "sessiontime=%ld", (long) sessiontime);
+      bassignformat(bt, "sessiontime=%" PRId64, (uint64_t) sessiontime);
       bconcat(str, bt);
     }
 
     if (conn->s_params.sessiontimeout) {
       bcatcstr(str, amp);
-      bassignformat(bt, "sessiontimeout=%ld", (long) conn->s_params.sessiontimeout);
+      bassignformat(bt, "sessiontimeout=%" PRId64, (uint64_t) conn->s_params.sessiontimeout);
       bconcat(str, bt);
     }
 
     if (conn->s_params.sessionterminatetime) {
       bcatcstr(str, amp);
-      bassignformat(bt, "stoptime=%ld", (long) conn->s_params.sessionterminatetime);
+      bassignformat(bt, "stoptime=%" PRId64, (uint64_t) conn->s_params.sessionterminatetime);
+      bconcat(str, bt);
+    }
+  }
+
+  if (conn->type == REDIR_TRIAL || conn->type == REDIR_LOGIN || conn->type == REDIR_STATUS){
+    if (conn->s_params.maxinputoctets) {
+      bcatcstr(str, amp);
+      bassignformat(bt, "maxinputoctets=%lld", conn->s_params.maxinputoctets);
+      bconcat(str, bt);
+    }
+
+    if (conn->s_params.maxoutputoctets) {
+      bcatcstr(str, amp);
+      bassignformat(bt, "maxoutputoctets=%lld", conn->s_params.maxoutputoctets);
+      bconcat(str, bt);
+    }
+
+    if (conn->s_params.warningoctets) {
+      bcatcstr(str, amp);
+      bassignformat(bt, "warningoctets=%lld", conn->s_params.warningoctets);
+      bconcat(str, bt);
+    }
+
+    if (conn->s_params.bandwidthmaxup) {
+      bcatcstr(str, amp);
+      bassignformat(bt, "bandwidthmaxup=%lld", conn->s_params.bandwidthmaxup);
+      bconcat(str, bt);
+    }
+
+    if (conn->s_params.bandwidthmaxdown) {
+	  bcatcstr(str, amp);
+	  bassignformat(bt, "bandwidthmaxdown=%lld", conn->s_params.bandwidthmaxdown);
+	  bconcat(str, bt);
+	}
+
+    if (conn->s_params.expiration &&
+        conn->s_state.redir.auth_mode != AUTH_TRIAL_USER) {
+      bcatcstr(str, amp);
+      bassignformat(bt, "expiration=%lld", conn->s_params.expiration);
       bconcat(str, bt);
     }
   }
 
   bcatcstr(str, amp);
-  bcatcstr(str, "called=");
+  bcatcstr(str, _options.paramcalled ? _options.paramcalled : "called");
+  bcatcstr(str, "=");
   if (_options.nasmac)
     bassigncstr(bt, _options.nasmac);
   else
@@ -488,7 +520,8 @@
 
   if (hismac) {
     bcatcstr(str, amp);
-    bcatcstr(str, "mac=");
+    bcatcstr(str, _options.parammac ? _options.parammac : "mac");
+    bcatcstr(str, "=");
     bassignformat(bt, "%.2X-%.2X-%.2X-%.2X-%.2X-%.2X",
 		  hismac[0], hismac[1],
 		  hismac[2], hismac[3],
@@ -499,7 +532,7 @@
 
   if (hisip) {
     bcatcstr(str, amp);
-    bassignformat(bt, "ip=%s", inet_ntoa(*hisip));
+    bassignformat(bt, "%s=%s", _options.paramip ? _options.paramip : "ip", inet_ntoa(*hisip));
     bconcat(str, bt);
   }
 
@@ -521,12 +554,38 @@
 
   if (_options.radiusnasid) {
     bcatcstr(str, amp);
-    bcatcstr(str, "nasid=");
+    bcatcstr(str, _options.paramnasid ? _options.paramnasid : "nasid");
+    bcatcstr(str, "=");
     bassigncstr(bt, _options.radiusnasid);
     redir_urlencode(bt, bt2);
     bconcat(str, bt2);
   }
 
+	if (_options.tos) {
+		bcatcstr(str, amp);
+		bcatcstr(str, "tos=1");
+	}
+
+    if (_options.macpass) {
+      bcatcstr(str, amp);
+      bcatcstr(str, "macpass=1");
+    }
+    
+    if (_options.registerusers) {
+        bcatcstr(str, amp);
+        bcatcstr(str, "signup=1"); 
+    }
+
+  if (_options.trialusers) {
+    bcatcstr(str, amp);
+    bcatcstr(str, "trial=1");
+  }
+
+    if (conn->s_state.terminate_cause_ui){
+		bcatcstr(str, amp);
+		bassignformat(bt, "termcause=%d", (long) conn->s_state.terminate_cause_ui);
+		bconcat(str, bt);
+  	}
 #ifdef ENABLE_IEEE8021Q
   if (_options.ieee8021q && conn->s_state.tag8021q) {
     bcatcstr(str, amp);
@@ -580,8 +639,8 @@
   }
 
   if (conn->s_state.sessionid[0]) {
-    bcatcstr(str, amp);
-    bcatcstr(str, "sessionid=");
+    bassignformat(bt, "%s%s=", amp, _options.paramsessionid ? _options.paramsessionid : "sessionid");
+    bconcat(str, bt);
     bassigncstr(bt, conn->s_state.sessionid);
     redir_urlencode(bt, bt2);
     bconcat(str, bt2);
@@ -620,13 +679,23 @@
   }
 
   if (userurl) {
-    bcatcstr(str, amp);
-    bcatcstr(str, "userurl=");
+    bassignformat(bt, "%s%s=", amp, _options.paramuserurl ? _options.paramuserurl : "userurl");
+    bconcat(str, bt);
     bassigncstr(bt, userurl);
     redir_urlencode(bt, bt2);
     bconcat(str, bt2);
   }
 
+  if (_options.param1 && _options.param1value){
+    bassignformat(bt, "%s%s=%s", amp, _options.param1, _options.param1value);
+    bconcat(str, bt);
+  }
+
+  if (_options.param2 && _options.param2value){
+    bassignformat(bt, "%s%s=%s", amp, _options.param2, _options.param2value);
+    bconcat(str, bt);
+  }
+
   if (redir->secret && *redir->secret) {
     /* take the md5 of the url+uamsecret as a checksum */
     redir_md_param(str, redir->secret, amp);
@@ -680,8 +749,8 @@
 
         bcatcstr(b, "<State>1</State>\r\n");
 
-        bassignformat(bt, "<StartTime>%d</StartTime>\r\n" ,
-                      conn->s_state.start_time);
+        bassignformat(bt, "<StartTime>%"PRId64"</StartTime>\r\n" ,
+                      (uint64_t)conn->s_state.start_time);
         bconcat(b, bt);
 
         bassignformat(bt, "<SessionTime>%d</SessionTime>\r\n",
@@ -717,6 +786,10 @@
         bassignformat(bt, "<MaxTotalOctets>%d</MaxTotalOctets>\r\n",
                       conn->s_params.maxtotaloctets);
         bconcat(b, bt);
+
+        bassignformat(bt, "<WarningOctets>%d</WarningOctets>\r\n",
+                      conn->s_params.warningoctets);
+        bconcat(b, bt);
       }
       else {
         bcatcstr(b, "<State>0</State>\r\n");
@@ -733,7 +806,10 @@
     case REDIR_FAILED_MTU:
     case REDIR_FAILED_TIMEOUT:
     case REDIR_FAILED_REJECT:
+    case REDIR_FAILED_DATA:
+    case REDIR_FAILED_TIME:
     case REDIR_FAILED_OTHER:
+    case REDIR_FAILED_TOS:
       if (reply) {
         bassignformat(bt, "<ReplyMessage>%s</ReplyMessage>\r\n", reply);
         bconcat(b, bt);
@@ -760,7 +836,12 @@
 
     case REDIR_REQERROR:
       break;
-
+    case REDIR_SMSSIGNUP_SUCCESS:
+    case REDIR_SMSSIGNUP_FAILED:
+    case REDIR_SMSSIGNUP_ALREADY:
+    case REDIR_SMSSIGNUP_SMS_FAIL:
+    case REDIR_SIGNUP_SUCCESS:
+    	break;
     default:
       syslog(LOG_ERR, "redir_wispr1_reply: Unhandled response code in switch: %d", res);
   }
@@ -779,9 +860,6 @@
 			 char* reply, char* redirurl, bstring b) {
   bstring bt = bfromcstr("");;
 
-  if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d):", __FUNCTION__, __LINE__);
-
   bcatcstr(b,
 	   "<!--\r\n"
 	   "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n"
@@ -816,10 +894,12 @@
         bconcat(b, bt);
       }
 
-      bassignformat(bt, "<LoginURL>%s%sres=wispr&amp;uamip=%s&amp;uamport=%d&amp;challenge=%s</LoginURL>\r\n",
+      bassignformat(bt, "<LoginURL>%s%sres=wispr&amp;&s=%s&amp;%s=%d&amp;%s=%s</LoginURL>\r\n",
                     _options.wisprlogin ? _options.wisprlogin : redir->url,
                     strchr(_options.wisprlogin ? _options.wisprlogin : redir->url, '?') ? "&amp;" : "?",
-                    inet_ntoa(redir->addr), redir->port, hexchal);
+                    _options.paramuamip ? _options.paramuamip : "uamip", inet_ntoa(redir->addr),
+                    _options.paramuamport ? _options.paramuamport : "uamport", redir->port,
+                    _options.paramchallenge ? _options.paramchallenge : "challenge", hexchal);
       bconcat(b, bt);
 
       bassignformat(bt, "<AbortLoginURL>http://%s:%d/abort</AbortLoginURL>\r\n",
@@ -860,7 +940,10 @@
     case REDIR_ERROR_PROTOCOL:
     case REDIR_FAILED_MTU:
     case REDIR_FAILED_TIMEOUT:
+    case REDIR_FAILED_DATA:
+    case REDIR_FAILED_TIME:
     case REDIR_FAILED_OTHER:
+    case REDIR_FAILED_TOS:
       bcatcstr(b,
                "<AuthenticationPollReply>\r\n"
                "<MessageType>140</MessageType>\r\n" /* response to authentication notification */
@@ -953,6 +1036,26 @@
     case REDIR_REQERROR:
       break;
 
+    case REDIR_SMSSIGNUP_SUCCESS:
+    case REDIR_SMSSIGNUP_FAILED:
+    case REDIR_SMSSIGNUP_ALREADY:
+    case REDIR_SMSSIGNUP_SMS_FAIL:
+    case REDIR_SIGNUP_SUCCESS:
+    	break;
+    case REDIR_FAILED_USER_DUPLICATE:
+      bcatcstr(b,
+                "<AuthenticationPollReply>\r\n"
+                "<MessageType>170</MessageType>\r\n"  /* response to notification */
+                "<ResponseCode>110</ResponseCode>\r\n");  /* login failed (Users duplicate) */
+
+      if (reply) {
+        bassignformat(bt, "<ReplyMessage>%s</ReplyMessage>\r\n", reply);
+        bconcat(b, bt);
+      } else {
+        bcatcstr(b, "<ReplyMessage>A user with the entered password already exists!</ReplyMessage>\r\n");
+      }
+      bcatcstr(b, "</AuthenticationPollReply>\r\n");
+      break;
     default:
       syslog(LOG_ERR, "redir_wispr1_reply: Unhandled response code in switch: %d", res);
   }
@@ -990,9 +1093,6 @@
   bstring bt = bfromcstr("");
   char eap64str [MAX_EAP_LEN*2];
 
-  if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d):", __FUNCTION__, __LINE__);
-
   bcatcstr(b,
 	   "<!--\r\n"
 	   "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n"
@@ -1037,10 +1137,12 @@
         bconcat(b, bt);
       }
 
-      bassignformat(bt, "<LoginURL>%s%sres=wispr&amp;uamip=%s&amp;uamport=%d&amp;challenge=%s</LoginURL>\r\n",
+      bassignformat(bt, "<LoginURL>%s%sres=wispr&amp;u%s=%s&amp;%s=%d&amp;%s=%s</LoginURL>\r\n",
                     _options.wisprlogin ? _options.wisprlogin : redir->url,
                     strchr(_options.wisprlogin ? _options.wisprlogin : redir->url, '?') ? "&amp;" : "?",
-                    inet_ntoa(redir->addr), redir->port, hexchal);
+                    _options.paramuamip ? _options.paramuamip : "uamip", inet_ntoa(redir->addr),
+                    _options.paramuamport ? _options.paramuamport : "uamport", redir->port,
+                    _options.paramchallenge ? _options.paramchallenge : "challenge", hexchal);
       bconcat(b, bt);
 
       bassignformat(bt, "<AbortLoginURL>http://%s:%d/abort</AbortLoginURL>\r\n",
@@ -1134,7 +1236,10 @@
       write_authentication_msg_footer(conn,b);
       break;
 
+    case REDIR_FAILED_DATA:
+    case REDIR_FAILED_TIME:
     case REDIR_FAILED_OTHER:
+    case REDIR_FAILED_TOS:
       write_authentication_msg_header(conn,b);
 
       bcatcstr(b,
@@ -1166,10 +1271,12 @@
           syslog(LOG_DEBUG, "%s(%d): Base64 encoding of radius eap message failed", __FUNCTION__, __LINE__);
       }
 
-      bassignformat(bt, "<LoginURL>%s%sres=wispr&amp;uamip=%s&amp;continue=1&amp;uamport=%d&amp;challenge=%s</LoginURL>\r\n",
+      bassignformat(bt, "<LoginURL>%s%sres=wispr&amp;%s=%s&amp;continue=1&amp;%s=%d&amp;%s=%s</LoginURL>\r\n",
                     _options.wisprlogin ? _options.wisprlogin : redir->url,
                     strchr(_options.wisprlogin ? _options.wisprlogin : redir->url, '?') ? "&amp;" : "?",
-                    inet_ntoa(redir->addr), redir->port, hexchal);
+                    _options.paramuamip ? _options.paramuamip : "uamip", inet_ntoa(redir->addr),
+                    _options.paramuamport ? _options.paramuamport : "uamport", redir->port,
+                    _options.paramchallenge ? _options.paramchallenge : "challenge", hexchal);
       bconcat(b, bt);
 
       bcatcstr(b, "</EAPAuthenticationReply>\r\n");
@@ -1259,6 +1366,22 @@
     case REDIR_REQERROR:
       break;
 
+    case REDIR_SMSSIGNUP_SUCCESS:
+    case REDIR_SMSSIGNUP_FAILED:
+    case REDIR_SMSSIGNUP_ALREADY:
+    case REDIR_SMSSIGNUP_SMS_FAIL:
+    case REDIR_SIGNUP_SUCCESS:
+    	break;
+    case REDIR_FAILED_USER_DUPLICATE:
+      write_authentication_msg_header(conn,b);
+      bcatcstr(b, "<ResponseCode>110</ResponseCode>\r\n");  /* login failed (Users duplicate) */
+      if (reply) {
+        bassignformat(bt, "<ReplyMessage>%s</ReplyMessage>\r\n", reply);
+        bconcat(b, bt);
+      } else {
+        bcatcstr(b, "<ReplyMessage>A user with the entered password already exists!</ReplyMessage>\r\n");
+      }
+      write_authentication_msg_footer(conn, b);
     default:
       syslog(LOG_ERR, "redir_wispr1_reply: Unhandled response code in switch: %d", res);
   }
@@ -1300,6 +1423,8 @@
       break;
 
     case REDIR_FAILED_REJECT:
+    case REDIR_FAILED_DATA:
+    case REDIR_FAILED_TIME:
     case REDIR_FAILED_OTHER:
       flg |= FLG_chlg;
       flg |= FLG_redir;
@@ -1423,7 +1548,7 @@
 #endif
 
 static void redir_buildurl(struct redir_conn_t *conn, bstring str,
-			   struct redir_t *redir, char *resp,
+			   struct redir_t *redir, const char *resp,
 			   long int timeleft, char* hexchal, char* uid,
 			   char* userurl, char* reply, char* redirurl,
 			   uint8_t *hismac, struct in_addr *hisip) {
@@ -1500,7 +1625,7 @@
 		char* userurl, char* reply, char* redirurl,
 		uint8_t *hismac, struct in_addr *hisip, char *qs) {
 
-  char *resp = NULL;
+  const char *resp = NULL;
   bstring buffer;
 
   switch (res) {
@@ -1508,7 +1633,7 @@
       resp = "already";
       break;
     case REDIR_FAILED_REJECT:
-      resp = "failed&reason=reject";
+        resp = "failed&reason=reject";
       break;
     case REDIR_FAILED_TIMEOUT:
       resp = "failed&reason=timeout";
@@ -1516,10 +1641,19 @@
     case REDIR_FAILED_MTU:
       resp = "failed&reason=mtu";
       break;
+    case REDIR_FAILED_DATA:
+      resp = "failed&reason=data_limit";
+      break;
+    case REDIR_FAILED_TIME:
+      resp = "failed&reason=time_limit";
+        break;
     case REDIR_FAILED_OTHER:
     case REDIR_ERROR_PROTOCOL:
       resp = "failed&reason=other";
       break;
+    case REDIR_FAILED_TOS:
+      resp = "failed&reason=tos";
+      break;
     case REDIR_REQERROR:
       resp = "failed";
       break;
@@ -1530,7 +1664,7 @@
       resp = "logoff";
       break;
     case REDIR_NOTYET:
-      resp = "notyet";
+      resp = (_options.smsusers && conn->s_state.redir.otp_state == 1) ? "notyet&otpstate=active" : "notyet";
       break;
     case REDIR_SPLASH:
       resp = "splash";
@@ -1550,6 +1684,48 @@
     case REDIR_CHALLENGE:
       resp = "challenge";
       break;
+    case REDIR_SMSSIGNUP_FAILED:
+      resp = "smssignup_fail&reason=err";
+      break;
+  	case REDIR_SMSSIGNUP_ALREADY:
+      resp = "smssignup_fail&reason=already";
+      break;
+    case REDIR_SMSSIGNUP_SMS_FAIL:
+      resp = "smssignup_fail&reason=sms";
+      break;
+  	case REDIR_SMSSIGNUP_DENIED:
+      resp = "smssignup_fail&reason=denied";
+      break;
+    case REDIR_SMSSIGNUP_SUCCESS:
+      resp = "smssuccess";
+      break;
+  	case REDIR_SIGNUP_SUCCESS:
+      resp = "signup_success";
+      break;
+  	case REDIR_SIGNUP_FAILED:
+      resp = "signup_fail&reason=err";
+      break;
+  	case REDIR_SIGNUP_ALREADY:
+      resp = "signup_fail&reason=already";
+      break;
+    case REDIR_SIGNUP_DENIED:
+      resp = "signup_fail&reason=denied";
+      break;
+    case REDIR_TRIALLOGIN_DENIED:
+      resp = "failed&reason=trial_denied";
+      break;
+    case REDIR_TRIALLOGIN_FAILED:
+      resp = "failed&reason=trial_fail";
+      break;
+    case REDIR_TRIAL_FAILED_DATA:
+      resp = "failed&reason=data_limit_trial";
+          break;
+    case REDIR_TRIAL_FAILED_TIME:
+      resp = "failed&reason=time_limit_trial";
+          break;
+    case REDIR_FAILED_USER_DUPLICATE:
+      resp = "failed&reason=user_duplicate";
+      break;
     default:
       syslog(LOG_ERR, "Unknown res in switch");
       return -1;
@@ -1577,12 +1753,10 @@
       bcatcstr(buffer, "Location: ");
 
       if (url) {
-
-        bconcat(buffer, url);
-
-      } else if (!_options.redirurl && redirurl && *redirurl) {
-	bcatcstr(buffer, redirurl);
-      } else {
+          bconcat(buffer, url);
+      }else if (!_options.redirurl && redirurl && *redirurl)
+	    bcatcstr(buffer, redirurl);
+      else {
         bt = bfromcstralloc(1024,"");
         redir_buildurl(conn, bt, redir, resp, timeleft, hexchal,
                        uid, userurl, reply, redirurl, hismac, hisip);
@@ -2171,6 +2345,12 @@
 	  conn->type = REDIR_LOGIN;
 	else if ((!strcmp(path, "logoff")) || (!strcmp(path, "logout")))
 	  conn->type = REDIR_LOGOUT;
+	else if (!strcmp(path, "trial"))
+	  conn->type = REDIR_TRIAL;
+    else if ((!strcmp(path, "signup")) || (!strcmp(path, "register")))
+      conn->type = REDIR_SIGNUP;
+    else if ((!strcmp(path, "smssignup")) || (!strcmp(path, "smsregister")))
+      conn->type = REDIR_SMSSIGNUP;
 	else if (!strncmp(path, "www/", 4) && strlen(path) > 4)
 	  conn->type = REDIR_WWW;
 	else if (!strcmp(path, "status"))
@@ -2234,7 +2414,16 @@
 	  p = buffer + 15;
 	  while (*p && isspace((int) *p)) p++;
 	  len = strlen(p);
-	  if (len > 0) httpreq->clen = atoi(p);
+	  if (len > 0) {
+		  char *endptr;
+		  long int clen = strtol(p, &endptr, 10);
+      if(p != endptr && *endptr != '\0')
+      {
+	      httpreq->clen = clen;
+      } else {
+        syslog(LOG_DEBUG, "%s(%d): Bad Content-Length: %s", __FUNCTION__, __LINE__, p);
+      }
+	  }
 #if(_debug_ > 1)
           if (_options.debug)
             syslog(LOG_DEBUG, "%s(%d): Content-Length: %s", __FUNCTION__, __LINE__, p);
@@ -2280,7 +2469,7 @@
       for (i = 0; i < (int)(buflen - linelen); i++)
 	buffer[i] = buffer[(int)linelen + i];
 
-      /*syslog(LOG_DEBUG, "linelen=%d buflen=%d", linelen, buflen);*/
+
       buflen -= linelen;
     }
 
@@ -2317,6 +2506,18 @@
         if (!redir_getparam(redir, httpreq->qs, "lang", bt))
           bstrtocstr(bt, conn->lang, sizeof(conn->lang));
 
+	  	if (_options.tos){
+		  if (redir_getparam(redir, httpreq->qs, "agreetos", bt)){
+		      if (_options.debug)
+			    syslog(LOG_ERR, "No agreetos found in login request");
+
+			  conn->response = REDIR_FAILED_TOS;
+			  bdestroy(bt);
+			  return 0;
+		  }
+		  conn->s_state.redir.tos = 1;
+	  	}
+
         if (redir_getparam(redir, httpreq->qs, "username", bt)) {
           syslog(LOG_ERR, "No username found in login request");
           conn->response = REDIR_ERROR_PROTOCOL;
@@ -2324,8 +2525,7 @@
           return -1;
         }
 
-        bstrtocstr(bt, conn->s_state.redir.username,
-                   sizeof(conn->s_state.redir.username));
+        besc_strtocstr(bt, conn->s_state.redir.username, sizeof(conn->s_state.redir.username));
 
         if (_options.debug)
           syslog(LOG_DEBUG, "%s(%d): -->> Setting username=[%s]", __FUNCTION__, __LINE__, conn->s_state.redir.username);
@@ -2376,11 +2576,16 @@
                           conn->authdata.v.chapmsg.password,
                           RADIUS_CHAPSIZE);
 
-          if (!redir_getparam(redir, httpreq->qs, "ident", bt) && bt->slen)
-            conn->authdata.v.chapmsg.identity = atoi((char*)bt->data);
-          else
+          if (!redir_getparam(redir, httpreq->qs, "ident", bt) && bt->slen) {
+            char *endptr;
+            unsigned long value = strtoul((char *)bt->data, &endptr, 10);
+            if(*endptr == '\0' && value <= UINT8_MAX) {
+              conn->authdata.v.chapmsg.identity = (uint8_t)value;
+            }
+          } else {
             conn->authdata.v.chapmsg.identity = 0;
-        }
+          }
+	}
         else if (!redir_getparam(redir, httpreq->qs, "password", bt)) {
           conn->authdata.type = REDIR_AUTH_PAP;
           if (_options.nochallenge) {
@@ -2471,7 +2676,102 @@
         bdestroy(bt);
       }
       break;
+    case REDIR_SIGNUP:
+      {
+      	if (!_options.registerusers){
+      	  if (_options.debug)
+			syslog(LOG_ERR, "Signup method is not allowed");
+
+          conn->response = REDIR_SIGNUP_DENIED;
+          return 0;
+      	}
+
+        bstring bt = bfromcstr("");
+        if (redir_getparam(redir, httpreq->qs, "email", bt)) {
+          if (_options.debug)
+            syslog(LOG_ERR, "No email found in signup request");
+
+          conn->response = REDIR_SIGNUP_FAILED;
+          bdestroy(bt);
+          return -1;
+        }
+
+        besc_strtocstr(bt, conn->s_state.redir.email,
+                       sizeof(conn->s_state.redir.email));
+        if (redir_getparam(redir, httpreq->qs, "phone", bt)) {
+          if (_options.debug)
+            syslog(LOG_ERR, "No phone found in signup request");
+
+          conn->response = REDIR_SIGNUP_FAILED;
+          bdestroy(bt);
+          return -1;
+        }
+
+	  	besc_strtocstr(bt, conn->s_state.redir.phone,
+                       sizeof(conn->s_state.redir.phone));
+        if (redir_getparam(redir, httpreq->qs, "password", bt)) {
+          if (_options.debug)
+            syslog(LOG_ERR, "No password found in signup request");
+
+          conn->response = REDIR_SIGNUP_FAILED;
+          bdestroy(bt);
+          return -1;
+        }
+
+	  	besc_strtocstr(bt, conn->s_state.redir.signup_password,
+                       sizeof(conn->s_state.redir.signup_password));
+        bdestroy(bt);
+      }
+      break;
+    case REDIR_SMSSIGNUP:
+    {
+		if (!_options.smsusers){
+			syslog(LOG_ERR, "SMSsignup method not allowed");
+			conn->response = REDIR_SMSSIGNUP_DENIED;
+			return 0;
+		}
+
+		bstring bt = bfromcstr("");
+		if (redir_getparam(redir, httpreq->qs, "phone", bt)){
+		syslog(LOG_ERR, "No phone found in smssignup request");
+		conn->response = REDIR_SMSSIGNUP_FAILED;
+		bdestroy(bt);
+		return -1;
+		}
+
+		besc_strtocstr(bt, conn->s_state.redir.phone,
+					 sizeof(conn->s_state.redir.phone));
+		bdestroy(bt);
+    }
+    break;
+    case REDIR_TRIAL:
+    {
+		if (!_options.trialusers){
+			syslog(LOG_ERR, "Trial login is not allowed");
+			conn->response = REDIR_TRIALLOGIN_DENIED;
+			return 0;
+		}
+
+      bstring bt = bfromcstr("");
+
+      //if (!redir_getparam(redir, httpreq->qs, "lang", bt))
+        //bstrtocstr(bt, conn->lang, sizeof(conn->lang));
+
+      if (_options.tos){
+        if (redir_getparam(redir, httpreq->qs, "agreetos", bt)){
+          if (_options.debug)
+            syslog(LOG_ERR, "No agreetos found in login request");
+
+          conn->response = REDIR_FAILED_TOS;
+          bdestroy(bt);
+          return 0;
+        }
+        conn->s_state.redir.tos = 1;
+      }
 
+      bdestroy(bt);
+    }
+    break;
     case REDIR_WWW:
       {
         bstring bt = bfromcstr(path+4);
@@ -2961,32 +3261,229 @@
   return 0;
 }
 
-int is_local_user(struct redir_t *redir, struct redir_conn_t *conn) {
-  uint8_t user_password[RADIUS_PWSIZE+1];
-  uint8_t chap_challenge[REDIR_MD5LEN];
+void session_param_local(struct session_params *params, char *line) {
+  uint64_t timeout = 0, dw = 0, up = 0, dw_bandwidth = 0, up_bandwidth =0;
+  uint32_t idle = 0;
+  int period = 0, start = 0;
+//"$timeout:$idle:$dw_max:$up_max:$dw_bwidth:$upl_bwidth:$period:$start"
+  sscanf(line, "%lld:%d:%lld:%lld:%lld:%lld:%d:%d",
+         &timeout, &idle, &dw, &up, &dw_bandwidth, &up_bandwidth, &period, &start);
+  if (_options.debug)
+    syslog(LOG_INFO, "line %s, timeout - %llu, idel - %d, dw - %llu, up - %llu, bdw - %llu, bup - %llu, period - %d, start - %d",
+          line, timeout, idle, dw, up, dw_bandwidth, up_bandwidth, period, start);
+
+  params->sessiontimeout = timeout ? timeout : 0;
+  params->idletimeout = idle ? idle : 0;
+  params->maxinputoctets = dw ? dw : 0;
+  params->maxoutputoctets = up ? up : 0;
+  params->bandwidthmaxdown = dw_bandwidth ? dw_bandwidth : 0;
+  params->bandwidthmaxup = up_bandwidth ? up_bandwidth : 0;
+  params->period = period ? period : 3;
+  params->start = start ? start : 1;
+}
+
+int auth_chap(struct redir_conn_t *conn, MD5_CTX *context, uint8_t *chap_challenge,
+		uint8_t *user_password, char *password)
+{
+    uint8_t tmp[REDIR_MD5LEN];
+    MD5Init(context);
+    MD5Update(context, (uint8_t*)&conn->authdata.v.chapmsg.identity, 1);
+    MD5Update(context, (uint8_t*)password, strlen(password));
+    MD5Update(context, chap_challenge, REDIR_MD5LEN);
+    MD5Final(tmp, context);
+
+    if (!memcmp(user_password, tmp,  REDIR_MD5LEN)) {
+		return ACCESS_ACCEPTED;
+	}
+    else {
+      if (_options.debug)
+		syslog(LOG_INFO, "%s(%d): bad password", __FUNCTION__, __LINE__);
+	}
+
+	return ACCESS_DENIED;
+}
+
+void mac_block_invoke(const char *command, struct redir_conn_t *conn)
+{
+  uint32_t tmp_id = 0;
+  struct blob_buf b = { 0 };
+  char mac[MACSTRLEN+1];
+
+  snprintf(mac, sizeof(mac), MAC_FMT, MAC_ARG(conn->hismac));
+  ubus_ctx = ubus_connect(NULL);
+  if (!ubus_ctx) {
+    syslog(LOG_WARNING, "Warning: Failed to connect to ubus.");
+    return;
+  }
+
+  int ret = ubus_lookup_id(ubus_ctx, "ip_block", &tmp_id);
+  if (ret) {
+    syslog(LOG_WARNING, "Warning: Failed to find 'ip_block' object.");
+    goto end;
+  }
+
+  blob_buf_init(&b, 0);
+  blobmsg_add_string(&b, "mac", mac);
+  void *r = blobmsg_open_array(&b, "interface");
+  if(_options.dhcpif)
+    blobmsg_add_string(&b, NULL, _options.dhcpif);
+  for (int i = 0; i < MAX_MOREIF; i++) {
+    if(!_options.moreif[i].dhcpif)
+	    continue;
+    blobmsg_add_string(&b, NULL, _options.moreif[i].dhcpif);
+	}
+  blobmsg_close_array(&b, r);
+
+  ubus_invoke(ubus_ctx, tmp_id, command, b.head, NULL, NULL, 1000);
+  blob_buf_free(&b);
+
+end:
+  ubus_free(ubus_ctx);
+}
+
+int authenticator(struct redir_t *redir, struct redir_conn_t *conn, MD5_CTX *context,
+			  uint8_t *user_password, uint8_t *chap_challenge)
+{
+  FILE *f;
+  int match = ACCESS_DENIED;
+  char *line = 0;
   char u[256]; char p[256];
-  size_t usernamelen, sz=1024;
   ssize_t len;
-  int match=0;
-  char *line=0;
-  MD5_CTX context;
-  FILE *f;
-
-  if (!_options.localusers) return 0;
+  size_t usernamelen, sz=1024;
 
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): checking %s for user %s", __FUNCTION__, __LINE__, _options.localusers, conn->s_state.redir.username);
+    syslog(LOG_INFO, "%s(%d): checking %s for user %s", __FUNCTION__, __LINE__,
+      _options.localusers, conn->s_state.redir.username);
 
   if (!(f = fopen(_options.localusers, "r"))) {
-    syslog(LOG_ERR, "%s: fopen() failed opening %s!", strerror(errno), _options.localusers);
-    return 0;
+    syslog(LOG_INFO, "%s: fopen() failed opening %s!", strerror(errno), _options.localusers);
+    return ACCESS_DENIED;
+  }
+
+  if (_options.debug)
+    syslog(LOG_INFO, "%s(%d): looking for %s", __FUNCTION__, __LINE__, conn->s_state.redir.username);
+  usernamelen = strlen(conn->s_state.redir.username);
+
+  line=(char*)malloc(sz);
+  while ((len = getline(&line, &sz, f)) > 0) {
+    if (len > 3 && len < sizeof(u) && line[0] != '#') {
+      char *pl=line,  /* pointer to current line */
+        *pu=u,     /* pointer to username     */
+        *pp=p;     /* pointer to password     */
+
+      /* username until the first ':' */
+      while (*pl && *pl != ':')	*pu++ = *pl++;
+
+      /* skip over ':' otherwise error */
+      if (*pl == ':') pl++;
+      else {
+        syslog(LOG_INFO, "not a valid localusers line: %s", line);
+        continue;
+      }
+
+      /* password until the next ':' */
+      while (*pl && *pl != ':' && *pl != '\n') *pp++ = *pl++;
+
+      *pu = 0; /* null terminate */
+      *pp = 0;
+
+      if (usernamelen == strlen(u) &&
+          !strncmp(conn->s_state.redir.username, u, usernamelen)) {
+
+        if (_options.debug)
+          syslog(LOG_INFO, "%s(%d): found %s, checking password", __FUNCTION__, __LINE__, u);
+
+        if (conn->authdata.type == REDIR_AUTH_PAP) {
+#ifdef HAVE_OPENSSL
+          char *salt = extract_salt(p);
+          char *plain_password = strndup((char *)user_password, strlen(p));
+          if (salt) {
+            user_password = (uint8_t *)hash_sha512_with_salt(plain_password, salt);
+
+            if (!user_password) {
+              syslog(LOG_INFO,
+                "%s(%d): failed to compute password hash for user %s",
+                __FUNCTION__, __LINE__, u);
+              // When hashing fails, make sure password check fails too
+              user_password = (uint8_t *)strdup("");
+            }
+
+            // Check for hash match, if hashes do not match, try again with MD5 hash
+            if (strncmp((char *)user_password, p, strlen(p))) {
+              user_password = (uint8_t *)hash_md5_with_salt(plain_password, salt);
+              if (!user_password) {
+                syslog(LOG_INFO,
+                  "%s(%d): failed to compute password hash for user %s",
+                  __FUNCTION__, __LINE__, u);
+                // When hashing fails, make sure password check fails too
+                user_password = (uint8_t *)strdup("");
+              }
+            }
+          }
+#endif
+                // Check for password math from UCI config
+          if (!strncmp((char *)user_password, p, strlen(p))) {
+#ifdef HAVE_OPENSSL
+            if (get_hash_type(p) == HASH_MD5) {
+              // If stored password is MD5 hash, rehash it to SHA-512 using the plain password
+              uint8_t *user_password_rehashed = (uint8_t *)hash_sha512(plain_password);
+              usr_update_user_pwd_uci(u, p, (char *)user_password_rehashed);
+              free(user_password_rehashed);
+            }
+#endif
+            match = ACCESS_ACCEPTED;
+          }
+
+#ifdef HAVE_OPENSSL
+          // If salt is not NULL that means that user_password was changed to point to newly allocated memory and we need to free it.
+          if (salt) {
+            free(user_password);
+            free(salt);
+          }
+          free(plain_password);
+#endif
+        }
+        else if (conn->authdata.type == REDIR_AUTH_CHAP) {
+          match = auth_chap(conn, context, chap_challenge, user_password, p);
+        }
+
+				if (match == ACCESS_ACCEPTED) {
+          mac_block_invoke("unblock_mac", conn);
+				  conn->s_state.redir.auth_mode = AUTH_LOCAL_USER;
+                  if (*pl == ':') pl++; //Skip ':'
+                    session_param_local(&conn->s_params, pl);
+                }
+
+        break;
+      }
+    }
   }
 
+  if (_options.debug)
+    syslog(LOG_DEBUG, "%s(%d): user %s %s", __FUNCTION__, __LINE__,
+      conn->s_state.redir.username,
+      match ? "found" : "not found");
+
+  fclose(f);
+  free(line);
+
+  return match;
+}
+
+int is_local_user(struct redir_t *redir, struct redir_conn_t *conn,
+				  int (*cb_validator) (struct redir_t *, struct redir_conn_t *,
+				  		MD5_CTX *, uint8_t *, uint8_t *))
+{
+  uint8_t user_password[RADIUS_PWSIZE+1];
+  uint8_t chap_challenge[REDIR_MD5LEN];
+  int match=ACCESS_DENIED;
+  MD5_CTX context;
+
   if (_options.debug) {/*debug*/
     char buffer[64];
     redir_chartohex(conn->s_state.redir.uamchal, buffer, REDIR_MD5LEN);
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): challenge: %s", __FUNCTION__, __LINE__, buffer);
+      syslog(LOG_INFO, "%s(%d): challenge: %s", __FUNCTION__, __LINE__, buffer);
   }/**/
 
   if (redir->secret && *redir->secret) {
@@ -3003,7 +3500,7 @@
     char buffer[64];
     redir_chartohex(chap_challenge, buffer, REDIR_MD5LEN);
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): chap challenge: %s", __FUNCTION__, __LINE__, buffer);
+      syslog(LOG_INFO, "%s(%d): chap challenge: %s", __FUNCTION__, __LINE__, buffer);
   }/**/
 
   switch (conn->authdata.type){
@@ -3019,87 +3516,270 @@
             user_password[m] =
                 conn->authdata.v.papmsg.password[m] ^ chap_challenge[n];
       }
+      // Correctly NUL terminate password string
+      size_t len = conn->authdata.v.papmsg.len;
+      if (len >= sizeof(user_password))
+        len = sizeof(user_password) - 1;
+      user_password[len] = 0;
       break;
     case REDIR_AUTH_CHAP:
       memcpy(user_password, conn->authdata.v.chapmsg.password, REDIR_MD5LEN);
       break;
     default:
-      syslog(LOG_ERR, "Authentication method not supported for locally authenticated users: %d",
+      syslog(LOG_INFO, "Authentication method not supported for locally authenticated users: %d",
              conn->authdata.type);
-      fclose(f);
-      return 0;
+      conn->response = REDIR_FAILED_REJECT;
+      return ACCESS_DENIED;
   }
 
   user_password[RADIUS_PWSIZE] = 0;
+  if ((match = cb_validator(redir, conn, &context, user_password, chap_challenge))
+  		== ACCESS_ACCEPTED) {
+  	conn->response = REDIR_SUCCESS;
+  }
+  else if ((match = cb_validator(redir, conn, &context, user_password, chap_challenge))
+  		== ACCESS_DENIED_UDUPCLICATE) {
+  	conn->response = REDIR_FAILED_USER_DUPLICATE;
+  }
+  else{
+    mac_block_invoke("push_mac", conn);
+  	conn->response = REDIR_FAILED_REJECT;
+  }
+
+#ifdef ENABLE_DATABASE
+	if (match == ACCESS_ACCEPTED){
+		if (conn->s_params.maxinputoctets || conn->s_params.maxoutputoctets ||
+				conn->s_params.sessiontimeout) {
+		  match = dbcheck_session(conn);
+		  switch (match){
+			case ACCESS_DENIED_DATA:
+			  conn->response = REDIR_FAILED_DATA;
+			  break;
+			case ACCESS_DENIED_TIME:
+			  conn->response = REDIR_FAILED_TIME;
+			  break;
+			case ACCESS_DENIED_UDUPCLICATE:
+			  conn->response = REDIR_FAILED_USER_DUPLICATE;
+			  break;
+		  }
+		}
+	}
+#endif
 
-  if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): looking for %s", __FUNCTION__, __LINE__, conn->s_state.redir.username);
-  usernamelen = strlen(conn->s_state.redir.username);
+  return match;
+}
 
-  line=(char*)malloc(sz);
-  while ((len = getline(&line, &sz, f)) > 0) {
-    if (len > 3 && len < sizeof(u) && line[0] != '#') {
-      char *pl=line,  /* pointer to current line */
-          *pu=u,     /* pointer to username     */
-          *pp=p;     /* pointer to password     */
+int dynamic_user_authenticator(struct redir_t *redir, struct redir_conn_t *conn,
+		MD5_CTX *context, uint8_t *user_password, uint8_t *chap_challenge)
+{
+  char email_escaped[REDIR_USERNAMESIZE + 1];
+  int match = ACCESS_DENIED;
+	struct str_user user;
+  sqlite3 *db;
 
-      /* username until the first ':' */
-      while (*pl && *pl != ':')	*pu++ = *pl++;
+  if (!_options.usersdbpath)
+    return ACCESS_DENIED;
 
-      /* skip over ':' otherwise error */
-      if (*pl == ':') pl++;
-      else {
-	syslog(LOG_WARNING, "not a valid localusers line: %s", line);
-	continue;
-      }
+  if (_options.debug)
+    syslog(LOG_INFO, "%s(%d): checking %s for user %s", __FUNCTION__, __LINE__,
+      _options.usersdbpath, conn->s_state.redir.username);
 
-      /* password until the next ':' */
-      while (*pl && *pl != ':' && *pl != '\n') *pp++ = *pl++;
+  if (!(db = sqlopen(_options.usersdbpath))) {
+    syslog(LOG_INFO, "%s: sqlopen() failed opening %s!", strerror(errno), _options.usersdbpath);
+    return ACCESS_DENIED;
+  }
 
-      *pu = 0; /* null terminate */
-      *pp = 0;
+  escape_cstr(conn->s_state.redir.username, email_escaped);
+  if (_options.debug)
+    syslog(LOG_INFO, "%s(%d): looking for %s", __FUNCTION__, __LINE__, conn->s_state.redir.username);
 
-      if (usernamelen == strlen(u) &&
-	  !strncmp(conn->s_state.redir.username, u, usernamelen)) {
+  if (!usr_get_user(db, &user, email_escaped) &&
+	    !strncmp(user.email, email_escaped, USER_EMAILSIZE)) {
 
-        if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): found %s, checking password", __FUNCTION__, __LINE__, u);
+    if (conn->authdata.type == REDIR_AUTH_PAP) {
+#ifdef HAVE_OPENSSL
+    char *salt = extract_salt(user.password);
+    char *plain_password = strndup((char *)user_password, strlen(user.password));
 
-	if (conn->authdata.type == REDIR_AUTH_PAP) {
-	  if (!strcmp((char*)user_password, p))
-	    match = 1;
-	}
-	else if (conn->authdata.type == REDIR_AUTH_CHAP) {
-	  uint8_t tmp[REDIR_MD5LEN];
-	  MD5Init(&context);
-	  MD5Update(&context, (uint8_t*)&conn->authdata.v.chapmsg.identity, 1);
-	  MD5Update(&context, (uint8_t*)p, strlen(p));
-	  MD5Update(&context, chap_challenge, REDIR_MD5LEN);
-	  MD5Final(tmp, &context);
-
-	  if (!memcmp(user_password, tmp,  REDIR_MD5LEN))
-	    match = 1;
-	  else {
-            if (_options.debug)
-              syslog(LOG_DEBUG, "%s(%d): bad password for %s", __FUNCTION__, __LINE__, u);
-	  }
-	}
+    if (salt) {
+      user_password	 = (uint8_t *)hash_sha512_with_salt(plain_password, salt);
 
-	break;
+      if (!user_password) {
+        syslog(LOG_INFO, "%s(%d): failed to compute password hash for user %s",
+          __FUNCTION__, __LINE__, user.username);
+        // When hashing fails, make sure password check fails too
+        user_password = (uint8_t *)strdup("");
+      }
+
+      // Check for hash match, if hashes do not match, try again with MD5 hash
+      if (strncmp((char *)user_password, user.password, strlen(user.password))) {
+        user_password = (uint8_t *)hash_md5_with_salt(plain_password, salt);
+        if (!user_password) {
+          syslog(LOG_INFO, "%s(%d): failed to compute password hash for user %s",
+            __FUNCTION__, __LINE__, user.username);
+          // When hashing fails, make sure password check fails too
+          user_password = (uint8_t *)strdup("");
+        }
       }
+}
+#endif
+      if (!strncmp((char *)user_password, user.password, strlen(user.password))) {
+#ifdef HAVE_OPENSSL
+        // Update password hash on the database
+        if(get_hash_type(user.password) == HASH_MD5) {
+          syslog(LOG_INFO, "%s(%d): updating user MD5 hash to SHA-512",
+            __FUNCTION__, __LINE__);
+          // If stored password is MD5 hash, rehash it to SHA-512 using the plain password
+          usr_update_user_pwd(db, &user, email_escaped, plain_password);
+        }
+#endif
+        match = ACCESS_ACCEPTED;
+      }
+
+#ifdef HAVE_OPENSSL
+      // If salt is not NULL that means that user_password was changed to point to newly allocated memory and we need to free it.
+      if (salt) {
+        free(user_password);
+        free(salt);
+      }
+      free(plain_password);
+#endif
+    }
+    else if (conn->authdata.type == REDIR_AUTH_CHAP) {
+      match = auth_chap(conn, context, chap_challenge, user_password, user.password);
+    }
+
+    if (match == ACCESS_ACCEPTED) {
+      conn->s_state.redir.user_time = user.user_time;
+      conn->s_state.redir.auth_mode = AUTH_DYN_USER;
+      session_params_dyn(&conn->s_params);
+      strlcpy(conn->s_state.redir.username, user.email, USER_EMAILSIZE);
     }
   }
 
   if (_options.debug)
     syslog(LOG_DEBUG, "%s(%d): user %s %s", __FUNCTION__, __LINE__,
-           conn->s_state.redir.username,
-           match ? "found" : "not found");
+      conn->s_state.redir.username, match ? "found" : "not found");
+
+  sqlclose(db);
 
-  fclose(f);
-  free(line);
   return match;
 }
 
+int sms_user_authenticator(struct redir_t *redir, struct redir_conn_t *conn,
+						   MD5_CTX *context, uint8_t *user_password, uint8_t *chap_challenge) {
+	char user_pass_escaped[RADIUS_PWSIZE + 1];
+	int match = ACCESS_DENIED;
+	struct str_sms_user user;
+	sqlite3 *db;
+
+	if (!_options.usersdbpath)
+		return ACCESS_DENIED;
+
+	if (_options.debug)
+		syslog(LOG_INFO, "%s(%d): checking %s for user %s", __FUNCTION__, __LINE__,
+			   _options.usersdbpath, conn->s_state.redir.username);
+
+	if (!(db = sqlopen(_options.usersdbpath))) {
+		syslog(LOG_INFO, "%s: sqlopen() failed opening %s!", strerror(errno), _options.usersdbpath);
+		return ACCESS_DENIED;
+	}
+  
+	user_password[USER_RAND_PASSWORD_LEN] = 0;
+	escape_cstr((char *) user_password, user_pass_escaped);
+    if (_options.debug)
+      syslog(LOG_INFO, "%s(%d): looking for %s (%s)", __FUNCTION__, __LINE__,
+             conn->s_state.redir.username, user_pass_escaped);
+
+	if (!usr_get_sms_user(db, &user, user_pass_escaped)) {
+    if (_options.duplicateusers && find_active_user(user.username)) {
+      syslog(LOG_INFO, "%s(%d): Found duplication on username: %s", __FUNCTION__, __LINE__, user.username);
+      match = ACCESS_DENIED_UDUPCLICATE;
+    }
+    else {
+      if (_options.duplicateusers) {
+        syslog(LOG_INFO, "%s(%d): Duplication on username %s was not found", __FUNCTION__, __LINE__, user.username);
+      }
+      if (_options.debug)
+        syslog(LOG_INFO, "%s(%d): found %s ", __FUNCTION__, __LINE__, user.username);
+
+      if (conn->authdata.type == REDIR_AUTH_PAP) {
+          if (!strncmp((char *) user_password, user.password, USER_RAND_PASSWORD_LEN))
+              match = ACCESS_ACCEPTED;
+      } else if (conn->authdata.type == REDIR_AUTH_CHAP) {
+          match = auth_chap(conn, context, chap_challenge, user_password, user.password);
+      }
+
+      if (match == ACCESS_ACCEPTED) {
+        conn->s_state.redir.user_time = user.user_time;
+        conn->s_state.redir.auth_mode = AUTH_SMS_USER;
+        strncpy(conn->s_state.redir.username, user.username, USER_RAND_USERNAME_LEN);
+        strlcpy(conn->s_state.redir.phone, user.phone, sizeof(conn->s_state.redir.phone));
+        session_params_dyn(&conn->s_params);
+      }
+    }
+	}
+
+	if (_options.debug)
+		syslog(LOG_DEBUG, "%s(%d): user %s %s", __FUNCTION__, __LINE__,
+			   conn->s_state.redir.username, match ? "found" : "not found");
+
+	sqlclose(db);
+
+	return match;
+}
+
+int mac_user_authenticator(struct redir_t *redir, struct redir_conn_t *conn,
+                           MD5_CTX *context, uint8_t *user_password, uint8_t *chap_challenge) {
+  int match = ACCESS_DENIED;
+  char mac[MACSTRLEN+1];
+
+  snprintf(mac, sizeof(mac), MAC_FMT, MAC_ARG(conn->hismac));
+  strlcpy(conn->s_state.redir.username, mac, USERNAMESIZE);
+
+  if (_options.macpass) {
+    if (_options.debug)
+      syslog(LOG_INFO, "%s(%d): looking for %s (%s)", __FUNCTION__, __LINE__,
+             conn->s_state.redir.username, _options.macpass);
+
+    if (conn->authdata.type == REDIR_AUTH_PAP) {
+      if (!strcmp((char *) user_password, _options.macpass))
+        match = ACCESS_ACCEPTED;
+    } else if (conn->authdata.type == REDIR_AUTH_CHAP) {
+      match = auth_chap(conn, context, chap_challenge, user_password, _options.macpass);
+    }
+
+    if (match == ACCESS_ACCEPTED) {
+      conn->s_state.redir.auth_mode = AUTH_MAC_USER;
+      session_params_dyn(&conn->s_params);
+    }
+
+    if (_options.debug)
+      syslog(LOG_DEBUG, "%s(%d): user %s %s", __FUNCTION__, __LINE__,
+             conn->s_state.redir.username, match ? "found" : "not found");
+  }
+  else {
+    conn->s_state.redir.auth_mode = AUTH_MAC_USER;
+    session_params_dyn(&conn->s_params);
+    match = ACCESS_ACCEPTED;
+  }
+
+  return match;
+}
+
+int trial_user_authenticator(struct redir_conn_t *conn) {
+  char mac[MACSTRLEN+7];
+
+  snprintf(mac, sizeof(mac), "trial-"MAC_FMT, MAC_ARG(conn->hismac));
+  strlcpy(conn->s_state.redir.username, mac, USERNAMESIZE);
+
+  conn->s_state.redir.auth_mode = AUTH_TRIAL_USER;
+  session_params_trial(&conn->s_params);
+
+  return ACCESS_ACCEPTED;
+}
+
+
 /* redir_accept() does the following:
    1) forks a child process
    2) Accepts the tcp connection
@@ -3345,7 +4025,7 @@
 
   /* We are forked when the redir_request is null */
   int forked = (rreq == 0);
-  int err;
+  int err, ret;
 
 
   memset(&httpreq,0,sizeof(httpreq));
@@ -3397,6 +4077,7 @@
   memset(hexchal, 0, sizeof(hexchal));
   memset(&conn, 0, sizeof(conn));
   memset(&msg, 0, sizeof(msg));
+  conn.s_state.redir.tos = 0;
 
   socket.fd[0] = infd;
   socket.fd[1] = outfd;
@@ -3561,8 +4242,8 @@
                                 || isWPAD
 #endif
                                 )) {
-          char *ctype = "text/plain";
-          char *filename = conn.wwwfile;
+          const char *ctype = "text/plain";
+          const char *filename = conn.wwwfile;
           size_t namelen = strlen(filename);
           int parse = 0;
 
@@ -3582,7 +4263,7 @@
             } else
 #endif
             {
-              char *p;
+              const char *p;
               int cnt = 0;
               for (p=filename; *p; p++) {
                 if (*p == '.' || *p == '_'|| *p == '-' || *p == '/') {
@@ -3889,6 +4570,15 @@
 
   /* default hexchal for use in replies */
   redir_chartohex(conn.s_state.redir.uamchal, hexchal, REDIR_MD5LEN);
+  if (_options.smsusers && _options.usersdbpath){
+    sqlite3 *db;
+    conn.s_state.redir.otp_state = 0;
+    if ((db = sqlopen(_options.usersdbpath)))
+      if (usr_sms_user_exists(db, NULL, conn.hismac) == USER_RET_ALREADY) {
+        conn.s_state.redir.otp_state = 1;
+        sqlclose(db);
+      }
+  }
 
   switch (conn.type) {
 
@@ -3897,21 +4587,17 @@
 
       /* Was client was already logged on? */
       if (state == 1) {
-
         if (splash) {
-
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): redir_accept: SPLASH reauth", __FUNCTION__, __LINE__);
+              syslog(LOG_DEBUG, "%s(%d): redir_accept: SPLASH reauth", __FUNCTION__, __LINE__);
           reauth = 1;
-
         } else {
-
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): redir_accept: already logged on", __FUNCTION__, __LINE__);
+              syslog(LOG_DEBUG, "%s(%d): redir_accept: already logged on", __FUNCTION__, __LINE__);
 
           redir_reply(redir, &socket, &conn, REDIR_ALREADY, NULL, 0,
                       NULL, NULL, conn.s_state.redir.userurl, NULL,
-                      (char *)conn.s_params.url, conn.hismac,
+                      (char *) conn.s_params.url, conn.hismac,
                       &conn.hisip, httpreq.qs);
 
           return redir_main_exit(&socket, forked, rreq);
@@ -3920,11 +4606,11 @@
 
       /* Did the challenge expire? */
       if (_options.challengetimeout2 &&
-          (conn.s_state.uamtime + _options.challengetimeout2) <
-          mainclock_now()) {
+        (conn.s_state.uamtime + _options.challengetimeout2) <
+        mainclock_now()) {
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): redir_accept: challenge expired: %ld : %ld", __FUNCTION__, __LINE__,
-                 (long) conn.s_state.uamtime, (long) mainclock_now());
+            syslog(LOG_DEBUG, "%s(%d): redir_accept: challenge expired: %ld : %ld", __FUNCTION__, __LINE__,
+                   (long) conn.s_state.uamtime, (long) mainclock_now());
 
         redir_memcopy(REDIR_CHALLENGE);
         redir_msg_send(REDIR_MSG_OPT_REDIR);
@@ -3936,74 +4622,197 @@
         return redir_main_exit(&socket, forked, rreq);
       }
 
-      if (is_local_user(redir, &conn)) {
-        session_param_defaults(&conn.s_params);
-        conn.response = REDIR_SUCCESS;
-      }
-      else {
+	  if (!_options.tos || (_options.tos && conn.response != REDIR_FAILED_TOS)) {
+		if (_options.localusers) {
+			if ((ret = is_local_user(redir, &conn, authenticator)) == ACCESS_ACCEPTED) {
+              session_param_defaults(&conn.s_params);
+            }
+			else if (_options.registerusers && conn.response == REDIR_FAILED_REJECT) {
+				ret = is_local_user(redir, &conn, dynamic_user_authenticator);
+			}
+
+		} else if (_options.smsusers) {
+		    if (is_local_user(redir, &conn, sms_user_authenticator) == ACCESS_ACCEPTED) {
+		      session_param_defaults(&conn.s_params);
+		    }
+    } else if (_options.macusers) {
+      is_local_user(redir, &conn, mac_user_authenticator);
+		} else {
 
 #ifdef ENABLE_MODULES
-        int i;
-        int flags = 0;
+			int i;
+			int flags = 0;
 #endif
 
-        if (!forked) {
-          /*
-           *  When waiting for RADIUS, we need to be forked.
-           *  TODO: make redir_radius asynchronous.
-           */
-          pid_t forkpid = redir_fork(infd, outfd);
-          if (forkpid) { /* parent or error */
-            return redir_main_exit(&socket, forked, rreq);
-          }
-        }
+			if (!forked) {
+				/*
+				 *  When waiting for RADIUS, we need to be forked.
+				 *  TODO: make redir_radius asynchronous.
+				 */
+				pid_t forkpid = redir_fork(infd, outfd);
+				if (forkpid) { /* parent or error */
+					return redir_main_exit(&socket, forked, rreq);
+				}
+			}
 
 #ifdef ENABLE_MODULES
-        if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): checking modules...", __FUNCTION__, __LINE__);
-        for (i=0; i < MAX_MODULES; i++) {
-          if (!_options.modules[i].name[0]) break;
-          if (_options.modules[i].ctx) {
-            struct chilli_module *m =
-                (struct chilli_module *)_options.modules[i].ctx;
-            if (m->redir_login) {
-              int modresult = m->redir_login(redir, &conn, &socket);
-              flags |= modresult;
-              switch(chilli_mod_state(modresult)) {
-                case CHILLI_MOD_ERROR:
-                  return redir_main_exit(&socket, forked, rreq);
-                default:
-                  break;
+            if (_options.debug)
+              syslog(LOG_DEBUG, "%s(%d): checking modules...", __FUNCTION__, __LINE__);
+            for (i=0; i < MAX_MODULES; i++) {
+              if (!_options.modules[i].name[0]) break;
+              if (_options.modules[i].ctx) {
+                struct chilli_module *m =
+                    (struct chilli_module *)_options.modules[i].ctx;
+                if (m->redir_login) {
+                  int modresult = m->redir_login(redir, &conn, &socket);
+                  flags |= modresult;
+                  switch(chilli_mod_state(modresult)) {
+                    case CHILLI_MOD_ERROR:
+                      return redir_main_exit(&socket, forked, rreq);
+                    default:
+                      break;
+                  }
+                }
               }
             }
-          }
-        }
-        if (flags & CHILLI_MOD_REDIR_SKIP_RADIUS) {
-          if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): Skipping RADIUS authentication", __FUNCTION__, __LINE__);
-        } else {
+			if (flags & CHILLI_MOD_REDIR_SKIP_RADIUS) {
+			  if (_options.debug)
+				syslog(LOG_DEBUG, "%s(%d): Skipping RADIUS authentication", __FUNCTION__, __LINE__);
+			} else {
 #endif
 
-          termstate = REDIR_TERM_RADIUS;
+			termstate = REDIR_TERM_RADIUS;
 
-          if (optionsdebug)
-            syslog(LOG_DEBUG, "%s(%d): redir_accept: Sending RADIUS request", __FUNCTION__, __LINE__);
+			if (optionsdebug)
+				syslog(LOG_DEBUG, "%s(%d): redir_accept: Sending RADIUS request", __FUNCTION__, __LINE__);
 
-          redir_radius(redir, &address->sin_addr, &conn, reauth);
-          termstate = REDIR_TERM_REPLY;
+			redir_radius(redir, &address->sin_addr, &conn, reauth);
+			termstate = REDIR_TERM_REPLY;
 
 #ifdef ENABLE_MODULES
-        }
+			}
 #endif
 
 #if(_debug_ > 1)
-        if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): Received RADIUS reply", __FUNCTION__, __LINE__);
+			if (_options.debug)
+			  syslog(LOG_DEBUG, "%s(%d): Received RADIUS reply", __FUNCTION__, __LINE__);
 #endif
-      }
+		}
+	  }
 
       if (conn.response == REDIR_SUCCESS) { /* Accept-Accept */
+        conn.s_params.flags &= ~REQUIRE_UAM_SPLASH;
+
+        if (reauth) {
+          conn.s_params.flags |= IS_UAM_REAUTH;
+        }
+
+        msg.mtype = REDIR_LOGIN;
+
+        if (_options.debug)
+          syslog(LOG_DEBUG, "%s(%d): handling Access-Accept", __FUNCTION__, __LINE__);
+
+//        if (_options.successuserurl || _options.successurlcustom){
+            bstring successurl;
+            successurl = bfromcstralloc(1024,"");
+            if (_options.successuserurl)
+                bcatcstr(successurl, conn.s_state.redir.userurl);
+            else if (_options.successurlcustom)
+                bcatcstr(successurl, _options.successurlcustom);
+            else
+                successurl = NULL;
+
+            redir_reply(redir, &socket, &conn, REDIR_SUCCESS, successurl,
+                        conn.s_params.sessiontimeout, NULL,
+                        conn.s_state.redir.username,
+                        conn.s_state.redir.userurl, conn.reply,
+                        (char *)conn.s_params.url,
+                        conn.hismac, &conn.hisip, httpreq.qs);
+            bdestroy(successurl);
+//        } else {
+//            redir_reply(redir, &socket, &conn, REDIR_SUCCESS, NULL,
+//                        conn.s_params.sessiontimeout, NULL,
+//                        conn.s_state.redir.username,
+//                        conn.s_state.redir.userurl, conn.reply,
+//                        (char *)conn.s_params.url,
+//                        conn.hismac, &conn.hisip, httpreq.qs);
+//        }
+
+        /* set params and redir data */
+        redir_msg_send(REDIR_MSG_OPT_REDIR | REDIR_MSG_OPT_PARAMS);
+
+      } else { /* Access-Reject */
+        int hasnexturl = (strlen((char *)conn.s_params.url) > 5);
+
+        if (_options.debug)
+          syslog(LOG_DEBUG, "%s(%d): handling Access-Reject", __FUNCTION__, __LINE__);
 
+        if (!hasnexturl) {
+          if (_options.challengetimeout)
+            redir_memcopy(REDIR_CHALLENGE);
+        } else {
+          msg.mtype = REDIR_NOTYET;
+        }
+
+        redir_reply(redir, &socket, &conn, conn.response,
+                    NULL,
+                    0, hexchal, NULL, conn.s_state.redir.userurl, conn.reply,
+                    (char *)conn.s_params.url, conn.hismac,
+                    &conn.hisip, httpreq.qs);
+
+        /* set params, redir data, and reset session-id */
+        redir_msg_send(REDIR_MSG_OPT_REDIR | REDIR_MSG_OPT_PARAMS |
+                       (conn.response == REDIR_CHALLENGE ? 0 : REDIR_MSG_NSESSIONID));
+      }
+
+      if (_options.debug)
+        syslog(LOG_DEBUG, "%s(%d): -->> Msg userurl=[%s]\n", __FUNCTION__, __LINE__, conn.s_state.redir.userurl);
+      return redir_main_exit(&socket, forked, rreq);
+    }
+
+    case REDIR_TRIAL: {
+      char reauth = 0;
+
+      /* Was client was already logged on? */
+      if (state == 1) {
+        if (splash) {
+          if (_options.debug)
+            syslog(LOG_DEBUG, "%s(%d): redir_accept: SPLASH reauth", __FUNCTION__, __LINE__);
+          reauth = 1;
+        } else {
+          if (_options.debug)
+            syslog(LOG_DEBUG, "%s(%d): redir_accept: already logged on", __FUNCTION__, __LINE__);
+
+          redir_reply(redir, &socket, &conn, REDIR_ALREADY, NULL, 0,
+                      NULL, NULL, conn.s_state.redir.userurl, NULL,
+                      (char *) conn.s_params.url, conn.hismac,
+                      &conn.hisip, httpreq.qs);
+
+          return redir_main_exit(&socket, forked, rreq);
+        }
+      }
+
+      //Setting conn.response here.
+      if (!_options.tos || (_options.tos && conn.response != REDIR_FAILED_TOS)) {
+		  if (_options.trialusers && trial_user_authenticator(&conn)) {
+			  conn.response = REDIR_SUCCESS;
+#ifdef ENABLE_DATABASE
+			  if (conn.s_params.maxinputoctets || conn.s_params.maxoutputoctets ||
+					  conn.s_params.sessiontimeout) {
+				switch (dbcheck_session(&conn)){
+				  case ACCESS_DENIED_DATA:
+					conn.response = REDIR_TRIAL_FAILED_DATA;
+					break;
+				  case ACCESS_DENIED_TIME:
+					conn.response = REDIR_TRIAL_FAILED_TIME;
+					break;
+				}
+			  }
+#endif
+		  }
+	  }
+
+      if (conn.response == REDIR_SUCCESS) { /* Accept-Accept */
         conn.s_params.flags &= ~REQUIRE_UAM_SPLASH;
 
         if (reauth) {
@@ -4015,18 +4824,28 @@
         if (_options.debug)
           syslog(LOG_DEBUG, "%s(%d): handling Access-Accept", __FUNCTION__, __LINE__);
 
-        redir_reply(redir, &socket, &conn, REDIR_SUCCESS, NULL,
+//        if (_options.successuserurl || _options.successurlcustom){
+        bstring successurl;
+        successurl = bfromcstralloc(1024,"");
+        if (_options.successuserurl)
+          bcatcstr(successurl, conn.s_state.redir.userurl);
+        else if (_options.successurlcustom)
+          bcatcstr(successurl, _options.successurlcustom);
+        else
+          successurl = NULL;
+
+        redir_reply(redir, &socket, &conn, REDIR_SUCCESS, successurl,
                     conn.s_params.sessiontimeout, NULL,
                     conn.s_state.redir.username,
                     conn.s_state.redir.userurl, conn.reply,
                     (char *)conn.s_params.url,
                     conn.hismac, &conn.hisip, httpreq.qs);
+        bdestroy(successurl);
 
         /* set params and redir data */
         redir_msg_send(REDIR_MSG_OPT_REDIR | REDIR_MSG_OPT_PARAMS);
 
       } else { /* Access-Reject */
-
         int hasnexturl = (strlen((char *)conn.s_params.url) > 5);
 
         if (_options.debug)
@@ -4034,9 +4853,9 @@
 
         if (!hasnexturl) {
           if (_options.challengetimeout)
-            redir_memcopy(REDIR_CHALLENGE);
+          redir_memcopy(REDIR_CHALLENGE);
         } else {
-          msg.mtype = REDIR_NOTYET;
+          msg.mtype = REDIR_TRIALLOGIN_FAILED;
         }
 
         redir_reply(redir, &socket, &conn, conn.response,
@@ -4148,6 +4967,40 @@
         return redir_main_exit(&socket, forked, rreq);
       }
 
+    case REDIR_SIGNUP:
+		if (_options.registerusers)
+			usr_add_user(&conn);
+
+		redir_reply(redir, &socket, &conn, conn.response, NULL, 0,
+			  hexchal, NULL, conn.s_state.redir.userurl, NULL,
+			  NULL, conn.hismac, &conn.hisip, httpreq.qs);
+
+      return redir_main_exit(&socket, forked, rreq);
+    case REDIR_SMSSIGNUP:
+    	{
+    		if (_options.smsusers) {
+				int ret;
+
+				if (strlen(conn.s_state.redir.phone) < USER_MIN_PHONE_LEN) {
+					conn.response = REDIR_SMSSIGNUP_FAILED;
+				} else if ((ret = usr_add_sms_user(&conn, conn.s_state.redir.phone, hexchal))) {
+					if (ret == USER_RET_ALREADY)
+						conn.response = REDIR_SMSSIGNUP_ALREADY;
+					else if (ret == USER_RET_SMS_ERR)
+						conn.response = REDIR_SMSSIGNUP_SMS_FAIL;
+					else
+						conn.response = REDIR_SMSSIGNUP_FAILED;
+				} else {
+					conn.response = REDIR_SMSSIGNUP_SUCCESS;
+				}
+			}
+
+			redir_reply(redir, &socket, &conn, conn.response, NULL, 0,
+						hexchal, NULL, conn.s_state.redir.userurl, NULL,
+						NULL, conn.hismac, &conn.hisip, httpreq.qs);
+
+			return redir_main_exit(&socket, forked, rreq);
+		}
     case REDIR_MSDOWNLOAD:
       snprintf(buffer, bufsize, "HTTP/1.0 403 Forbidden\r\n\r\n");
       redir_write(&socket, buffer, strlen(buffer));
@@ -4314,11 +5167,8 @@
     redir_memcopy(REDIR_CHALLENGE);
     redir_msg_send(REDIR_MSG_OPT_REDIR);
   }
-  else {
-    redir_chartohex(conn.s_state.redir.uamchal, hexchal, REDIR_MD5LEN);
-    msg.mtype = splash ? REDIR_ALREADY : REDIR_NOTYET;
-    redir_msg_send(REDIR_MSG_OPT_REDIR);
-  }
+
+  redir_chartohex(conn.s_state.redir.uamchal, hexchal, REDIR_MD5LEN);
 
 #if(_debug_ > 1)
   if (_options.debug)
diff --recursive --unified --new-file --no-dereference orig/src/redir.h src/src/redir.h
--- orig/src/redir.h	2016-12-15 17:28:43.000000000 +0000
+++ src/src/redir.h	2024-01-26 11:00:37.000000000 +0000
@@ -45,6 +45,9 @@
 #define REDIR_SPLASH          8
 #define REDIR_MACREAUTH       9
 #define REDIR_REQERROR       10  /* Used internally when the HTTP request parsing created an error */
+#define REDIR_SIGNUP		11
+#define REDIR_SMSSIGNUP		12
+#define REDIR_TRIAL			13
 
 #define REDIR_WWW            20
 #ifdef ENABLE_EWTAPI
@@ -70,6 +73,23 @@
 #define REDIR_FAILED_NOROUTE 60 /* Reply to /logon - no route for NAI */
 #define REDIR_ERROR_PROTOCOL 61 /* Reply to /logon - the client software is not matching the protocol (e.g. WISPr 1.0 or WISPr 2.0) */
 #define REDIR_CHALLENGE      62 /* Reply to /logon - if Radius challenge received in EAP authentication */
+#define REDIR_FAILED_DATA	 63 /* Reply to /logon if data limit reached */
+#define REDIR_FAILED_TIME	 64 /* Reply to /logon if time limit reached */
+#define REDIR_SIGNUP_FAILED	 65 /* Reply to /signup if no username or password found */
+#define REDIR_SIGNUP_SUCCESS 66 /* Reply to /signup user registered successfully */
+#define REDIR_SIGNUP_ALREADY 67 /* Reply to /signup user registered unsuccessfully */
+#define REDIR_SIGNUP_DENIED 68 /* Reply to /signup if method is disabled */
+#define REDIR_SMSSIGNUP_FAILED 69 /* Reply to /smssignup user registered unsuccessfully */
+#define REDIR_SMSSIGNUP_ALREADY 70 /* Reply to /smssignup user registered unsuccessfully */
+#define REDIR_SMSSIGNUP_SUCCESS 71 /* Reply to /smssignup user registered successfully */
+#define REDIR_SMSSIGNUP_SMS_FAIL 72 /* Reply to /smssignup user registered unsuccessfully (sms failure) */
+#define REDIR_SMSSIGNUP_DENIED 73 /* Reply to /smssignup if method is disabled */
+#define REDIR_FAILED_TOS 74 /* Reply to /logon - the client does not accepted TOS */
+#define REDIR_TRIALLOGIN_DENIED 75 /* Reply to /trial - method not allowed */
+#define REDIR_TRIALLOGIN_FAILED 76 /* Reply to /trial - login failed */
+#define REDIR_TRIAL_FAILED_DATA	 77 /* Reply to /trial if data limit reached */
+#define REDIR_TRIAL_FAILED_TIME	 78 /* Reply to /trial if time limit reached */
+#define REDIR_FAILED_USER_DUPLICATE	 79 /* Reply to /logon if user duplicates with other */
 
 /* If more than one format flag is set, it indicates that Coova advertises several
    protocols that can be used by the client. Once the client has choosen which protocol
@@ -92,6 +112,18 @@
 #define REDIR_MSG_OPT_PARAMS  2
 #define REDIR_MSG_NSESSIONID  4
 
+#define ACCESS_DENIED 0
+#define ACCESS_ACCEPTED 1
+#define ACCESS_DENIED_DATA 2
+#define ACCESS_DENIED_TIME 3
+#define ACCESS_DENIED_UDUPCLICATE 4
+
+#define AUTH_LOCAL_USER 0
+#define AUTH_DYN_USER 1
+#define AUTH_SMS_USER 2
+#define AUTH_MAC_USER 3
+#define AUTH_TRIAL_USER 4
+
 struct eapmsg_t {
   uint16_t len;
   uint8_t data[MAX_EAP_LEN];
@@ -156,6 +188,10 @@
    */
   struct session_params s_params;
   struct session_state s_state;
+#ifdef ENABLE_DATABASE
+    struct session_history s_history;		/*Session history*/
+#endif
+
 } __attribute__((packed));
 
 /* HTTP request parsing context */
@@ -243,7 +279,7 @@
   int uiport;
 #endif
 
-  int starttime;
+  time_t starttime;
 
   char *url;
   char *homepage;
diff --recursive --unified --new-file --no-dereference orig/src/session.c src/src/session.c
--- orig/src/session.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/session.c	2024-01-26 11:00:37.000000000 +0000
@@ -68,16 +68,16 @@
   bcatcstr(json,"\",\"userName\":\"");
   bcatcstr(json,state->redir.username);
   bcatcstr(json, "\",\"startTime\":");
-  bassignformat(tmp, "%ld", (long) mainclock_towall(init ? mainclock_now() : starttime));
+  bassignformat(tmp, "%"PRId64, (uint64_t) mainclock_towall(init ? mainclock_now() : starttime));
   bconcat(json, tmp);
   bcatcstr(json,",\"sessionTimeout\":");
-  bassignformat(tmp, "%ld", (long) params->sessiontimeout);
+  bassignformat(tmp, "%"PRId64, (uint64_t) params->sessiontimeout);
   bconcat(json, tmp);
   bcatcstr(json,",\"terminateTime\":");
-  bassignformat(tmp, "%ld", (long) params->sessionterminatetime);
+  bassignformat(tmp, "%"PRId64, (uint64_t) params->sessionterminatetime);
   bconcat(json, tmp);
   bcatcstr(json,",\"idleTimeout\":");
-  bassignformat(tmp, "%ld", (long) params->idletimeout);
+  bassignformat(tmp, "%"PRId64, (uint64_t) params->idletimeout);
   bconcat(json, tmp);
 #ifdef ENABLE_IEEE8021Q
   if (_options.ieee8021q && state->tag8021q) {
@@ -101,6 +101,11 @@
     bassignformat(tmp, "%lld", params->maxtotaloctets);
     bconcat(json, tmp);
   }
+  if (params->warningoctets) {
+    bcatcstr(json,",\"warningOctets\":");
+    bassignformat(tmp, "%lld", params->warningoctets);
+    bconcat(json, tmp);
+  }
 
   bdestroy(tmp);
   return 0;
diff --recursive --unified --new-file --no-dereference orig/src/session.h src/src/session.h
--- orig/src/session.h	2016-12-15 17:28:43.000000000 +0000
+++ src/src/session.h	2024-01-26 11:00:37.000000000 +0000
@@ -25,7 +25,6 @@
 #include "garden.h"
 
 struct session_params {
-  uint8_t url[REDIR_USERURLSIZE];
   uint8_t filteridbuf[256];
   uint8_t filteridlen;
   uint8_t routeidx;
@@ -34,10 +33,20 @@
   uint64_t maxinputoctets;
   uint64_t maxoutputoctets;
   uint64_t maxtotaloctets;
+  uint64_t warningoctets; /* Data amount over which an SMS warning is sent */
   uint64_t sessiontimeout;
   uint32_t idletimeout;
   uint16_t interim_interval;     /* Seconds. 0 = No interim accounting */
   time_t sessionterminatetime;
+  int period; /* Data limit period */
+  int start;  /* Data limit start point */
+  uint64_t expiration;  /* Expiration time for dynamically allocated users */
+  uint32_t padding;
+  uint8_t url[REDIR_USERURLSIZE];
+
+#define PERIOD_DAY 1
+#define PERIOD_WEEK 2
+#define PERIOD_MONTH 3
 
 #define REQUIRE_UAM_AUTH   (1<<0)
 #define REQUIRE_UAM_SPLASH (1<<1)
@@ -74,27 +83,23 @@
 
   char username[REDIR_USERNAMESIZE];
   char userurl[REDIR_USERURLSIZE];
+  char phone[64];
+  char email[128];
+  char signup_password[128];
 
   uint8_t uamchal[REDIR_MD5LEN];
 
-  /* To store the RADIUS CLASS attribute received in the Access Accept */
-  uint8_t classbuf[RADIUS_ATTR_VLEN];
-  size_t classlen;
-
-  /* To store the RADIUS CUI attribute received in the Access Accept */
-  uint8_t cuibuf[RADIUS_ATTR_VLEN];
-  size_t cuilen;
-
-  /* To store the RADIUS STATE attribute between Radius requests */
-  uint8_t statebuf[RADIUS_ATTR_VLEN];
-  uint8_t statelen;
-
   /*  EAP identity of the last request sent */
   uint8_t eap_identity;
 
   /* UAM protocol used */
   uint8_t uamprotocol;
 
+  uint8_t tos:1;
+  uint8_t otp_state:1;
+  int auth_mode; /* user authentication mode */
+  int user_time;
+
 #ifdef ENABLE_USERAGENT
   char useragent[REDIR_USERAGENTSIZE];
 #endif
@@ -113,6 +118,15 @@
   size_t vsalen;
 #endif
 
+  /* To store the RADIUS CLASS attribute received in the Access Accept */
+  uint8_t classbuf[RADIUS_ATTR_VLEN];
+  /* To store the RADIUS CUI attribute received in the Access Accept */
+  uint8_t cuibuf[RADIUS_ATTR_VLEN];
+  /* To store the RADIUS STATE attribute between Radius requests */
+  uint8_t statebuf[RADIUS_ATTR_VLEN];
+  size_t classlen;
+  size_t cuilen;
+  uint8_t statelen;
 } __attribute__((packed));
 
 struct session_state {
@@ -137,12 +151,16 @@
   time_t last_time; /* Last time a packet was received or sent */
   time_t uamtime;
 
+  int warning_sent_download;
+  int warning_sent_upload;
+
   uint64_t input_packets;
   uint64_t output_packets;
   uint64_t input_octets;
   uint64_t output_octets;
   uint32_t terminate_cause;
   uint32_t session_id;
+  uint32_t terminate_cause_ui;
 
 #ifdef ENABLE_GARDENACCOUNTING
   char garden_sessionid[REDIR_SESSIONID_LEN];
@@ -198,5 +216,14 @@
 #endif
 
 } __attribute__((packed));
+#ifdef ENABLE_DATABASE
+struct session_history {
+    uint64_t input_packets;
+    uint64_t output_packets;
+    uint64_t input_octets;
+    uint64_t output_octets;
+    uint32_t sessiontime;
+} __attribute__((packed));
+#endif
 
 #endif
diff --recursive --unified --new-file --no-dereference orig/src/sqlite.c src/src/sqlite.c
--- orig/src/sqlite.c	1970-01-01 00:00:00.000000000 +0000
+++ src/src/sqlite.c	2024-01-26 11:00:37.000000000 +0000
@@ -0,0 +1,73 @@
+
+#include "sqlite.h"
+#include "system.h"
+
+sqlite3 *sqlopen(char *dbpath) {
+    sqlite3 *db;
+    int ret;
+
+    ret = sqlite3_open(dbpath, &db);
+    if (ret)
+        syslog(LOG_INFO, "[%s] Can't open database: %s", __FUNCTION__ , sqlite3_errmsg(db));
+
+    return db;
+}
+
+int sqlclose(sqlite3 *db){
+    return sqlite3_close(db);
+}
+
+int sqlexec(sqlite3 *db, char *sql, int (*callback)(void*,int,char**,char**)){
+    int ret;
+    char *err = 0;
+
+    ret = sqlite3_exec(db, sql, callback, 0, &err);
+    if (ret){
+        syslog(LOG_INFO, "[%s] SQL error: %s\n", __FUNCTION__, err);
+        sqlite3_free(err);
+    }
+
+    return ret;
+}
+
+int sqlprepare(sqlite3 *db, char *sql){
+    sqlite3_stmt *stmt;
+    int ret;
+
+    ret = sqlite3_prepare_v2(db, sql, -1, &stmt, NULL);
+    if (ret) {
+        syslog(LOG_INFO, "SQL error: %s\n", sqlite3_errmsg(db));
+        goto out;
+    }
+
+    ret = sqlite3_step(stmt);
+    if (ret){
+        syslog(LOG_INFO, "SQL error: %s\n", sqlite3_errmsg(db));
+        goto out;
+    }
+
+    out:
+    return ret;
+}
+
+int sqltable_exists(sqlite3 *db, char *table_name){
+    int ret;
+    int count = 0;
+    char *sql = NULL;
+    sqlite3_stmt *stmt;
+
+    asprintf(&sql, "SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name='%s';",
+			 table_name);
+    ret = sqlite3_prepare_v2(db, sql, -1, &stmt, 0);
+    if (ret != SQLITE_OK) {
+        syslog(LOG_INFO, "[%s] SQL error: %s", __FUNCTION__ , sqlite3_errmsg(db));
+        return SQL_FAIL;
+    }
+
+    if ((ret = sqlite3_step(stmt)) == SQLITE_ROW)
+        count = sqlite3_column_int(stmt, 0);
+
+    sqlite3_finalize(stmt);
+
+    return (count == 0) ? SQL_FAIL : SQL_SUCCESS;
+}
diff --recursive --unified --new-file --no-dereference orig/src/sqlite.h src/src/sqlite.h
--- orig/src/sqlite.h	1970-01-01 00:00:00.000000000 +0000
+++ src/src/sqlite.h	2024-01-26 11:00:37.000000000 +0000
@@ -0,0 +1,19 @@
+//
+// Created by darius on 19.5.23.
+//
+
+#ifndef RUTX_SQLITE_H
+#define RUTX_SQLITE_H
+
+#include <sqlite3.h>
+
+#define SQL_SUCCESS 0
+#define SQL_FAIL 1
+
+sqlite3 *sqlopen(char *dbpath);
+int sqlclose(sqlite3 *db);
+int sqlexec(sqlite3 *db, char *sql, int (*callback)(void*,int,char**,char**));
+int sqlprepare(sqlite3 *db, char *sql);
+int sqltable_exists(sqlite3 *db, char *table_name);
+
+#endif //RUTX_SQLITE_H
diff --recursive --unified --new-file --no-dereference orig/src/statusfile.c src/src/statusfile.c
--- orig/src/statusfile.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/statusfile.c	2024-01-26 11:00:37.000000000 +0000
@@ -324,7 +324,7 @@
   file = fopen(filedest, "w");
   if (!file) { syslog(LOG_ERR, "%s: could not open file %s", strerror(errno), filedest); return -1; }
   fprintf(file, "#CoovaChilli-Version: %s\n", VERSION);
-  fprintf(file, "#Timestamp: %d\n", (int) mainclock);
+  fprintf(file, "#Timestamp: %"PRId64"\n", (uint64_t) mainclock);
 
   /* marker */
   fputc(MARK_START, file);
@@ -394,20 +394,20 @@
   fprintf(file, "#Version:1.1\n");
   fprintf(file, "#SessionID = SID\n#Start-Time = ST\n");
   fprintf(file, "#SessionTimeOut = STO\n#SessionTerminateTime = STT\n");
-  fprintf(file, "#Timestamp: %d\n", (int) mainclock);
+  fprintf(file, "#Timestamp: %"PRId64"\n", (uint64_t) mainclock);
   fprintf(file, "#User, IP, MAC, SID, ST, STO, STT\n");
 
   while(dhcpconn) {
     appconn = (struct app_conn_t *)dhcpconn->peer;
     if (appconn && appconn->s_state.authenticated == 1) {
-      fprintf(file, "%s, %s, %.2X-%.2X-%.2X-%.2X-%.2X-%.2X, %s, %d, %d, %d\n",
+      fprintf(file, "%s, %s, %.2X-%.2X-%.2X-%.2X-%.2X-%.2X, %s, %"PRId64", %d, %d\n",
 	      appconn->s_state.redir.username,
 	      inet_ntoa(appconn->hisip),
 	      appconn->hismac[0], appconn->hismac[1],
 	      appconn->hismac[2], appconn->hismac[3],
 	      appconn->hismac[4], appconn->hismac[5],
 	      appconn->s_state.sessionid,
-	      appconn->s_state.start_time,
+	      (uint64_t)appconn->s_state.start_time,
 	      appconn->s_params.sessiontimeout,
 	      appconn->s_params.sessionterminatetime);
     }
diff --recursive --unified --new-file --no-dereference orig/src/ubus.c src/src/ubus.c
--- orig/src/ubus.c	1970-01-01 00:00:00.000000000 +0000
+++ src/src/ubus.c	2024-01-26 11:00:37.000000000 +0000
@@ -0,0 +1,544 @@
+
+#include "chilli.h"
+#include "options.h"
+
+
+static int chilli_list_method(struct ubus_context *ctx, struct ubus_object *obj,
+							  struct ubus_request_data *req, const char *method, struct blob_attr *msg);
+static int chilli_logout_method(struct ubus_context *ctx, struct ubus_object *obj,
+								struct ubus_request_data *req, const char *method, struct blob_attr *msg);
+
+static int chilli_forget_method(struct ubus_context *ctx, struct ubus_object *obj,
+								struct ubus_request_data *req, const char *method, struct blob_attr *msg);
+
+enum {
+	FORMAT_TABLE,
+	FORMAT_ARRAY
+};
+
+enum {
+	CHILLI_IP,
+	CHILLI_MAC,
+	CHILLI_SESSION_ID,
+	CHILLI_MAX
+};
+
+enum {
+	CHILLI_FORGET_MAC,
+	CHILLI_FORGET_MAX
+};
+
+static const struct blobmsg_policy chilli_default_policy[] = {
+		[CHILLI_IP]  = {.name = "ip", .type = BLOBMSG_TYPE_STRING},
+		[CHILLI_MAC] = {.name = "mac", .type = BLOBMSG_TYPE_STRING},
+		[CHILLI_SESSION_ID]   = {.name = "sessionid", .type = BLOBMSG_TYPE_STRING},
+};
+
+static const struct blobmsg_policy chilli_forget_policy[] = {
+		[CHILLI_FORGET_MAC] = {.name = "mac", .type = BLOBMSG_TYPE_STRING},
+};
+
+static const struct ubus_method chilli_methods[] = {
+		UBUS_METHOD("list", chilli_list_method, chilli_default_policy),
+		UBUS_METHOD("logout", chilli_logout_method, chilli_default_policy),
+		UBUS_METHOD("forget", chilli_forget_method, chilli_forget_policy),
+};
+
+static struct ubus_object_type chilli_object_type =
+		UBUS_OBJECT_TYPE("chilli_obj_type", chilli_methods);
+
+struct ubus_object chilli_object = {
+		.name      = "chilli",
+		.type      = &chilli_object_type,
+		.methods   = chilli_methods,
+		.n_methods = ARRAY_SIZE(chilli_methods),
+};
+
+static int parse_mac(uint8_t *mac, char *string) {
+	unsigned int temp[PKT_ETH_ALEN];
+	char macstr[RADIUS_ATTR_VLEN];
+	int macstrlen;
+	int i;
+
+	if ((macstrlen = strlen(string)) >= (RADIUS_ATTR_VLEN-1)) {
+		fprintf(stderr, "%s: bad MAC address\n", string);
+		return -1;
+	}
+
+	memcpy(macstr, string, macstrlen);
+	macstr[macstrlen] = 0;
+
+	for (i=0; i<macstrlen; i++)
+		if (!isxdigit((int) macstr[i]))
+			macstr[i] = 0x20;
+
+	if (sscanf(macstr, "%2x %2x %2x %2x %2x %2x",
+			   &temp[0], &temp[1], &temp[2],
+			   &temp[3], &temp[4], &temp[5]) != 6) {
+		fprintf(stderr, "%s: bad MAC address\n", string);
+		return -1;
+	}
+
+	for (i = 0; i < PKT_ETH_ALEN; i++)
+		mac[i] = temp[i];
+
+	return 0;
+}
+
+static void chilli_session_params(struct session_state *state, struct session_params *params,
+								  struct blob_buf *b)
+{
+	time_t starttime = state->start_time;
+
+	blobmsg_add_string(b, "sessionId", state->sessionid);
+	blobmsg_add_string(b, "userName", state->redir.username);
+	blobmsg_add_u64(b, "startTime", (uint64_t) mainclock_towall(starttime));
+	blobmsg_add_u64(b, "sessionTimeout", params->sessiontimeout);
+	blobmsg_add_u64(b, "terminateTime", params->sessionterminatetime);
+	blobmsg_add_u32(b, "idleTimeout", params->idletimeout);
+#ifdef ENABLE_IEEE8021Q
+	if (_options.ieee8021q && state->tag8021q) {
+		blobmsg_add_u16(b, "vlan", ntohs(state->tag8021q & PKT_8021Q_MASK_VID));
+	}
+#endif
+	if (params->maxinputoctets) {
+		blobmsg_add_u64(b, "maxInputOctets", params->maxinputoctets);
+	}
+	if (params->maxoutputoctets) {
+		blobmsg_add_u64(b, "maxOutputOctets", params->maxoutputoctets);
+	}
+	if (params->maxtotaloctets) {
+		blobmsg_add_u64(b, "maxTotalOctets", params->maxtotaloctets);
+	}
+	if (params->bandwidthmaxdown) {
+		blobmsg_add_u64(b, "maxDwBandwidth", params->bandwidthmaxdown);
+	}
+	if (params->bandwidthmaxup) {
+		blobmsg_add_u64(b, "maxUpBandwidth", params->bandwidthmaxup);
+	}
+}
+
+static void chilli_session_acct(struct session_state *state, struct blob_buf *b)
+{
+	uint32_t inoctets = state->input_octets;
+	uint32_t outoctets = state->output_octets;
+	uint32_t ingigawords = (state->input_octets >> 32);
+	uint32_t outgigawords = (state->output_octets >> 32);
+	uint32_t sessiontime;
+	uint32_t idletime;
+
+	sessiontime = mainclock_diffu(state->start_time);
+	idletime    = mainclock_diffu(state->last_up_time);
+
+	blobmsg_add_u32(b, "sessionTime", !state->authenticated ? 0 : sessiontime);
+	blobmsg_add_u32(b, "idleTime", !state->authenticated ? 0 : idletime);
+	blobmsg_add_u32(b, "inputOctets", !state->authenticated ? 0 : inoctets);
+	blobmsg_add_u32(b, "outputOctets", !state->authenticated ? 0 : outoctets);
+	blobmsg_add_u32(b, "inputGigawords", !state->authenticated ? 0 : ingigawords);
+	blobmsg_add_u32(b, "outputGigawords", !state->authenticated ? 0 : (long)outgigawords);
+	blobmsg_add_string(b, "viewPoint", _options.swapoctets ? "nas" : "client");
+}
+
+static void chilli_getinfo(struct app_conn_t *appconn, struct blob_buf *b, int format_array) {
+	if (appconn->s_state.authenticated) {
+		void *i = blobmsg_open_table(b, "session");
+		chilli_session_params(&appconn->s_state, &appconn->s_params, b);
+		blobmsg_close_table(b, i);
+
+		if (format_array) {
+			i = blobmsg_open_table(b, "accounting");
+			chilli_session_acct(&appconn->s_state, b);
+			blobmsg_close_table(b, i);
+		}
+	}
+}
+
+void chilli_form_blob(struct blob_buf *b, struct app_conn_t *appconn, struct dhcp_conn_t *conn, int format_array) {
+	char tmp_buff[64];
+	void *i;
+
+	if (!appconn && conn)
+		appconn = (struct app_conn_t *)conn->peer;
+
+	if ((!appconn || !appconn->inuse)) {
+		return;
+	} else if (conn && !conn->inuse) {
+		return;
+	} else {
+		if (format_array) {
+			i = blobmsg_open_table(b, NULL);
+		}
+		if (appconn) {
+			blobmsg_add_u32(b, "nasPort", appconn->unit);
+			blobmsg_add_u8(b, "clientState", appconn->s_state.authenticated);
+			blobmsg_add_string(b, "ipAddress", inet_ntoa(appconn->hisip));
+			if (appconn->s_state.redir.userurl[0]) {
+				blobmsg_add_string(b, "url", appconn->s_state.redir.userurl);
+			}
+		}
+
+		if (conn) {
+			sprintf(tmp_buff, MAC_FMT, MAC_ARG(conn->hismac));
+			blobmsg_add_string(b, "macAddress", tmp_buff);
+			blobmsg_add_string(b, "dhcpState", state2name(conn->authstate));
+		}
+
+		if (appconn) {
+			chilli_getinfo(appconn, b, format_array);
+		}
+
+		if (format_array) {
+			blobmsg_close_table(b, i);
+		}
+	}
+}
+
+void unused (void){
+	return;
+}
+
+static int chilli_list_method(struct ubus_context *ctx, struct ubus_object *obj,
+							  struct ubus_request_data *req, const char *method,
+							  struct blob_attr *msg)
+{
+	struct cmdsock_request req_params = { 0 };
+	struct app_conn_t *appconn = NULL;
+	struct dhcp_conn_t *dhcpconn = NULL;
+	struct blob_attr *tb[CHILLI_MAX];
+	struct blob_buf b = { 0 };
+	int crt = 0;
+	void *ses;
+
+	blob_buf_init(&b, 0);
+	blobmsg_parse(chilli_default_policy, ARRAY_SIZE(chilli_default_policy),
+				  tb, blob_data(msg), blob_len(msg));
+
+	if (tb[CHILLI_IP]) {
+		crt = 1;
+		if (!inet_pton(AF_INET, blobmsg_data(tb[CHILLI_IP]), &req_params.ip)) {
+			return UBUS_STATUS_INVALID_ARGUMENT;
+		}
+	}
+
+	if (tb[CHILLI_MAC]) {
+		if (parse_mac(req_params.mac, blobmsg_data(tb[CHILLI_MAC]))) {
+			return UBUS_STATUS_INVALID_ARGUMENT;
+		}
+
+		crt = 1;
+	}
+
+	if (tb[CHILLI_SESSION_ID]) {
+		crt = 1;
+		strlcpy(req_params.d.sess.sessionid, blobmsg_data(tb[CHILLI_SESSION_ID]),
+				sizeof(req_params.d.sess.sessionid));
+	}
+
+	ses = blobmsg_open_array(&b, "sessions");
+	appconn = find_app_conn(&req_params, &crt);
+	if (appconn) {
+		dhcpconn = (struct dhcp_conn_t *)appconn->dnlink;
+		chilli_form_blob(&b, appconn, dhcpconn, FORMAT_ARRAY);
+	} else if (!crt) {
+		if (dhcp) {
+			dhcpconn = dhcp->firstusedconn;
+			while (dhcpconn) {
+				chilli_form_blob(&b, NULL, dhcpconn, FORMAT_ARRAY);
+				dhcpconn = dhcpconn->next;
+			}
+		}
+	}
+
+	blobmsg_close_array(&b, ses);
+	ubus_send_reply(ctx, req, b.head);
+	blob_buf_free(&b);
+
+	return UBUS_STATUS_OK;
+}
+
+static int chilli_logout_method(struct ubus_context *ctx, struct ubus_object *obj,
+								struct ubus_request_data *req, const char *method, struct blob_attr *msg)
+{
+	struct cmdsock_request req_params;
+	struct app_conn_t *appconn = NULL;
+	struct blob_attr *tb[CHILLI_MAX];
+	int count = 0;
+
+	memset(&req_params, 0, sizeof(req_params));
+	blobmsg_parse(chilli_default_policy, ARRAY_SIZE(chilli_default_policy),
+				  tb, blob_data(msg), blob_len(msg));
+
+	if (tb[CHILLI_IP]) {
+		count++;
+		if (!inet_pton(AF_INET, blobmsg_data(tb[CHILLI_IP]), &req_params.ip)) {
+			return UBUS_STATUS_INVALID_ARGUMENT;
+		}
+	}
+
+	if (tb[CHILLI_MAC]) {
+		if (parse_mac(req_params.mac, blobmsg_data(tb[CHILLI_MAC]))) {
+			return UBUS_STATUS_INVALID_ARGUMENT;
+		}
+
+		count++;
+	}
+
+	if (tb[CHILLI_SESSION_ID]) {
+		count++;
+		strlcpy(req_params.d.sess.sessionid, blobmsg_data(tb[CHILLI_SESSION_ID]),
+				sizeof(req_params.d.sess.sessionid));
+	}
+
+	if (count == 0) {
+		return UBUS_STATUS_INVALID_ARGUMENT;
+	}
+
+	appconn = find_app_conn(&req_params, 0);
+	if (_options.debug) {
+		syslog(LOG_DEBUG, "%s(%d): looking to logout session %s", __FUNCTION__, __LINE__,
+			   inet_ntoa(req_params.ip));
+	}
+
+	if (appconn) {
+		if (_options.debug) {
+			syslog(LOG_DEBUG, "%s(%d): found %s %s", __FUNCTION__, __LINE__,
+				   inet_ntoa(appconn->hisip), appconn->s_state.sessionid);
+		}
+
+		terminate_appconn(appconn, RADIUS_TERMINATE_CAUSE_ADMIN_RESET);
+	}
+
+	return UBUS_STATUS_OK;
+}
+
+static int chilli_forget_method(struct ubus_context *ctx, struct ubus_object *obj,
+								struct ubus_request_data *req, const char *method, struct blob_attr *msg)
+{
+	int ret = UBUS_STATUS_OK;
+	struct blob_attr *tb[CHILLI_FORGET_MAX];
+	uint8_t mac[6];
+
+	blobmsg_parse(chilli_forget_policy, CHILLI_FORGET_MAX,
+				  tb, blob_data(msg), blob_len(msg));
+
+	if (!tb[CHILLI_FORGET_MAC] || parse_mac(mac, blobmsg_data(tb[CHILLI_FORGET_MAC]))) {
+		ret = UBUS_STATUS_INVALID_ARGUMENT;
+		goto end;
+	}
+
+	usr_rm_user(mac);
+	usr_rm_sms_user(mac);
+end:
+	return ret;
+}
+
+void ubus_disconnect_cb(struct ubus_context *ubus)
+{
+	int ret;
+
+	if ((ret = ubus_reconnect(ubus, NULL)))
+	{
+		syslog(LOG_ERR, "Cannot reconnect to UBus: %s", ubus_strerror(ret));
+		ubus_free(ubus);
+	}
+}
+
+void chilli_ubus_add_obj(struct ubus_context *ctx)
+{
+	int ret;
+
+	if ((ret = ubus_add_object(ctx, &chilli_object))) {
+		syslog(LOG_ERR, "Failed to add object: %s", ubus_strerror(ret));
+	}
+
+	ctx->connection_lost = ubus_disconnect_cb;
+}
+
+void chilli_ubus_remove_obj(struct ubus_context *ctx)
+{
+	int ret = ubus_remove_object(ctx, &chilli_object);
+	if (ret) {
+		syslog(LOG_ERR, "Failed to remove object: %s", ubus_strerror(ret));
+	}
+}
+
+// main hostapd event handler.
+// the general approach of using hostapd might be inefficient, as hostapd
+// is kind of a fire hose when it comes to the events it sends out.
+static int hostapd_event_handle(struct ubus_context *ctx, struct ubus_object *obj,
+			struct ubus_request_data *req, const char *method,
+			struct blob_attr *msg)
+{
+
+	// unused vars
+	UNUSED(ctx);
+	UNUSED(obj);
+	UNUSED(req);
+
+	// coova-chilli functionality related vars
+	struct cmdsock_request req_params;
+	struct app_conn_t *appconn = NULL;
+
+	// blobmsg parsing related vars
+	struct blob_attr *cur;
+	int rem;
+
+	// check to see if we're receiving a dissasoc call
+	// from hostapd
+	if (strcmp(method, CHILLI_UBUS_HAP_DISASSOC) != 0) {
+		return UBUS_STATUS_OK;
+	}
+
+	// at this point, we know that we are dealing with data that is
+	// related to a disconnect event
+
+	// this loop is only really concerned with
+	// the first blobvalue of *msg.
+	// which may or may not be our MAC addr
+	blobmsg_for_each_attr(cur, msg, rem) {
+
+		// check if we have field named 'address' (contains our mac addr).
+		// if not, break.
+		if (strcmp(blobmsg_name(cur), CHILLI_UBUS_HAP_ADDR)) {
+			continue;
+		}
+
+		// use the same methods as above to remove the disconnect from coova-chilli
+		// internally.
+		if (parse_mac(req_params.mac, blobmsg_get_string(cur))) {
+			syslog(LOG_ERR, "Unable to parse incoming mac address from hostapd");
+			break;
+		}
+
+		appconn = find_app_conn(&req_params, 0);
+
+		if (_options.debug) {
+			syslog(LOG_DEBUG, "%s(%d): looking to logout session %s", __FUNCTION__, __LINE__,
+				inet_ntoa(req_params.ip));
+		}
+
+		if (!appconn) {
+			break;
+		}
+
+		// at this point we have a valid appconn obj
+
+		if (_options.debug) {
+			syslog(LOG_DEBUG, "%s(%d): found %s %s", __FUNCTION__, __LINE__,
+				   inet_ntoa(appconn->hisip), appconn->s_state.sessionid);
+		}
+
+		terminate_appconn(appconn, RADIUS_TERMINATE_CAUSE_LOST_SERVICE);
+
+		// we can break here since we
+		// got everything we needed out of *msg.
+		break;
+	}
+
+	return UBUS_STATUS_OK;
+}
+
+// tries to subscribe a single *ubus_subscriber and an iface pair to hostapd
+static int chilli_ubus_singlesub_hostapd(struct ubus_context *ctx, struct ubus_subscriber *event, char *iface)
+{
+	// null-check
+	if (iface == NULL || iface[0] == '\0') {
+		syslog(LOG_DEBUG, "%s given null iface argument.", __FUNCTION__);
+		return 1;
+	}
+
+	uint32_t u_obj_id;
+
+	char obj_name_buf[CHILLI_UBUS_OBJ_BUFSIZ];
+
+	// set event handler for ubus_subscriber
+	event->cb = hostapd_event_handle;
+
+	// prepare ubus obj string. i,e take the iface we got and add the hostapd base ubus
+	// obj name and a dot before it
+	snprintf(obj_name_buf, CHILLI_UBUS_OBJ_BUFSIZ, "%s.%s", CHILLI_UBUS_HAP_OBJ, iface);
+
+	// try to look for ubus hostapd obj
+	if (ubus_lookup_id(ctx, obj_name_buf, &u_obj_id)) {
+		syslog(LOG_ERR, "Failed to find ubus object: %s", obj_name_buf);
+		return 1;
+	}
+
+	// try to register ubus subscriber
+	if (ubus_register_subscriber(ctx, event)) {
+		syslog(LOG_ERR, "Failed to register ubus subscriber for %s", obj_name_buf);
+		return 1;
+	}
+
+	// try to subscribe
+	if (ubus_subscribe(ctx, event, u_obj_id) != UBUS_STATUS_OK) {
+		syslog(LOG_ERR, "Failed to subscribe to %s", obj_name_buf);
+		return 1;
+	}
+
+	syslog(LOG_INFO, "Successfully subscribed to %s", obj_name_buf);
+	return 0;
+
+}
+
+
+// function that subscribes to any relevant hostapd ubus objects. This is used to track 
+// Wifi connects/disconnects in order to be able to remove user from session list
+// if they disconnect from the wifi itself.
+void chilli_ubus_subscribe_hostapd(struct ubus_context *ctx, struct options_t options)
+{
+	// NOTE: i know there's the _options global, accessible from here, but having the options be passed
+	// as an argument is better practice, especially for maintainability
+
+
+	// null-check. Something has probably gone very wrong if this gets triggered.
+	if (options.dhcpif == NULL || options.dhcpif[0] == '\0') {
+		syslog(LOG_ERR, "Unable to add hostapd listeners. DHCP iface not set.");
+		return;
+	}
+
+	static struct ubus_subscriber hostapd_event; // ubus subscription object
+
+	// try to subscribe to the hostapd instance of the main iface.
+	// if this fails, move on.
+	chilli_ubus_singlesub_hostapd(ctx, &hostapd_event, options.dhcpif);
+
+	// basically do the same as above, but with the idea that all data of note is stored as arrays
+	#ifdef ENABLE_MULTILAN
+		static struct ubus_subscriber hostapd_multi_events[MAX_MOREIF]; // array of additional ubus sub objs
+
+		// for every additional interface that we got
+		for (int i = 0; i < MAX_MOREIF; i++) {
+			// try to subscribe to additinoal interface, move on if failed.
+			chilli_ubus_singlesub_hostapd(ctx, &hostapd_multi_events[i], options.moreif[i].dhcpif);
+		}
+	#endif
+}
+
+void send_ubus_event(struct ubus_context *ctx, char *state, struct app_conn_t *appconn,
+			struct dhcp_conn_t *dhcpconn)
+{
+	if (!ctx) {
+		return;
+	}
+
+	struct blob_buf b = { 0 };
+	int err = 0;
+
+	blob_buf_init(&b, 0);
+
+	if (appconn) {
+		if (!strcmp(state, CHILLI_EVENT_CONNECT)) {
+			chilli_form_blob(&b, appconn, dhcpconn, FORMAT_TABLE);
+		} else {
+			blobmsg_add_string(&b, "sessionId", appconn->s_state.sessionid);
+		}
+	}
+
+	err = ubus_send_event(ctx, state, b.head);
+	if (err) {
+		syslog(LOG_ERR, "Failed to send ubus event '%s': %s", state, ubus_strerror(err));
+	}
+
+	blob_buf_free(&b);
+}
\ No newline at end of file
diff --recursive --unified --new-file --no-dereference orig/src/ubus.h src/src/ubus.h
--- orig/src/ubus.h	1970-01-01 00:00:00.000000000 +0000
+++ src/src/ubus.h	2024-01-26 11:00:37.000000000 +0000
@@ -0,0 +1,27 @@
+
+#ifndef _CHILLI_UBUS_H
+#define _CHILLI_UBUS_H
+
+#include <libubus.h>
+
+#define CHILLI_UBUS_OBJ_BUFSIZ 50
+
+// various defines for parsing the incoming ubus obj
+#define CHILLI_UBUS_HAP_OBJ "hostapd"
+#define CHILLI_UBUS_HAP_DISASSOC "disassoc"
+#define CHILLI_UBUS_HAP_ADDR "address"
+
+#define UNUSED(x) (void)(x)
+
+#define CHILLI_EVENT_CONNECT "chilli.connect"
+#define CHILLI_EVENT_DISCONNECT "chilli.disconnect"
+
+void chilli_ubus_add_obj(struct ubus_context *ctx);
+void chilli_ubus_remove_obj(struct ubus_context *ctx);
+
+void chilli_ubus_subscribe_hostapd(struct ubus_context *ctx, struct options_t options);
+
+void send_ubus_event(struct ubus_context *ctx, char *state, struct app_conn_t *appconn,
+                        struct dhcp_conn_t *dhcpconn);
+
+#endif //_CHILLI_UBUS_H
diff --recursive --unified --new-file --no-dereference orig/src/users.c src/src/users.c
--- orig/src/users.c	1970-01-01 00:00:00.000000000 +0000
+++ src/src/users.c	2024-01-26 11:00:37.000000000 +0000
@@ -0,0 +1,510 @@
+#include "chilli.h"
+#include <uci.h>
+#include <libtlt_uci.h>
+#ifdef ENABLE_GSM
+#include "gsm.h"
+#endif
+
+static int rm_user(char * table, uint8_t * mac);
+
+/*!
+ * Generate a n octet random string
+ * @param dst The memory area to copy to
+ * @param size The number of bytes to copy
+ * @return 0 on success, -1 on fail.
+ */
+
+int usr_random_hex(char *dst, size_t size)
+{
+	size_t i = 0;
+	int c;
+	char x[3];
+	FILE *file;
+
+	if ((file = fopen("/dev/urandom", "r")) == NULL) {
+		syslog(LOG_ERR, "%s: fopen(/dev/urandom)", strerror(errno));
+		return -1;
+	}
+
+	for (i=0; i <= size-2; i++){
+		c = fgetc(file);
+		snprintf(x, 3, "%.2x", c);
+		dst[i++] = x[0];
+		dst[i] = x[1];
+	}
+
+	dst[size] = 0;
+
+	fclose(file);
+	return 0;
+}
+
+int usr_runscript(struct redir_conn_t *conn, char* script,
+		char *username, char *password) {
+	int status;
+	uint32_t sessiontime;
+
+	if ((status = chilli_fork(CHILLI_PROC_SCRIPT, script)) < 0) {
+		syslog(LOG_ERR, "%s: forking %s", strerror(errno), script);
+		return 0;
+	}
+
+	if (status > 0) { /* Parent */
+		return 0;
+	}
+
+	set_env("DEV", VAL_STRING, tun(tun, 0).devname, 0);
+	set_env("ADDR", VAL_IN_ADDR, &conn->ourip, 0);
+	set_env("FRAMED_IP_ADDRESS", VAL_IN_ADDR, &conn->hisip, 0);
+	set_env("SESSION_TIMEOUT", VAL_ULONG64, &conn->s_params.sessiontimeout, 0);
+	set_env("IDLE_TIMEOUT", VAL_ULONG, &conn->s_params.idletimeout, 0);
+	set_env("CALLING_STATION_ID", VAL_MAC_ADDR, conn->hismac, 0);
+	set_env("CALLED_STATION_ID", VAL_MAC_ADDR, chilli_called_station(&conn->s_state), 0);
+	set_env("WISPR_BANDWIDTH_MAX_UP", VAL_ULONG, &conn->s_params.bandwidthmaxup, 0);
+	set_env("WISPR_BANDWIDTH_MAX_DOWN", VAL_ULONG, &conn->s_params.bandwidthmaxdown, 0);
+	set_env("COOVACHILLI_MAX_INPUT_OCTETS", VAL_ULONG64, &conn->s_params.maxinputoctets, 0);
+	set_env("COOVACHILLI_MAX_OUTPUT_OCTETS", VAL_ULONG64, &conn->s_params.maxoutputoctets, 0);
+	set_env("COOVACHILLI_MAX_TOTAL_OCTETS", VAL_ULONG64, &conn->s_params.maxtotaloctets, 0);
+	set_env("COOVACHILLI_WARNING_OCTETS", VAL_ULONG64, &conn->s_params.warningoctets, 0);
+
+	sessiontime = mainclock_diffu(conn->s_state.start_time);
+	set_env("SESSION_TIME", VAL_ULONG, &sessiontime, 0);
+	sessiontime = mainclock_diffu(conn->s_state.last_up_time);
+	set_env("IDLE_TIME", VAL_ULONG, &sessiontime, 0);
+	set_env("USER_EXPIRATION_TIME", VAL_ULONG64, &conn->s_params.expiration, 0);
+	set_env("PHONE", VAL_STRING, &conn->s_state.redir.phone, 0);
+	set_env("EMAIL", VAL_STRING, &conn->s_state.redir.email, 0);
+
+	if (username) {
+		set_env("USER_NAME", VAL_STRING, username, 0);
+	}
+	if (_options.smsusers) {
+		if (password)
+			set_env("PASSWORD", VAL_STRING, password, 0);
+#ifdef ENABLE_GSM
+		if (_options.modemid)
+			set_env("MODEM_ID", VAL_STRING, _options.modemid, 0);
+#endif
+	}
+
+	if (execl(
+#ifdef ENABLE_CHILLISCRIPT
+			SBINDIR "/chilli_script", SBINDIR "/chilli_script", _options.binconfig,
+#else
+			script,
+#endif
+			script, (char *) 0) != 0) {
+		syslog(LOG_ERR, "%s: exec %s failed", strerror(errno), script);
+	}
+
+	exit(0);
+}
+
+int usr_gen_message(char *msg, char *password)
+{
+	time_t now;
+
+	if (_options.dynexpirationtime) {
+		time(&now);
+		now += _options.dynexpirationtime;
+	}
+
+	sprintf(msg, MSG_FMT, password, _options.dynexpirationtime ? ctime(&now) : "unlimited");
+
+	return 0;
+}
+
+int _select_callback(void *str_user, int argc, char **argv, char **azColName)
+{
+	struct str_user *p_str_user = (struct str_user *)str_user;
+
+	if (argc > 0) {
+		strncpy(p_str_user->username, argv[COL_USER_NAME], USER_USERNAMENAMESIZE);
+		p_str_user->username[USER_USERNAMENAMESIZE] = 0;
+		strncpy(p_str_user->email, argv[COL_USER_EMAIL], USER_EMAILSIZE);
+		p_str_user->email[USER_EMAILSIZE] = 0;
+		strncpy(p_str_user->password, argv[COL_USER_PASS], USER_PASSWORDSIZE);
+		p_str_user->password[USER_PASSWORDSIZE] = 0;
+		strncpy(p_str_user->phone, argv[COL_USER_PHONE], USER_PHONESIZE);
+		p_str_user->phone[USER_PHONESIZE] = 0;
+		p_str_user->expiration = argv[COL_USER_EXPIRATION] ? strtol(argv[COL_USER_EXPIRATION], NULL, 0) : 0;
+		p_str_user->user_time = argv[COL_USER_TIME] ? strtol(argv[COL_USER_TIME], NULL, 0) : 0;
+	}
+
+	return SQL_SUCCESS;
+}
+
+int usr_user_expired (sqlite3 *db, char *email, uint8_t *mac)
+{
+	int ret = USER_RET_SUCCESS;
+	char *sql;
+	sqlite3_stmt *stmt;
+
+	asprintf(&sql, SELECT_NOT_EXPIRED_EMAIL_FMT, "users", email, MAC_ARG(mac));
+	if (_options.debug)
+		syslog(LOG_INFO, "[%s] SQL: %s", __FUNCTION__ , sql);
+
+	ret = sqlite3_prepare_v2(db, sql, -1, &stmt, 0);
+	if (ret != SQLITE_OK) {
+		syslog(LOG_INFO, "[%s] SQL error: %s", __FUNCTION__ , sqlite3_errmsg(db));
+		ret = USER_RET_ERROR;
+		goto out;
+	}
+
+	if (sqlite3_step(stmt) == SQLITE_ROW)
+		if (sqlite3_column_int(stmt, 0) > 0)
+			ret = USER_RET_ALREADY;
+
+	sqlite3_finalize(stmt);
+
+out:
+	free(sql);
+
+	return ret;
+}
+
+int usr_get_user (sqlite3 *db, struct str_user *user, char *email)
+{
+	int ret;
+	char *sql;
+	char *err = 0;
+
+	asprintf(&sql, SELECT_USER_FMT, email);
+	if (_options.debug)
+		syslog(LOG_INFO, "[%s] SQL: %s", __FUNCTION__ , sql);
+
+	ret = sqlite3_exec(db, sql, _select_callback, user, &err);
+	if (ret){
+		syslog(LOG_INFO, "[%s] SQL error: %s\n", __FUNCTION__, err);
+		sqlite3_free(err);
+		free(sql);
+
+		return SQL_FAIL;
+	}
+
+	free(sql);
+
+	return SQL_SUCCESS;
+}
+
+int usr_update_user_pwd (sqlite3 *db, struct str_user *user, char *email, char *new_passw)
+{
+	#ifndef HAVE_OPENSSL
+	return SQL_FAIL;
+	#endif
+	char *new_passw_hash = hash_sha512(new_passw);
+	int ret;
+	char *sql;
+	char *err = 0;
+
+	asprintf(&sql, UPDATE_USR_PWD, new_passw_hash, email);
+	if (_options.debug)
+		syslog(LOG_INFO, "[%s] SQL: %s", __FUNCTION__ , sql);
+
+	ret = sqlite3_exec(db, sql, _select_callback, user, &err);
+	if (ret){
+		syslog(LOG_INFO, "[%s] SQL error: %s\n", __FUNCTION__, err);
+		sqlite3_free(err);
+		free(sql);
+		free(new_passw_hash);
+
+		return SQL_FAIL;
+	}
+
+	free(sql);
+	free(new_passw_hash);
+
+	return SQL_SUCCESS;
+}
+
+int ubus_uci_reload ()
+{
+	int ret = USER_RET_SUCCESS;
+	uint32_t uci_id = 0;
+	struct ubus_context *ctx;
+
+	ctx = ubus_connect(NULL);
+	if (!ctx) {
+		syslog(LOG_INFO, "[%s] failed to connect to ubus\n", __FUNCTION__);
+		return USER_RET_ERROR;
+	}
+
+	if (ubus_lookup_id(ctx, "uci", &uci_id) ||
+	    	ubus_invoke(ctx, uci_id, "reload_config", NULL, NULL, NULL, 3000)) {
+		syslog(LOG_INFO, "[%s] ubus request failed\n", __FUNCTION__);
+		ret = USER_RET_ERROR;
+	}
+
+	ubus_free(ctx);
+	return ret;
+}
+
+int usr_update_user_pwd_uci (char username[256], char password[256], char *new_password)
+{
+	struct uci_context *uci = uci_alloc_context();
+	if (!uci) {
+		return 1;
+	}
+
+	struct uci_package *uci_chilli = NULL;
+	if (uci_load(uci, "chilli", &uci_chilli)) {
+		uci_cleanup(uci);
+		return 1;
+	}
+
+	struct uci_element *e = NULL;
+	uci_foreach_element (&uci_chilli->sections, e) {
+		struct uci_section *s = uci_to_section(e);
+		if (!s->type || strcmp(s->type, "user")) {
+			continue;
+		}
+
+		char *username_uci = ucix_get_option(uci, "chilli", s->e.name, "username");
+		if (!username_uci) {
+			continue;
+		}
+
+		char *password_uci = ucix_get_option(uci, "chilli", s->e.name, "password");
+		if (!password_uci) {
+			continue;
+		}
+
+		if (!strncmp(username_uci, username, strlen(username)) && !strncmp(password_uci, password, strlen(password))) {
+			ucix_add_option(uci, "chilli", s->e.name, "password", new_password);
+		}
+
+		free(username_uci);
+		free(password_uci);
+	}
+
+	ucix_commit(uci, "chilli");
+	uci_cleanup(uci);
+	ubus_uci_reload();
+
+	return 0;
+}
+
+int usr_add_user (struct redir_conn_t *conn)
+{
+	sqlite3 *db;
+	char *sql = NULL;
+	int ret	  = USER_RET_ERROR;
+	char username[USER_USERNAMENAMESIZE + 1];
+
+	if (!_options.usersdbpath || !(db = sqlopen(_options.usersdbpath))) {
+		conn->response = REDIR_SIGNUP_FAILED;
+		return USER_RET_ERROR;
+	}
+
+	if ((ret = usr_user_expired(db, conn->s_state.redir.email, conn->hismac)) != USER_RET_SUCCESS) {
+		if (ret == USER_RET_ALREADY)
+			conn->response = REDIR_SIGNUP_ALREADY;
+		else
+			conn->response = REDIR_SIGNUP_FAILED;
+
+		goto out;
+	}
+
+	if (usr_random_hex(username, USER_RAND_USERNAME_LEN)) {
+		ret = USER_RET_ERROR;
+		goto out;
+	}
+
+	asprintf(&sql, INSERT_USERS_FMT, username, conn->s_state.redir.email,
+		 conn->s_state.redir.signup_password, MAC_ARG(conn->hismac), 
+		 conn->s_state.redir.phone, _options.dynexpirationtime);
+
+	if (_options.debug)
+		syslog(LOG_INFO, "[%s] SQL: %s", __FUNCTION__, sql);
+
+	if (!sqlexec(db, sql, NULL)) {
+		conn->response = REDIR_SIGNUP_SUCCESS;
+		ret	       = USER_RET_SUCCESS;
+		if (_options.usersignup && !(conn->s_params.flags & NO_SCRIPT)) {
+			if (_options.debug)
+				syslog(LOG_DEBUG, "%s(%d): Calling user signup script: %s\n", __FUNCTION__, __LINE__,
+				       _options.usersignup);
+
+			usr_runscript(conn, _options.usersignup, conn->s_state.redir.email, NULL);
+		}
+	} else {
+		ret = USER_RET_ERROR;
+	}
+
+	free(sql);
+out:
+	sqlclose(db);
+
+	return ret;
+}
+
+int _sms_select_callback (void *str_user, int argc, char **argv, char **azColName)
+{
+	struct str_sms_user *p_str_user = (struct str_sms_user *)str_user;
+
+	if (argc > 0) {
+		strncpy(p_str_user->username, argv[COL_SMS_USER_NAME], USER_RAND_USERNAME_LEN);
+		p_str_user->username[USER_RAND_USERNAME_LEN] = 0;
+		strncpy(p_str_user->password, argv[COL_SMS_USER_PASS], USER_RAND_PASSWORD_LEN);
+		p_str_user->password[USER_RAND_PASSWORD_LEN] = 0;
+		strncpy(p_str_user->phone, argv[COL_SMS_USER_PHONE], USER_PHONESIZE);
+		p_str_user->phone[USER_PHONESIZE] = 0;
+		p_str_user->expiration = argv[COL_SMS_USER_EXPIRATION] ? strtol(argv[COL_SMS_USER_EXPIRATION], NULL, 0) : 0;
+		p_str_user->user_time = argv[COL_SMS_USER_TIME] ? strtol(argv[COL_SMS_USER_TIME], NULL, 0) : 0;
+	}
+
+	return SQL_SUCCESS;
+}
+
+int usr_get_sms_user (sqlite3 *db, struct str_sms_user *user, char * password)
+{
+	int ret;
+	char *sql;
+	char *err = 0;
+
+	asprintf(&sql, SELECT_SMS_USER_FMT, password);
+	if (_options.debug)
+		syslog(LOG_INFO, "[%s] SQL: %s", __FUNCTION__ , sql);
+
+	ret = sqlite3_exec(db, sql, _sms_select_callback, user, &err);
+	if (ret){
+		syslog(LOG_INFO, "[%s] SQL error: %s\n", __FUNCTION__, err);
+		sqlite3_free(err);
+		free(sql);
+
+		return SQL_FAIL;
+	}
+
+	free(sql);
+
+	return SQL_SUCCESS;
+}
+
+int usr_sms_user_exists (sqlite3 *db, char *phone, uint8_t *mac)
+{
+	int ret = USER_RET_ERROR;
+	char *sql;
+	sqlite3_stmt *stmt;
+
+	if (phone != NULL && mac != NULL)
+		asprintf(&sql, SELECT_NOT_EXPIRED_FMT, "sms_users", phone, MAC_ARG(mac));
+	else if (mac != NULL)
+		asprintf(&sql, SELECT_NOT_EXPIRED_MAC_FMT, "sms_users", MAC_ARG(mac));
+	else
+		goto out;
+
+	if (_options.debug)
+		syslog(LOG_INFO, "[%s] SQL: %s", __FUNCTION__ , sql);
+
+	if (sqlite3_prepare_v2(db, sql, -1, &stmt, 0) != SQLITE_OK) {
+		syslog(LOG_INFO, "[%s] SQL error: %s", __FUNCTION__ , sqlite3_errmsg(db));
+		goto out;
+	}
+
+	if (sqlite3_step(stmt) == SQLITE_ROW)
+		ret = sqlite3_column_int(stmt, 0) > 0 ? USER_RET_ALREADY : USER_RET_SUCCESS;
+
+	sqlite3_finalize(stmt);
+
+out:
+	free(sql);
+
+	return ret;
+}
+
+int usr_add_sms_user (struct redir_conn_t *conn, char *phone, char *hexchall)
+{
+	sqlite3 *db;
+	char *sql = NULL;
+	int ret = USER_RET_ERROR;
+	char username[USER_RAND_USERNAME_LEN + 1], password[USER_RAND_PASSWORD_LEN + 1];
+
+	if (!_options.usersdbpath || !(db = sqlopen(_options.usersdbpath)))
+		return USER_RET_ERROR;
+
+	if ((ret = usr_sms_user_exists(db, phone, conn->hismac)) != USER_RET_SUCCESS) {
+		syslog(LOG_DEBUG, "user already exists: %d\n", ret);
+		goto out;
+	}
+
+	if (usr_random_hex(username, USER_RAND_USERNAME_LEN) ||
+			usr_random_hex(password, USER_RAND_PASSWORD_LEN))
+	{
+		ret = USER_RET_ERROR;
+		goto out;
+	}
+
+	asprintf(&sql, INSERT_SMS_USERS_FMT, phone, password, MAC_ARG(conn->hismac),
+			 phone, _options.dynexpirationtime);
+	if (_options.debug)
+		syslog(LOG_INFO, "[%s] SQL: %s", __FUNCTION__ , sql);
+
+	if (!sqlexec(db, sql, NULL)) {
+		ret = USER_RET_SUCCESS;
+#ifdef ENABLE_GSM
+		char message[USER_MAX_MESSAGE_SIZE];
+
+		usr_gen_message(message, password);
+        
+		if (chilli_send_sms(phone, message, _options.modemid) != CHILLI_GSM_OK) {
+			usr_rm_sms_user(conn->hismac);
+			ret = USER_RET_SMS_ERR;
+		}
+#endif
+		if (ret == USER_RET_SUCCESS && _options.usersignup && !(conn->s_params.flags & NO_SCRIPT)) {
+			if (_options.debug)
+				syslog(LOG_DEBUG, "%s(%d): Calling user signup script: %s\n",
+					   __FUNCTION__, __LINE__, _options.usersignup);
+
+			usr_runscript(conn, _options.usersignup, username, password);
+		}
+	}
+	else {
+		ret = USER_RET_ERROR;
+	}
+
+	free(sql);
+out:
+	sqlclose(db);
+
+	return ret;
+}
+
+static int rm_user(char * table, uint8_t * mac) {
+	sqlite3 *db;
+	char *sql = NULL;
+	int ret = USER_RET_SUCCESS;
+
+	if (!_options.usersdbpath || !(db = sqlopen(_options.usersdbpath))) {
+		ret = USER_RET_ERROR;
+		goto end;
+	}
+
+	asprintf(&sql, DELETE_USER_FMT, table, MAC_ARG(mac));
+	if (_options.debug) 
+	{
+		syslog(LOG_INFO, "[%s] SQL: %s", __FUNCTION__ , sql);
+	}
+
+	if (sqlexec(db, sql, NULL)) {
+		ret = USER_RET_ERROR;
+	}
+
+	free(sql);
+	sqlclose(db);
+end:
+	return ret;
+}
+
+int usr_rm_user(uint8_t * mac) {
+	return rm_user("users", mac);
+}
+
+int usr_rm_sms_user(uint8_t * mac) {
+	return rm_user("sms_users", mac);
+}
+
+int usr_get(char *username)
+{
+	return 0;
+}
diff --recursive --unified --new-file --no-dereference orig/src/users.h src/src/users.h
--- orig/src/users.h	1970-01-01 00:00:00.000000000 +0000
+++ src/src/users.h	2024-01-26 11:00:37.000000000 +0000
@@ -0,0 +1,113 @@
+
+#ifndef RUTX_USERS_H
+#define RUTX_USERS_H
+
+#define USER_MIN_PHONE_LEN 6
+
+#define USER_USERNAMENAMESIZE 128
+#define USER_PASSWORDSIZE 128
+#define USER_PHONESIZE 64
+#define USER_EMAILSIZE 128
+
+#define USER_RAND_USERNAME_LEN 16
+#define USER_RAND_PASSWORD_LEN 6
+
+#define USER_RET_SUCCESS 0
+#define USER_RET_ERROR 1
+#define USER_RET_ALREADY 2
+#define USER_RET_SMS_ERR 3
+
+#define USER_MAX_MESSAGE_SIZE 128
+
+enum {
+	COL_SMS_USER_ID = 0,
+	COL_SMS_USER_NAME,
+	COL_SMS_USER_PASS,
+	COL_SMS_USER_MAC,
+	COL_SMS_USER_PHONE,
+	COL_SMS_USER_CREATED,
+	COL_SMS_USER_EXPIRATION,
+	COL_SMS_USER_TIME,
+};
+
+enum {
+	COL_USER_ID = 0,
+	COL_USER_NAME,
+	COL_USER_EMAIL,
+	COL_USER_PASS,
+	COL_USER_MAC,
+	COL_USER_PHONE,
+	COL_USER_CREATED,
+	COL_USER_EXPIRATION,
+	COL_USER_TIME,
+};
+
+
+#define INSERT_SMS_USERS_FMT "INSERT INTO sms_users (username, password, mac, phone," \
+			" expiration) VALUES ('%s', '%s', '"MAC_FMT"', '%s', '%"PRId64"');"
+
+#define NOT_EXPIRED_FMT "((strftime('%%s','now') - strftime('%%s', created)) < expiration" \
+			" OR expiration = '0')"
+
+#define LIMIT_FMT " ORDER BY id DESC limit 1"
+
+#define UPDATE_USR_PWD "UPDATE users SET password='%s' \
+			WHERE ("NOT_EXPIRED_FMT" AND email = '%s');"
+
+#define USER_TIME_FMT "(strftime('%%s','now') - strftime('%%s', created)) AS user_time"
+
+//Cont all unexpired users with corresponding phone number
+#define SELECT_NOT_EXPIRED_FMT "SELECT COUNT(*) from %s" \
+			" WHERE ("NOT_EXPIRED_FMT" AND (phone = '%s' OR mac = '"MAC_FMT"'));"
+
+//Cont all unexpired users with corresponding mac
+#define SELECT_NOT_EXPIRED_MAC_FMT "SELECT COUNT(*) from %s" \
+			" WHERE ("NOT_EXPIRED_FMT" AND mac = '"MAC_FMT"');"
+
+#define SELECT_NOT_EXPIRED_EMAIL_FMT "SELECT COUNT(*) from %s" \
+			" WHERE ("NOT_EXPIRED_FMT" AND (email = '%s' OR mac = '"MAC_FMT"'));"
+
+#define SELECT_SMS_USER_FMT "SELECT *, "USER_TIME_FMT"  FROM sms_users" \
+			" WHERE ("NOT_EXPIRED_FMT" AND password = '%s')"LIMIT_FMT";"
+
+
+#define INSERT_USERS_FMT "INSERT INTO users (username, email, password, mac, phone," \
+			" expiration) VALUES ('%s', '%s', '%s', '"MAC_FMT"', '%s', '%"PRId64"');"
+
+#define SELECT_USER_FMT "SELECT *, "USER_TIME_FMT" FROM users " \
+			"WHERE ("NOT_EXPIRED_FMT" AND email = '%s')"LIMIT_FMT";"
+
+#define DELETE_USER_FMT "DELETE FROM %s WHERE (mac = '"MAC_FMT"');"
+
+#define MSG_FMT "Password - %s, expiration time - %s"
+
+struct str_sms_user {
+	char username[USER_RAND_USERNAME_LEN + 1];
+	char password[USER_RAND_PASSWORD_LEN + 1];
+	char phone[USER_PHONESIZE + 1];
+	uint32_t expiration;
+	uint32_t user_time;
+};
+
+struct str_user {
+	char username[USER_USERNAMENAMESIZE + 1];
+	char email[USER_EMAILSIZE + 1];
+	char password[USER_PASSWORDSIZE + 1];
+	char phone[USER_PHONESIZE + 1];
+	uint32_t expiration;
+	uint32_t user_time;
+};
+
+int usr_get_user (sqlite3 *db, struct str_user *user, char *email);
+int usr_update_user_pwd(sqlite3 *db, struct str_user *user, char *email, char *new_passw);
+int usr_update_user_pwd_uci(char username[256], char passw[256], char *new_passw);
+int usr_add_user(struct redir_conn_t *conn);
+
+int usr_get_sms_user(sqlite3 *db, struct str_sms_user *user, char *password);
+int usr_add_sms_user(struct redir_conn_t *conn, char *phone, char *hexchall);
+int usr_sms_user_exists(sqlite3 *db, char *phone, uint8_t *mac);
+
+int usr_rm_user(uint8_t * mac);
+int usr_rm_sms_user(uint8_t * mac);
+
+#endif //RUTX_USERS_H
diff --recursive --unified --new-file --no-dereference orig/src/util.c src/src/util.c
--- orig/src/util.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/util.c	2024-01-26 11:00:37.000000000 +0000
@@ -117,6 +117,54 @@
   return 0;
 }
 
+int bstrtocstr(bstring src, char *dst, unsigned int len) {
+	if (!src || src->slen == 0) {
+		dst[0] = 0;
+		return 0;
+	}
+
+	strlcpy(dst, (char*)src->data, len);
+	return 0;
+}
+
+int bescape_str(bstring src, bstring dst) {
+  int n;
+
+  bassigncstr(dst, "");
+  for (n=0; n < src->slen; n++)
+    if ('\'' != src->data[n] && src->data[n] != '"' &&
+        '\\' != src->data[n]) {
+      bconchar(dst,src->data[n]);
+    }
+
+  return 0;
+}
+
+int escape_cstr(char *src, char *dst) {
+  int i = 0;
+  int n;
+
+  for (n = 0; n < strlen(src); n++)
+    if ('\'' != src[n] && src[n] != '"' &&
+        '\\' != src[n]) {
+      dst[i++] = src[n];
+    }
+
+  dst[i] = 0;
+
+  return 0;
+}
+
+int besc_strtocstr(bstring src, char *dst, unsigned int len) {
+  bstring dst_bt = bfromcstr("");
+
+  bescape_str(src, dst_bt);
+  bstrtocstr(dst_bt, dst, len);
+  bdestroy(dst_bt);
+
+  return 0;
+}
+
 
 /* This file is free software; you can redistribute it and/or modify */
 /* it under the terms of the GNU General Public License as published by */
