/*
 * Copyright 2010-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 */

/*eslint no-restricted-properties: 0*/
exports.BackoffRetry = class BackoffRetry {
    /**
     *
     * @param taskToTry - The function that will be wrapped in an exponential backoff retry handler. This function MUST
     *  satisfy a few requirements in order to be usable by BackoffRetry:
     *  1. taskToTry must follow the standard JS practice of setting the last argument in its argument list to be a callback.
     *  2. taskToTry's last argument, the callback mentioned above, must have its first parameter be an error (again a
     *     standard JS practice). The error will be used to determine if taskToTry was a success or failure. If the
     *     error is set, then BackoffRetry will retry taskToTry.
     * @param thisArg - The 'this' that taskToTry should execute with
     * @param errorCallback - In case of an error during retries, errorCallback will be called with the error right before the retry
     * @param multiplier - The initial wait duration for the first retry.
     * @param backoffCoefficient - the base value for exponential retry.
     * @param maxDelay - The maximum amount of time to wait per try.
     * @param maxAttempts - This method will retry up to this value.
     * @param expirationDuration - the maximum amount of time retry can wait.
     * @param enableJitter - Setting this to true will add jitter.
     */
    constructor(taskToTry, thisArg, errorCallback, multiplier, backoffCoefficient, maxDelay, maxAttempts, expirationDuration, enableJitter) {
        this._taskName = taskToTry.name;
        this.thisArg = thisArg;
        this.errorCallback = errorCallback;

        const backoffRetry = this; // Store 'this' for use in _wrappedTaskToTry below

        // _wrappedTaskToTry extracts taskToTry's callback (the last parameter of taskToTry) and wraps it in logic that
        // will retry taskToTry in case of an error.
        this._wrappedTaskToTry = function wrappedTaskToTry() {
            // Store the arguments provided to taskToTry.
            const taskToTryArguments = Array.from(arguments);

            // Extract the callback from the arguments provided to taskToTry
            const taskToTryCallback = taskToTryArguments[taskToTryArguments.length - 1];

            // Wrap the callback provided to taskToTry in retry logic that inspects if the callback was provided an error
            // object or not. We assume the callback is following the standard practice of the first argument being an error object.
            function wrappedTaskToTryCallback(error) {
                // Save the time we are called so we can know how long to wait if called again in the future.
                backoffRetry._lastCallTime = Date.now();

                // Save the arguments provided to taskToTry's callback
                const taskToTryCallbackArguments = Array.from(arguments);

                if (error) {
                    // If there was an error, call the provided callback with it and try again
                    errorCallback(error);
                    backoffRetry._retryOrThrowError(...taskToTryArguments);
                } else {
                    // If there wasn't an error, go call taskToTry's callback, we are done here.
                    taskToTryCallback.apply(thisArg, taskToTryCallbackArguments);
                }
            }

            // Call taskToTry with the wrapped callback
            taskToTry.apply(thisArg, taskToTryArguments.slice(0, -1).concat([wrappedTaskToTryCallback]));
        };

        this._multiplier = multiplier;
        this._backoffCoefficient = backoffCoefficient;
        this._maxDelay = maxDelay;
        this._maxAttempts = maxAttempts;
        this._expirationDuration = expirationDuration;
        this._enableJitter = enableJitter;

        this._lastCallTime = Date.now();
        this._totalWaitTimeMillis = 0;
        this._tryCount = 0;

        // tryOrThrowError is the method used to start the attempt and retry task
        this.tryOrThrowError = this._attemptTaskWithRetry.bind(this);
    }

    /*
    _attemptTaskWithRetry will immediately attempt _wrappedTaskToTry which will try
    to execute taskToTry. On failure, _wrappedTaskToTry will call _retryOrThrowError which
    handles the retry logic
    */
    _attemptTaskWithRetry() {
        setImmediate(() => this._wrappedTaskToTry.apply(this.thisArg, arguments));
    }

    /*
    _retryOrThrowError will execute the taskToTry after a certain duration calculated by how many times _retryOrThrowError has
    been called since the creation of this object, following an exponential backoff algorithm. It should be called with
    the same arguments you provide to taskToTry, they will be proxied to the underlying call to taskToTry.
     */
    _retryOrThrowError() {
        if (this._tryCount >= this._maxAttempts) {
            throw new Error(`Retry handler for ${this._taskName} exceeded max attempt count during retries.`);
        }

        const jitter = this._enableJitter ? Math.random() : 1;
        const waitTimeMillis = Math.min(this._maxDelay, this._multiplier * Math.pow(this._backoffCoefficient, this._tryCount)) * jitter;

        if (this._totalWaitTimeMillis + waitTimeMillis > this._expirationDuration) {
            throw new Error(`Retry handler for ${this._taskName} exceeded max timeout during retries.`);
        }

        this._totalWaitTimeMillis += waitTimeMillis;
        this._tryCount += 1;

        // If adjustedWaitTimeMillis is less than 1 (including negative values), the timeout will be for only 1 millisecond
        const adjustedWaitTimeMillis = (this._lastCallTime + waitTimeMillis) - Date.now();
        setTimeout(() => this._wrappedTaskToTry.apply(this.thisArg, arguments), adjustedWaitTimeMillis);
    }
};
