/*
 * Copyright 2010-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 */

const http = require('http');
const util = require('util');
const { logging } = require('aws-greengrass-common-js');
const { config, envVars } = require('aws-greengrass-common-js');

// declare this variable as let then assign to pass lint and test which overrides
let runtimeLogger = null;
runtimeLogger = new logging.LocalWatchLogger('/GreengrassSystem/node_runtime', 'fromNodeAppender');

const Event = 'Event';
const RequestResponse = 'RequestResponse';

const DEFAULT_IPC_VERSION = '2016-11-01';
const HEADER_INVOCATION_ID = 'x-amz-invocationid';
const HEADER_CLIENT_CONTEXT = 'x-amz-client-context';
const HEADER_AUTH_TOKEN = 'authorization';
const HEADER_INVOCATION_TYPE = 'x-amz-invocation-type';
const HEADER_FUNCTION_ERR_TYPE = 'x-amz-function-error';

function getRequestPath(functionArn) {
    return util.format('/%s/functions/%s', DEFAULT_IPC_VERSION, functionArn);
}

function getWorkRequestPath(functionArn) {
    return util.format('%s/work', getRequestPath(functionArn));
}

class IPCClient {
    /**
     * @param authToken {string}
     * @param host {string | undefined} If undefined, DEFAULT_HOST is used.
     * @param port {undefined} - Deprecated. Will not be used.
     */
    constructor(authToken, host, port) {
        this._authToken = authToken;
        this._host = host !== undefined ? host : config.DEFAULT_HOST;
        this._port = parseInt(envVars.GG_DAEMON_PORT, 10);
        this._httpAgent = config.DEFAULT_HTTP_AGENT;

        if (port !== undefined) {
            IPCClient.logErrorMessage(
                'port parameter is deprecated and will not be used'
            );
        }
    }

    getWork(functionArn, callback) {
        const path = getWorkRequestPath(functionArn);
        const options = {
            host: this._host,
            port: this._port,
            path: path,
            headers: {
                [HEADER_AUTH_TOKEN]: this._authToken,
            },
            agent: this._httpAgent,
        };

        runtimeLogger.info(`Getting work for function [${functionArn}] from ${path}`);

        let body = '';
        http.get(options, (res) => {
            const invocationId = res.headers[HEADER_INVOCATION_ID];
            const clientContext = res.headers[HEADER_CLIENT_CONTEXT];
            if (res.statusCode !== 200) {
                res.on('data', (chunk) => {
                    IPCClient.logErrorMessage(res, chunk, 'GetWork returned HTTP with status code', callback);
                });
                return;
            }

            runtimeLogger.info(`Got work item with invocation id [${invocationId}]`);
            res.on('data', (chunk) => { body += chunk; });
            res.on('end', () => callback(undefined, body, invocationId, clientContext));
        }).on('error', (e) => {
            runtimeLogger.error(`Failed to get work: ${e}`);
            callback(e);
        });
    }

    postWork(functionArn, inputBytes, clientContext, invocationType, callback) {
        if (invocationType !== Event && invocationType !== RequestResponse) {
            callback(new Error(`InvocationType '${invocationType}' is incorrect, should be ${Event} or ${RequestResponse}`));
            return;
        }

        const path = getRequestPath(functionArn);
        const options = {
            method: 'POST',
            host: this._host,
            port: this._port,
            path: path,
            headers: {
                [HEADER_AUTH_TOKEN]: this._authToken,
                [HEADER_CLIENT_CONTEXT]: clientContext,
                [HEADER_INVOCATION_TYPE]: invocationType,
            },
            agent: this._httpAgent,
        };

        runtimeLogger.info(`Posting work for function [${functionArn}] to ${path}`);

        const req = http.request(options, (res) => {
            if ((invocationType === Event && res.statusCode !== 202) || (invocationType === RequestResponse && res.statusCode !== 200)) {
                res.on('data', (chunk) => {
                    IPCClient.logErrorMessage(res, chunk, `PostWork returned HTTP with invocation type ${invocationType} status code`, callback);
                });
                return;
            }

            const invocationId = res.headers[HEADER_INVOCATION_ID];
            runtimeLogger.info(`Work posted with invocation ID [${invocationId}]`);

            res.on('data', () => {}); // TODO any better way to do this? If we don't include it, the 'end' event will never trigger
            res.on('end', () => callback(undefined, invocationId));
        }).on('error', (e) => {
            runtimeLogger.error(`Failed to post work: ${e}`);
            callback(e);
        });

        req.write(inputBytes);
        req.end();
    }

    getWorkResult(functionArn, invocationId, callback) {
        const path = getRequestPath(functionArn);
        const options = {
            host: this._host,
            port: this._port,
            path: path,
            headers: {
                [HEADER_AUTH_TOKEN]: this._authToken,
                [HEADER_INVOCATION_ID]: invocationId,
            },
            agent: this._httpAgent,
        };

        runtimeLogger.info(`Getting work result for invocation id [${invocationId}] from ${path}`);
        let body = '';
        http.get(options, (res) => {
            if (res.statusCode !== 200) {
                res.on('data', (chunk) => {
                    IPCClient.logErrorMessage(res, chunk, 'GetWorkResult returned HTTP with status code', callback);
                });
                return;
            }

            runtimeLogger.info(`Got result for invocation id [${invocationId}]`);
            const functionErr = res.headers[HEADER_FUNCTION_ERR_TYPE];
            res.on('data', (chunk) => { body += chunk; });
            res.on('end', () => callback(undefined, body, functionErr, res.statusCode));
        }).on('error', (e) => {
            runtimeLogger.error(`Failed to get work result: ${e}`);
            callback(e);
        });
    }

    postWorkResult(functionArn, resultBytes, invocationId, callback) {
        const path = getWorkRequestPath(functionArn);
        const options = {
            method: 'POST',
            host: this._host,
            port: this._port,
            path: path,
            headers: {
                [HEADER_AUTH_TOKEN]: this._authToken,
                [HEADER_INVOCATION_ID]: invocationId,
            },
            agent: this._httpAgent,
        };

        runtimeLogger.info(`Posting work result for invocation id [${invocationId}] to ${path}`);

        const req = http.request(options, (res) => {
            if (res.statusCode !== 200) {
                res.on('data', (chunk) => {
                    IPCClient.logErrorMessage(res, chunk, 'PostWorkResult returned HTTP with status code', callback);
                });
                return;
            }

            runtimeLogger.info(`Posted work result for invocation id [${invocationId}]`);
            res.on('data', () => {});
            res.on('end', () => callback(undefined));
        }).on('error', (e) => {
            runtimeLogger.error(`Failed to post work result: ${e}`);
            callback(e);
        });

        req.write(resultBytes);
        req.end();
    }

    postHandlerErr(functionArn, errBytes, invocationId, callback) {
        const path = getWorkRequestPath(functionArn);
        const options = {
            method: 'POST',
            host: this._host,
            port: this._port,
            path: path,
            headers: {
                [HEADER_AUTH_TOKEN]: this._authToken,
                [HEADER_INVOCATION_ID]: invocationId,
                [HEADER_FUNCTION_ERR_TYPE]: 'Handled',
            },
            agent: this._httpAgent,
        };

        runtimeLogger.info(`Posting handler error for invocation id [${invocationId}] to ${path}`);

        const req = http.request(options, (res) => {
            if (res.statusCode !== 200) {
                res.on('data', (chunk) => {
                    IPCClient.logErrorMessage(res, chunk, 'PostHandlerErr returned HTTP with status code', callback);
                });
                return;
            }

            runtimeLogger.info(`Posted handler error for invocation id [${invocationId}]`);
            res.on('data', () => {});
            res.on('end', () => callback(undefined));
        }).on('error', (e) => {
            runtimeLogger.error(`Failed to post handler error: ${e}`);
            callback(e);
        });

        req.write(errBytes);
        req.end();
    }

    static logErrorMessage(res, chunk, errorString, callback) {
        const err = new Error(`${errorString}: ${res.statusCode}, ${chunk}`);
        runtimeLogger.error(err);
        callback(err);
    }
}

module.exports = IPCClient;
