diff --recursive --unified --new-file --no-dereference orig/README.md src/README.md
--- orig/README.md	1970-01-01 00:00:00.000000000 +0000
+++ src/README.md	2022-10-07 06:31:35.000000000 +0000
@@ -0,0 +1,2 @@
+# ddns-scripts
+
diff --recursive --unified --new-file --no-dereference orig/ddns.config src/ddns.config
--- orig/ddns.config	2023-11-08 12:46:52.000000000 +0000
+++ src/ddns.config	1970-01-01 00:00:00.000000000 +0000
@@ -1,32 +0,0 @@
-#
-# Please read https://openwrt.org/docs/guide-user/base-system/ddns
-#
-config ddns "global"
-	option ddns_dateformat "%F %R"
-#	option ddns_rundir "/var/run/ddns"
-#	option ddns_logdir "/var/log/ddns"
-	option ddns_loglines "250"
-	option upd_privateip "0"
-
-
-config service "myddns_ipv4"
-	option service_name	"dyndns.org"
-	option lookup_host	"yourhost.example.com"
-	option domain		"yourhost.example.com"
-	option username		"your_username"
-	option password		"your_password"
-	option interface	"wan"
-	option ip_source	"network"
-	option ip_network	"wan"
-
-config service "myddns_ipv6"
-	option update_url	"http://[USERNAME]:[PASSWORD]@your.provider.net/nic/update?hostname=[DOMAIN]&myip=[IP]"
-	option lookup_host	"yourhost.example.com"
-	option domain		"yourhost.example.com"
-	option username		"your_username"
-	option password		"your_password"
-	option use_ipv6		"1"
-	option interface	"wan6"
-	option ip_source	"network"
-	option ip_network	"wan6"
-
diff --recursive --unified --new-file --no-dereference orig/ddns.config_sample src/ddns.config_sample
--- orig/ddns.config_sample	2023-11-08 12:46:52.000000000 +0000
+++ src/ddns.config_sample	1970-01-01 00:00:00.000000000 +0000
@@ -1,314 +0,0 @@
-#
-#
-# Here you find a description on every parameter supported
-# and used by ddns-scripts and corresponding LuCI application
-#
-# Inside your ddns configuration file (/etc/config/ddns)
-# you might not find some of below described options.
-# This is because you don't need to define options
-# if using there defaults. The LuCI application will delete
-# options that configured to there default values.
-#
-# If you have a working ddns configuration from old ddns-scripts (Version 1.x)
-# everything will function the same with new scripts
-# without any changes to the configuration.
-#
-# If you like to use this file for your configuration then
-# use a copy, because the used software to modify the
-# configuration files will throw away all empty lines
-# and those starting with # (comments).
-#
-
-#####################################################################
-# Global application settings
-#
-config ddns "global"
-
-	###########
-	# set date format to use for display date in logfiles
-	# and LuCI web application.
-	# For codes see man pages of date command.
-	# default: "%F %R" (ISO 8601 format)
-#	option ddns_dateformat "%F %R"
-
-	###########
-	# set run directory to use for .pid and .update files
-	# there will be a separate file for every running service section
-	# default: "/var/run/ddns"
-#	option ddns_rundir "/var/run/ddns"
-
-	###########
-	# set log directory to use for .log files
-	# there will be a separate file for every running service section
-	# default: "/var/log/ddns"
-#	option ddns_logdir "/var/log/ddns"
-
-	###########
-	# set number of lines stored in .log file before auto truncated
-	# default: "250" lines
-#	option ddns_loglines "250"
-
-	###########
-	# Whether to allow to send Private/Special IP's to the DDNS provider
-	# IPv4: 0.x, 10.x, 127.x, 172.16.x-172.31.x, 192.168.x
-	# IPv6: ::, Fxxx:
-	# default: "0"	disabled
-#	option upd_privateip "0"
-
-#####################################################################
-# DDNS service settings
-#
-# for each service you want to serve you need a separate configuration
-# if you need IPv4 and IPv6 you need to setup 2 separate configurations
-# with different names. (i.e. "myddns_ipv4" and "myddns_ipv6")
-# do not use white-spaces or dashes "-" or "@" ":" "!" or
-# other special characters inside name.
-config service "myddns"
-
-	########### Basic settings ########################
-
-	###########
-	# enable/disable this service section
-	# default: "0"	disabled
-	option enabled "0"
-
-	###########
-	# detecting/sending IPv4 or IPv6 address to the DDNS provider
-	# set to "1" if you want to use IPv6
-	# default: "0"	use IPv4
-	option use_ipv6 "0"
-
-	###########
-	# defines the network as defined in /etc/config/network
-	# to be monitored for up/down events to start via hotplug
-	default: "wan"	for IPv4
-	default: "wan6"	for IPv6
-	option interface "wan"
-
-	###########
-	# Next you need to specify the name of the service you are
-	# connecting to "eg. dyndns.org".  The format of the update
-	# urls for several different dynamic dns services is specified
-	# in the "/usr/lib/ddns/services" file for IPv4 and in
-	# "/usr/lib/ddns/service_ipv6" file. This list is hardly complete
-	# as there are many, many different dynamic dns services.
-	# If your service is on the list you can merely specify it with the
-	# "service_name" option.  Otherwise you will need to determine
-	# the format of the url to update with.  You can either add an
-	# entry to the "/usr/lib/ddns/services" or "services_ipv6" file
-	# or specify this with the "update_url" option.
-	# If your ddns provider doesn't work with ddns-scripts because
-	# there are additional parameters or other special thinks to be done,
-	# then you could write your own script to send updates to your ddns provider.
-	# Have a look into /usr/lib/ddns/update_sample.sh
-	# The script is specified in "update_script"
-	# Either set "service_name" or one of "update_url" and "update_script"
-	# default: none
-	option service_name "dyndns.org"
-
-	# sample:
-	# "http://[USERNAME]:[PASSWORD]@members.dyndns.org/nic/update?hostname=[DOMAIN]&myip=[IP]"
-#	option update_url   ""
-
-	# sample:
-	# "/usr/lib/ddns/update_sample.sh"
-#	option update_script   ""
-
-	###########
-	# Keep an eye on providers help pages.
-	#
-	# FQDN of ONE of your defined host at DDNS provider
-	# REQUIRED to verify what the current IP at DNS using nslookup/host command
-	# default: none
-	option lookup_host ""
-
-	# Your DNS name / replace [DOMAIN] in update_url
-	# default: none
-	option domain ""
-
-	# Username of your DDNS service account / replace [USERNAME] in update_url
-	# default: none
-	option username ""
-
-	# Password of your DDNS service account / replace [PASSWORD] in update url
-	# default: none
-	option password ""
-
-	###########
-	# Optional parameters for use inside update_url
-	#
-	# parameter that will be urlencoded before replacement of [PARAMENC] inside update url
-	# default: none
-	option param_enc ""
-
-	# parameter that repace [PARAMOPT] inside update url
-	# default: none
-	option param_opt ""
-
-	###########
-	# use HTTPS for secure communication with you DDNS provider
-	# personally found some providers having problems when not sending
-	# updates via HTTPS. You must not specify "https://" in update_url.
-	# It's modified by the scripts themselves
-	# Needs GNU Wget (with SSL support) or cURL to be installed.
-	# default: "0"	do not use HTTPS
-	option use_https "0"
-
-	# if using HTTPS (see above) the transfer program tries to verify
-	# the providers server certificate. For verification there needs to be
-	# the counterpart on this machine. Specify the path or path/file where
-	# the transfer program can find them. (might need package CA-certificates)
-	# if you don't want to verify servers certificate (insecure) you should
-	# this parameter to "IGNORE" (in capital letters)
-	# default: (none)	path where CA-certificate package is installed
-	option cacert "/etc/ssl/certs"
-
-	###########
-	# for logging and control if everything work fine you can get information inside
-	# system log . Critical Errors are always send to system log.
-	# You can define which information you like to log
-	# 1 == info, notice, warning, errors
-	# 2 == notice, warning, errors
-	# 3 == warning, errors
-	# 4 == errors
-	# default: "0" off
-	option use_syslog  "0"
-
-	###########
-	# for logging and control if everything work fine you can get information inside
-	# log file. You find the file per default in /var/log/ddns/[sectionname].log
-	# The path can be modified for all log files in ddns.global section (see above)
-	# default: "1" on
-	option use_logfile "1"
-
-	########### Advanced settings #####################
-
-	###########
-	# you need to specify how ddns-scripts should detect you current local ip.
-	# the ip_source could be set to "network", "web", "interface" or "script"
-	# the parameters below specifying the additional information needed for
-	# the corresponding ip_spource configuration
-	# default: "network"
-
-	# ip_source "network" additional uses option ip_network and detects the
-	# current local ip on network as defined in /etc/config/network
-	# default: "wan"  using IPv4
-	# default: "wan6" using IPv6
-	option ip_source  "network"
-	option ip_network "wan"
-
-	# ip_source "web" additional uses option ip_url and detects the current
-	# local ip from special web sides that response with the ip address of
-	# calling host. If you are behind a firewall/NAT this is the best option
-	# since none of the local networks or interfaces will have the external ip.
-	# default: "http://checkip.dyndns.com"   using IPv4
-	# default: "http://checkipv6.dyndns.com" using IPv6
-#	option ip_source "web"
-#	option ip_url    "http://checkip.dyndns.com"
-
-	# ip_source "interface" additional uses option ip_interface
-	# ip_source "interface" uses one of the locally installed physical interfaces
-	# to detect independent from network they configured to.
-	# default: none
-#	option ip_source    "interface"
-#	option ip_interface "eth1"
-
-	# ip_source "script" additional uses option ip_script
-	# it's useful if you want to write your own script to detect the
-	# current local ip. put full path into ip_script option.
-	# The script must be executable.
-	# default: none
-#	option ip_source "script"
-#	option ip_script ""
-
-	###########
-	# force_ipversion option will set the "-4" respectively "-6" parameter
-	# on command line of transfer and DNS lookup program.
-	# So the whole communication uses the selected IP version between both ends.
-	# needs GNU Wget or cURL installed for transfer and
-	# BIND's host for DNS lookup.
-	# default: "0" disabled
-	option force_ipversion "0"
-
-	###########
-	# Normally the current (in the internet) registered ip is detected using the
-	# local defined name lookup policies (i.e. /etc/resolve.conf etc.)
-	# Specify here a DNS server to use instead of the defaults.
-	# you can use hostname or ip address
-	# i.e. "google-public-dns-a.google.com"
-	# default: none
-#	option dns_server "google-public-dns-a.google.com"
-
-	# By default every DNS call is made via UDP protocol
-	# Some internet provider offer modems that cache UDP DNS requests.
-	# They also redirect calls to external servers to local.
-	# To force the usage of TCP for DNS requests enable this option
-	# Needs BIND's host program be installed
-	# default: "0" disabled
-#	option force_dnstcp "0"
-
-	###########
-	# If a Proxy is need to access HTTP/HTTPS pages on the WEB
-	# it can be configured here also for sending updates to the
-	# DDNS provider. If you configured use_https='1' above, you
-	# need to setup your HTTPS proxy here, otherwise your
-	# HTTP proxy. !!! You should not detect your current IP
-	# ip_source='web' (see above) because this request is also
-	# send via the configured proxy !!!
-	# Syntax: [user:password@]proxy:port !port is required !
-	# IPv6 address must be in squared brackets "[...]"
-	# default: none
-#	option proxy ''
-
-	###########
-	# In some very special configurations i.e. Multi WAN environment
-	# in a NAT cascade it might be necessary to define
-	# a network to use for communication.
-	# should use option ip_source "web" (see above)
-	# Needs GNU Wget (with SSL support) or cURL to be installed.
-	# GNU Wget will use IP address and cURL the physical device 
-	# of the given network
-	# default: none
-#	option bind_network "wan7"
-
-	########### Timer settings ########################
-
-	###########
-	# defines the time interval to check if local IP has changed
-	# After the first start and first update send, the system will
-	# wait this time before verify if update was successful send.
-	# !!! checks below 5 minutes make no sense because the Internet
-	# needs about 5-10 minutes to sync an IP-change to all DNS servers !!!
-	# accepted unit entry’s: 'seconds' 'minutes' 'hours'
-	# minimum 5 minutes == 300 seconds
-	# default 10 minutes
-	option check_interval	'10'
-	option check_unit	'minutes'
-
-	###########
-	# force to send an update to service provider, if no change was detected.
-	# consult DDNS providers documentation if your DDNS entry might timeout.
-	# accepted unit entry’s: 'minutes' 'hours' 'days'
-	# minimum needs to be greater or equal check interval (see above)
-	# A special setting of '0' is allowed, which forces the script to run once.
-	# It sends an update, verify if update was accepted by DNS
-	# (retry if not) and finish. Useful if you want to start by your own (i.e. cron)
-	# default 3 days == 72 hours
-	option force_interval	'72'
-	option force_unit	'hours'
-
-	###########
-	# if error happen on detecting, sending or updating the
-	# script will retry the relevant action for retry_count times
-	# before stopping script execution.
-	# default: 5
-	option retry_count '5'
-
-	###########
-	# if error happen on detecting, sending or updating the
-	# script will retry the relevant action.
-	# here you define the time to wait before retry is started
-	# accepted unit entry’s: 'seconds' 'minutes'
-	# default: 60 seconds
-	option retry_interval	'60'
-	option retry_unit	'seconds'
diff --recursive --unified --new-file --no-dereference orig/ddns.defaults src/ddns.defaults
--- orig/ddns.defaults	2023-11-08 12:46:52.000000000 +0000
+++ src/ddns.defaults	1970-01-01 00:00:00.000000000 +0000
@@ -1,201 +0,0 @@
-#!/bin/sh
-
-g_pslfile=/usr/share/public_suffix_list.dat.gz
-[ -f "$g_pslfile" ] || g_pslfile="$(dirname $0)/public_suffix_list.dat.gz"
-
-g_pslerr=0
-g_cfgfile="ddns"
-
-# modify timer settings from interval and unit to dhms format
-timer2dhms() {
-# $1	Number and
-# $2	Unit of time interval
-	local t=0
-	case $2 in
-		days)		t=$(( $1 * 86400 ));;
-		hours)		t=$(( $1 * 3600 ));;
-		minutes)	t=$(( $1 * 60 ));;
-		*)		t=$1;;
-	esac
-
-	local d=$(( $t / 86400 ))
-	local h=$(( $t % 86400 / 3600 ))
-	local m=$(( $t % 3600 / 60 ))
-	local s=$(( $t % 60 ))
-	if [ $d -gt 0 ]; then printf "%dd %02dh %02dm %02ds" "$d" "$h" "$m" "$s"
-	elif [ $h -gt 0 ]; then printf "%dh %02dm %02ds" "$h" "$m" "$s"
-	elif [ $m -gt 0 ]; then printf "%dm %02ds" "$m" "$s"
-	else printf "%ds" "$s"; fi
-
-	unset d h m s t
-	return 0
-}
-
-# using function to not confuse function calls with existing ones inside /lib/functions.sh
-update_config() {
-	uc_uci="$(which uci) -q"	# ignore errors
-	uc_cfg=""
-	uc_name=""
-	uc_var=""
-	uc_val=""
-	package() { return 0; }
-	config () {
-		uc_cfg="$1"
-		uc_name="$2"
-
-		# Type = ddns	Name = global
-		if [ "$uc_cfg" = "$g_cfgfile" -a "$uc_name" = "global" ]; then
-			option() {
-				uc_var="$1"; shift
-				uc_val="$*"
-				case "$uc_var" in
-					allow_local_ip)	$uc_uci rename $g_cfgfile.$uc_name.$uc_var="upd_privateip";;
-					date_format)	$uc_uci rename $g_cfgfile.$uc_name.$uc_var="ddns_dateformat";;
-					log_lines)	$uc_uci rename $g_cfgfile.$uc_name.$uc_var="ddns_loglines";;
-					log_dir)	$uc_uci rename $g_cfgfile.$uc_name.$uc_var="ddns_logdir";;
-					run_dir)	$uc_uci rename $g_cfgfile.$uc_name.$uc_var="ddns_rundir";;
-					# leave all other options currently unchanged
-					*)	;;
-				esac
-			}
-
-		# Type = service	Name = ???
-		elif [ "$uc_cfg" = "service" ]; then
-			option() {
-				uc_var="$1"; shift
-				uc_val="$*"
-				case "$uc_var" in
-					# fix some option service_name values
-					# and some settings for specific providers
-					service_name|upd_provider)
-						case "$uc_val" in
-							freedns\.afraid\.org|afraid\.org)
-								$uc_uci set $g_cfgfile.$uc_name.$uc_var="afraid.org-keyauth";;
-							Bind-nsupdate)
-								$uc_uci set $g_cfgfile.$uc_name.$uc_var="bind-nsupdate";;
-							dyndns\.org|dyndns\.com)
-								$uc_uci set $g_cfgfile.$uc_name.$uc_var="dyn.com";;
-							free\.editdns\.net)
-								$uc_uci set $g_cfgfile.$uc_name.$uc_var="editdns.net";;
-							FreeDNS\.42\.pl)
-								$uc_uci set $g_cfgfile.$uc_name.$uc_var="freedns.42.pl";;
-							domains\.google\.com)
-								$uc_uci set $g_cfgfile.$uc_name.$uc_var="google.com";;
-							loopia\.com)
-								$uc_uci set $g_cfgfile.$uc_name.$uc_var="loopia.se";;
-							NoIP\.com|No-IP\.com)
-								$uc_uci set $g_cfgfile.$uc_name.$uc_var="no-ip.com";;
-							spdns\.de)
-								$uc_uci set $g_cfgfile.$uc_name.$uc_var="spdyn.de";;
-							strato\.de)
-								$uc_uci set $g_cfgfile.$uc_name.$uc_var="strato.com";;
-							*)
-								# all others leave unchanged
-								;;
-						esac
-						# rename option service_name to option upd_provider
-#						$uc_uci rename $g_cfgfile.$uc_name.$uc_var="upd_provider"
-						;;
-					domain|upd_object)
-						# verify if lookup_host is set
-						$uc_uci get $g_cfgfile.$uc_name.lookup_host >/dev/null 2>&1 || \
-							$uc_uci set $g_cfgfile.$uc_name.lookup_host="$uc_val"
-						if [ -f "$g_pslfile" ]; then
-							# if service_name/upd_provider cloudflare_v1 then change domain/upd_object to new syntax
-							# there is no sort order inside uci data so we need multiple checks
-							uco_provider=$($uc_uci get $g_cfgfile.$uc_name.upd_provider 2>/dev/null) || \
-								uco_provider=$($uc_uci get $g_cfgfile.$uc_name.service_name 2>/dev/null)
-							unset uco_provider
-						fi
-						# rename option domain to option upd_object
-#						$uc_uci rename $g_cfgfile.$uc_name.$uc_var="upd_object"
-						;;
-#					dns_server)
-#						# if bind-nsupdate takeover old "dns_server" value as new "upd_nsupd_server" value
-#						uco_provider=$($uc_uci get $g_cfgfile.$uc_name.upd_provider 2>/dev/null) || \
-#							uco_provider=$($uc_uci get $g_cfgfile.$uc_name.service_name 2>/dev/null)
-#						[ "$uco_provider" = "Bind-nsupdate" -o \
-#						  "$uco_provider" = "bind-nsupdate" ] && \
-#							$uc_uci set $g_cfgfile.$uc_name.upd_nsupd_server="$uc_val"
-#						# rename option dns_server to new option global_dnssvr
-#						$udc_uci rename $g_cfgfile.$uc_name.$uc_var="global_dnssvr"
-#						;;
-#					bind_network)
-#						$udc_uci set $g_cfgfile.$uc_name.upd_url_bindnet="$uc_val"
-#						$udc_uci rename $g_cfgfile.$uc_name.$uc_var="lip_url_bindnet"
-#						;;
-#					proxy)
-#						# proxy value must include protocoll
-#						$udc_uci set $g_cfgfile.$uc_name.$uc_var="http://$uc_val"
-#						$udc_uci rename $g_cfgfile.$uc_name.$uc_var="upd_url_proxy"
-#						;;
-#					use_ipv6)
-#						$udc_uci set $g_cfgfile.$uc_name.$uc_var="$(( 4 + ( 2 * $uc_val ) ))"
-#						$udc_uci rename $g_cfgfile.$uc_name.$uc_var="upd_ipversion"
-#				TODO	update_url)
-#				TODO	update_script)
-					# other renames
-#				TODO	lookup_host)	-> rip_host
-#					enabled)	$udc_uci rename $g_cfgfile.$uc_name.$uc_var="upd_enabled";;
-#					force_dnstcp)	$udc_uci rename $g_cfgfile.$uc_name.$uc_var="rip_host_dnstcp";;
-#					is_glue)	$udc_uci rename $g_cfgfile.$uc_name.$uc_var="rip_host_isglue";;
-#					ip_interface)	$udc_uci rename $g_cfgfile.$uc_name.$uc_var="lip_iface";;
-#					ip_network)	$udc_uci rename $g_cfgfile.$uc_name.$uc_var="lip_net";;
-#					use_https)	$udc_uci rename $g_cfgfile.$uc_name.$uc_var="upd_url_secure";;
-#					cacert)		$udc_uci rename $g_cfgfile.$uc_name.$uc_var="upd_url_cacert";;
-#					username)	$udc_uci rename $g_cfgfile.$uc_name.$uc_var="upd_username";;
-#					password)	$udc_uci rename $g_cfgfile.$uc_name.$uc_var="upd_password";;
-#					param_opt)	$udc_uci rename $g_cfgfile.$uc_name.$uc_var="upd_paramopt";;
-#					param_enc)	$udc_uci rename $g_cfgfile.$uc_name.$uc_var="upd_paramenc";;
-
-					# leave all other options currently unchanged
-					*)	;;
-				esac
-				return 0
-			}
-			return 0
-
-		# ignore unknown
-		else
-			return 0
-		fi
-	}
-
-	# read config file
-	uc_data=$($uc_uci -S -n export "$g_cfgfile")
-	uc_ret="$?"
-	# Error then create config file
-	[ $uc_ret -ne 0 ] && {
-		touch /etc/config/$uc_cfgfile
-		chmod 644 /etc/config/$uc_cfgfile
-	}
-	# No error and uc_data then execute (eval)
-	# this will call functions defined above
-	[ $uc_ret -eq 0 -a -n "$uc_data" ] && eval "$uc_data"
-
-	# add config ddns "global" (ignore error if exists)
-	$uc_uci set ddns.global="$g_cfgfile"
-
-	# write changes to config file
-	$uc_uci commit "$g_cfgfile"
-
-	unset uc_uci uc_cfg uc_name uc_var uc_val uc_ret uc_data
-	return 0
-}
-
-# clear LuCI indexcache
-rm -f /tmp/luci-indexcache >/dev/null 2>&1
-
-# do config update
-update_config
-
-#cleanup
-[ $g_pslerr -ne 0 ] && {
-	unset g_pslfile g_pslerr g_cfgfile
-	return 1
-}
-
-[ -f "$g_pslfile" ] && rm -f "$g_pslfile"
-unset g_pslfile g_pslerr g_cfgfile
-return 0
-
diff --recursive --unified --new-file --no-dereference orig/ddns.hotplug src/ddns.hotplug
--- orig/ddns.hotplug	2023-11-08 12:46:52.000000000 +0000
+++ src/ddns.hotplug	1970-01-01 00:00:00.000000000 +0000
@@ -1,11 +0,0 @@
-#!/bin/sh
-
-# there are other ACTIONs like ifupdate we don't need
-case "$ACTION" in
-	ifup)					# OpenWrt is giving a network not phys. Interface
-		/etc/init.d/ddns enabled && /usr/lib/ddns/dynamic_dns_updater.sh -n "$INTERFACE" -- start
-		;;
-	ifdown)
-		/usr/lib/ddns/dynamic_dns_updater.sh -n "$INTERFACE" -- stop
-		;;
-esac
diff --recursive --unified --new-file --no-dereference orig/ddns.init src/ddns.init
--- orig/ddns.init	2023-11-08 12:46:52.000000000 +0000
+++ src/ddns.init	1970-01-01 00:00:00.000000000 +0000
@@ -1,27 +0,0 @@
-#!/bin/sh /etc/rc.common
-START=95
-STOP=10
-
-boot() {
-	return 0
-}
-
-reload() {
-	/usr/lib/ddns/dynamic_dns_updater.sh -- reload
-	return 0
-}
-
-restart() {
-	/usr/lib/ddns/dynamic_dns_updater.sh -- stop
-	sleep 1	# give time to shutdown
-	/usr/lib/ddns/dynamic_dns_updater.sh -- start
-}
-
-start() {
-	/usr/lib/ddns/dynamic_dns_updater.sh -- start
-}
-
-stop() {
-	/usr/lib/ddns/dynamic_dns_updater.sh -- stop
-	return 0
-}
diff --recursive --unified --new-file --no-dereference orig/dynamic_dns_functions.sh src/dynamic_dns_functions.sh
--- orig/dynamic_dns_functions.sh	2023-11-08 12:46:52.000000000 +0000
+++ src/dynamic_dns_functions.sh	1970-01-01 00:00:00.000000000 +0000
@@ -1,1373 +0,0 @@
-#!/bin/sh
-# /usr/lib/ddns/dynamic_dns_functions.sh
-#
-#.Distributed under the terms of the GNU General Public License (GPL) version 2.0
-# Original written by Eric Paul Bishop, January 2008
-# (Loosely) based on the script on the one posted by exobyte in the forums here:
-# http://forum.openwrt.org/viewtopic.php?id=14040
-# extended and partial rewritten
-#.2014-2018 Christian Schoenebeck <christian dot schoenebeck at gmail dot com>
-#
-# function timeout
-# copied from http://www.ict.griffith.edu.au/anthony/software/timeout.sh
-# @author Anthony Thyssen  6 April 2011
-#
-# variables in small chars are read from /etc/config/ddns
-# variables in big chars are defined inside these scripts as global vars
-# variables in big chars beginning with "__" are local defined inside functions only
-# set -vx  	#script debugger
-
-. /lib/functions.sh
-. /lib/functions/network.sh
-
-# GLOBAL VARIABLES #
-VERSION="2.7.8-2"
-SECTION_ID=""		# hold config's section name
-VERBOSE=0		# default mode is log to console, but easily changed with parameter
-MYPROG=$(basename $0)	# my program call name
-
-LOGFILE=""		# logfile - all files are set in dynamic_dns_updater.sh
-PIDFILE=""		# pid file
-UPDFILE=""		# store UPTIME of last update
-DATFILE=""		# save stdout data of WGet and other external programs called
-ERRFILE=""		# save stderr output of WGet and other external programs called
-IPFILE=""		# store registered IP for read by LuCI status
-TLDFILE=/usr/share/public_suffix_list.dat.gz	# TLD file used by split_FQDN
-
-CHECK_SECONDS=0		# calculated seconds out of given
-FORCE_SECONDS=0		# interval and unit
-RETRY_SECONDS=0		# in configuration
-
-LAST_TIME=0		# holds the uptime of last successful update
-CURR_TIME=0		# holds the current uptime
-NEXT_TIME=0		# calculated time for next FORCED update
-EPOCH_TIME=0		# seconds since 1.1.1970 00:00:00
-
-REGISTERED_IP=""	# holds the IP read from DNS
-LOCAL_IP=""		# holds the local IP read from the box
-
-URL_USER=""		# url encoded $username from config file
-URL_PASS=""		# url encoded $password from config file
-URL_PENC=""		# url encoded $param_enc from config file
-
-UPD_ANSWER=""		# Answer given by service on success
-
-ERR_LAST=0		# used to save $? return code of program and function calls
-ERR_UPDATE=0		# error counter on different local and registered ip
-
-PID_SLEEP=0		# ProcessID of current background "sleep"
-
-# regular expression to detect IPv4 / IPv6
-# IPv4       0-9   1-3x "." 0-9  1-3x "." 0-9  1-3x "." 0-9  1-3x
-IPV4_REGEX="[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}"
-# IPv6       ( ( 0-9a-f  1-4char ":") min 1x) ( ( 0-9a-f  1-4char   )optional) ( (":" 0-9a-f 1-4char  ) min 1x)
-IPV6_REGEX="\(\([0-9A-Fa-f]\{1,4\}:\)\{1,\}\)\(\([0-9A-Fa-f]\{1,4\}\)\{0,1\}\)\(\(:[0-9A-Fa-f]\{1,4\}\)\{1,\}\)"
-
-# detect if called by ddns-lucihelper.sh script, disable retrys (empty variable == false)
-LUCI_HELPER=$(printf %s "$MYPROG" | grep -i "luci")
-
-# Name Server Lookup Programs
-BIND_HOST=$(which host)
-KNOT_HOST=$(which khost)
-DRILL=$(which drill)
-HOSTIP=$(which hostip)
-NSLOOKUP=$(which nslookup)
-
-# Transfer Programs
-WGET=$(which wget)
-WGET_SSL=$(which wget-ssl)
-
-CURL=$(which curl)
-
-# CURL_PROXY not empty then Proxy support available
-CURL_PROXY=$(find /lib /usr/lib -name libcurl.so* -exec strings {} 2>/dev/null \; | grep -im1 "all_proxy")
-
-UCLIENT_FETCH=$(which uclient-fetch)
-
-# Global configuration settings
-# allow NON-public IP's
-upd_privateip=$(uci -q get ddns.global.upd_privateip) || upd_privateip=0
-
-# directory to store run information to.
-ddns_rundir=$(uci -q get ddns.global.ddns_rundir) || ddns_rundir="/var/run/ddns"
-[ -d $ddns_rundir ] || mkdir -p -m755 $ddns_rundir
-
-# directory to store log files
-ddns_logdir=$(uci -q get ddns.global.ddns_logdir) || ddns_logdir="/var/log/ddns"
-[ -d $ddns_logdir ] || mkdir -p -m755 $ddns_logdir
-
-# number of lines to before rotate logfile
-ddns_loglines=$(uci -q get ddns.global.ddns_loglines) || ddns_loglines=250
-ddns_loglines=$((ddns_loglines + 1))	# correct sed handling
-
-# format to show date information in log and luci-app-ddns default ISO 8601 format
-ddns_dateformat=$(uci -q get ddns.global.ddns_dateformat) || ddns_dateformat="%F %R"
-DATE_PROG="date +'$ddns_dateformat'"
-
-# USE_CURL if GNU Wget and cURL installed normally Wget is used by do_transfer()
-# to change this use global option use_curl '1'
-USE_CURL=$(uci -q get ddns.global.use_curl) || USE_CURL=0	# read config
-[ -n "$CURL" ] || USE_CURL=0					# check for cURL
-
-# loads all options for a given package and section
-# also, sets all_option_variables to a list of the variable names
-# $1 = ddns, $2 = SECTION_ID
-load_all_config_options()
-{
-	local __PKGNAME="$1"
-	local __SECTIONID="$2"
-	local __VAR
-	local __ALL_OPTION_VARIABLES=""
-
-	# this callback loads all the variables in the __SECTIONID section when we do
-	# config_load. We need to redefine the option_cb for different sections
-	# so that the active one isn't still active after we're done with it.  For reference
-	# the $1 variable is the name of the option and $2 is the name of the section
-	config_cb()
-	{
-		if [ ."$2" = ."$__SECTIONID" ]; then
-			option_cb()
-			{
-				__ALL_OPTION_VARIABLES="$__ALL_OPTION_VARIABLES $1"
-			}
-		else
-			option_cb() { return 0; }
-		fi
-	}
-
-	config_load "$__PKGNAME"
-
-	# Given SECTION_ID not found so no data, so return 1
-	[ -z "$__ALL_OPTION_VARIABLES" ] && return 1
-
-	for __VAR in $__ALL_OPTION_VARIABLES
-	do
-		config_get "$__VAR" "$__SECTIONID" "$__VAR"
-	done
-	return 0
-}
-
-# read's all service sections from ddns config
-# $1 = Name of variable to store
-load_all_service_sections() {
-	local __DATA=""
-	config_cb()
-	{
-		# only look for section type "service", ignore everything else
-		[ "$1" = "service" ] && __DATA="$__DATA $2"
-	}
-	config_load "ddns"
-
-	eval "$1=\"$__DATA\""
-	return
-}
-
-# starts updater script for all given sections or only for the one given
-# $1 = interface (Optional: when given only scripts are started
-# configured for that interface)
-# used by /etc/hotplug.d/iface/95-ddns on IFUP
-# and by /etc/init.d/ddns start
-start_daemon_for_all_ddns_sections()
-{
-	local __EVENTIF="$1"
-	local __SECTIONS=""
-	local __SECTIONID=""
-	local __IFACE=""
-
-	load_all_service_sections __SECTIONS
-	for __SECTIONID in $__SECTIONS; do
-		config_get __IFACE "$__SECTIONID" interface "wan"
-		[ -z "$__EVENTIF" -o "$__IFACE" = "$__EVENTIF" ] || continue
-		if [ $VERBOSE -eq 0 ]; then	# start in background
-			/usr/lib/ddns/dynamic_dns_updater.sh -v 0 -S "$__SECTIONID" -- start &
-		else
-			/usr/lib/ddns/dynamic_dns_updater.sh -v "$VERBOSE" -S "$__SECTIONID" -- start
-		fi
-	done
-}
-
-# stop sections process incl. childs (sleeps)
-# $1 = section
-stop_section_processes() {
-	local __PID=0
-	local __PIDFILE="$ddns_rundir/$1.pid"
-	[ $# -ne 1 ] && write_log 12 "Error calling 'stop_section_processes()' - wrong number of parameters"
-
-	[ -e "$__PIDFILE" ] && {
-		__PID=$(cat $__PIDFILE)
-		ps | grep "^[\t ]*$__PID" >/dev/null 2>&1 && kill $__PID || __PID=0	# terminate it
-	}
-	[ $__PID -eq 0 ] # report if process was running
-}
-
-# stop updater script for all defines sections or only for one given
-# $1 = interface (optional)
-# used by /etc/hotplug.d/iface/95-ddns on 'ifdown'
-# and by /etc/init.d/ddns stop
-# needed because we also need to kill "sleep" child processes
-stop_daemon_for_all_ddns_sections() {
-	local __EVENTIF="$1"
-	local __SECTIONS=""
-	local __SECTIONID=""
-	local __IFACE=""
-
-	load_all_service_sections __SECTIONS
-	for __SECTIONID in $__SECTIONS;	do
-		config_get __IFACE "$__SECTIONID" interface "wan"
-		[ -z "$__EVENTIF" -o "$__IFACE" = "$__EVENTIF" ] || continue
-		stop_section_processes "$__SECTIONID"
-	done
-}
-
-# reports to console, logfile, syslog
-# $1	loglevel 7 == Debug to 0 == EMERG
-#	value +10 will exit the scripts
-# $2..n	text to report
-write_log() {
-	local __LEVEL __EXIT __CMD __MSG __MSE
-	local __TIME=$(date +%H%M%S)
-	[ $1 -ge 10 ] && {
-		__LEVEL=$(($1-10))
-		__EXIT=1
-	} || {
-		__LEVEL=$1
-		__EXIT=0
-	}
-	shift	# remove loglevel
-	[ $__EXIT -eq 0 ] && __MSG="$*" || __MSG="$* - TERMINATE"
-	case $__LEVEL in		# create log message and command depending on loglevel
-		0)	__CMD="logger -p user.emerg -t ddns-scripts[$$] $SECTION_ID: $__MSG"
-			__MSG=" $__TIME EMERG : $__MSG" ;;
-		1)	__CMD="logger -p user.alert -t ddns-scripts[$$] $SECTION_ID: $__MSG"
-			__MSG=" $__TIME ALERT : $__MSG" ;;
-		2)	__CMD="logger -p user.crit -t ddns-scripts[$$] $SECTION_ID: $__MSG"
-			__MSG=" $__TIME  CRIT : $__MSG" ;;
-		3)	__CMD="logger -p user.err -t ddns-scripts[$$] $SECTION_ID: $__MSG"
-			__MSG=" $__TIME ERROR : $__MSG" ;;
-		4)	__CMD="logger -p user.warn -t ddns-scripts[$$] $SECTION_ID: $__MSG"
-			__MSG=" $__TIME  WARN : $__MSG" ;;
-		5)	__CMD="logger -p user.notice -t ddns-scripts[$$] $SECTION_ID: $__MSG"
-			__MSG=" $__TIME  note : $__MSG" ;;
-		6)	__CMD="logger -p user.info -t ddns-scripts[$$] $SECTION_ID: $__MSG"
-			__MSG=" $__TIME  info : $__MSG" ;;
-		7)	__MSG=" $__TIME       : $__MSG";;
-		*) 	return;;
-	esac
-
-	# verbose echo
-	[ $VERBOSE -gt 0 -o $__EXIT -gt 0 ] && echo -e "$__MSG"
-	# write to logfile
-	if [ ${use_logfile:-1} -eq 1 -o $VERBOSE -gt 1 ]; then
-		if [ -n "$password" ]; then
-			# url encode __MSG, password already done
-			urlencode __MSE "$__MSG"
-			# replace encoded password inside encoded message
-			# and url decode (newline was encoded as %00)
-			__MSG=$( echo -e "$__MSE" \
-				| sed -e "s/$URL_PASS/***PW***/g" \
-				| sed -e "s/+/ /g; s/%00/\n/g; s/%/\\\\x/g" | xargs -0 printf "%b" )
-		fi
-		printf "%s\n" "$__MSG" >> $LOGFILE
-		# VERBOSE > 1 then NO loop so NO truncate log to $ddns_loglines lines
-		[ $VERBOSE -gt 1 ] || sed -i -e :a -e '$q;N;'$ddns_loglines',$D;ba' $LOGFILE
-	fi
-	[ -n "$LUCI_HELPER" ] && return	# nothing else todo when running LuCI helper script
-	[ $__LEVEL -eq 7 ] && return	# no syslog for debug messages
-	__CMD=$(echo -e "$__CMD" | tr -d '\n' | tr '\t' '     ')        # remove \n \t chars
-	[ $__EXIT  -eq 1 ] && {
-		$__CMD		# force syslog before exit
-		exit 1
-	}
-	[ $use_syslog -eq 0 ] && return
-	[ $((use_syslog + __LEVEL)) -le 7 ] && $__CMD
-
-	return
-}
-
-# replace all special chars to their %hex value
-# used for USERNAME and PASSWORD in update_url
-# unchanged: "-"(minus) "_"(underscore) "."(dot) "~"(tilde)
-# to verify: "'"(single quote) '"'(double quote)	# because shell delimiter
-#            "$"(Dollar)				# because used as variable output
-# tested with the following string stored via Luci Application as password / username
-# A B!"#AA$1BB%&'()*+,-./:;<=>?@[\]^_`{|}~	without problems at Dollar or quotes
-urlencode() {
-	# $1	Name of Variable to store encoded string to
-	# $2	string to encode
-	local __STR __LEN __CHAR __OUT
-	local __ENC=""
-	local __POS=1
-
-	[ $# -ne 2 ] && write_log 12 "Error calling 'urlencode()' - wrong number of parameters"
-
-	__STR="$2"		# read string to encode
-	__LEN=${#__STR}		# get string length
-
-	while [ $__POS -le $__LEN ]; do
-		# read one chat of the string
-		__CHAR=$(expr substr "$__STR" $__POS 1)
-
-		case "$__CHAR" in
-		        [-_.~a-zA-Z0-9] )
-				# standard char
-				__OUT="${__CHAR}"
-				;;
-		        * )
-				# special char get %hex code
-		               __OUT=$(printf '%%%02x' "'$__CHAR" )
-				;;
-		esac
-		__ENC="${__ENC}${__OUT}"	# append to encoded string
-		__POS=$(( $__POS + 1 ))		# increment position
-	done
-
-	eval "$1=\"$__ENC\""	# transfer back to variable
-	return 0
-}
-
-# extract url or script for given DDNS Provider from
-# file /etc/ddns/services for IPv4 or from
-# file /etc/ddns/services_ipv6 for IPv6
-# $1	Name of Variable to store url to
-# $2	Name of Variable to store script to
-# $3	Name of Variable to store service answer to
-get_service_data() {
-	[ $# -ne 3 ] && write_log 12 "Error calling 'get_service_data()' - wrong number of parameters"
-
-	__FILE="/etc/ddns/services"				# IPv4
-	[ $use_ipv6 -ne 0 ] && __FILE="/etc/ddns/services_ipv6"	# IPv6
-
-	# workaround with variables; pipe create subshell with no give back of variable content
-	mkfifo pipe_$$
-	# only grep without # or whitespace at linestart | remove "
-#	grep -v -E "(^#|^[[:space:]]*$)" $__FILE | sed -e s/\"//g > pipe_$$ &
-	sed '/^#/d; /^[ \t]*$/d; s/\"//g' $__FILE  > pipe_$$ &
-
-	while read __SERVICE __DATA __ANSWER; do
-		if [ "$__SERVICE" = "$service_name" ]; then
-			# check if URL or SCRIPT is given
-			__URL=$(echo "$__DATA" | grep "^http")
-			[ -z "$__URL" ] && __SCRIPT="/usr/lib/ddns/$__DATA"
-
-			eval "$1=\"$__URL\""
-			eval "$2=\"$__SCRIPT\""
-			eval "$3=\"$__ANSWER\""
-			rm pipe_$$
-			return 0
-		fi
-	done < pipe_$$
-	rm pipe_$$
-
-	eval "$1=\"\""	# no service match clear variables
-	eval "$2=\"\""
-	eval "$3=\"\""
-	return 1
-}
-
-# Calculate seconds from interval and unit
-# $1	Name of Variable to store result in
-# $2	Number and
-# $3	Unit of time interval
-get_seconds() {
-	[ $# -ne 3 ] && write_log 12 "Error calling 'get_seconds()' - wrong number of parameters"
-	case "$3" in
-		"days" )	eval "$1=$(( $2 * 86400 ))";;
-		"hours" )	eval "$1=$(( $2 * 3600 ))";;
-		"minutes" )	eval "$1=$(( $2 * 60 ))";;
-		* )		eval "$1=$2";;
-	esac
-	return 0
-}
-
-timeout() {
-	#.copied from http://www.ict.griffith.edu.au/anthony/software/timeout.sh
-	# only did the following changes
-	#	- commented out "#!/bin/bash" and usage section
-	#	- replace exit by return for usage as function
-	#	- some reformatting
-	#
-	# timeout [-SIG] time [--] command args...
-	#
-	# Run the given command until completion, but kill it if it runs too long.
-	# Specifically designed to exit immediately (no sleep interval) and clean up
-	# nicely without messages or leaving any extra processes when finished.
-	#
-	# Example use
-	#    timeout 5 countdown
-	#
-	# Based on notes in my "Shell Script Hints", section "Command Timeout"
-	#   http://www.ict.griffith.edu.au/~anthony/info/shell/script.hints
-	#
-	# This script uses a lot of tricks to terminate both the background command,
-	# the timeout script, and even the sleep process.  It also includes trap
-	# commands to prevent sub-shells reporting expected "Termination Errors".
-	#
-	# It took years of occasional trials, errors and testing to get a pure bash
-	# timeout command working as well as this does.
-	#
-	#.Anthony Thyssen     6 April 2011
-	#
-#	PROGNAME=$(type $0 | awk '{print $3}')	# search for executable on path
-#	PROGDIR=$(dirname $PROGNAME)		# extract directory of program
-#	PROGNAME=$(basename $PROGNAME)		# base name of program
-
-	# output the script comments as docs
-#	Usage() {
-#		echo >&2 "$PROGNAME:" "$@"
-#		sed >&2 -n '/^###/q; /^#/!q; s/^#//; s/^ //; 3s/^/Usage: /; 2,$ p' "$PROGDIR/$PROGNAME"
-#		exit 10;
-#	}
-
-	SIG=-TERM
-
-	while [ $# -gt 0 ]; do
-		case "$1" in
-			--)
-				# forced end of user options
-				shift;
-				break ;;
-#			-\?|--help|--doc*)
-#				Usage ;;
-			[0-9]*)
-				TIMEOUT="$1" ;;
-			-*)
-				SIG="$1" ;;
-			*)
-				# unforced  end of user options
-				break ;;
-		esac
-		shift	# next option
-	done
-
-	# run main command in backgrounds and get its pid
-	"$@" &
-	command_pid=$!
-
-	# timeout sub-process abort countdown after ABORT seconds! also backgrounded
-	sleep_pid=0
-	(
-		# cleanup sleep process
-		trap 'kill -TERM $sleep_pid; return 1' 1 2 3 15
-		# sleep timeout period in background
-		sleep $TIMEOUT &
-		sleep_pid=$!
-		wait $sleep_pid
-		# Abort the command
-		kill $SIG $command_pid >/dev/null 2>&1
-		return 1
-	) &
-	timeout_pid=$!
-
-	# Wait for main command to finished or be timed out
-	wait $command_pid
-	status=$?
-
-	# Clean up timeout sub-shell - if it is still running!
-	kill $timeout_pid 2>/dev/null
-	wait $timeout_pid 2>/dev/null
-
-	# Uncomment to check if a LONG sleep still running (no sleep should be)
-	# sleep 1
-	# echo "-----------"
-	# /bin/ps j  # uncomment to show if abort "sleep" is still sleeping
-
-	return $status
-}
-
-# verify given host and port is connectable
-# $1	Host/IP to verify
-# $2	Port to verify
-verify_host_port() {
-	local __HOST=$1
-	local __PORT=$2
-	local __NC=$(which nc)
-	local __NCEXT=$($(which nc) --help 2>&1 | grep "\-w" 2>/dev/null)	# busybox nc compiled with extensions
-	local __IP __IPV4 __IPV6 __RUNPROG __PROG __ERR
-	# return codes
-	# 1	system specific error
-	# 2	nslookup/host error
-	# 3	nc (netcat) error
-	# 4	unmatched IP version
-
-	[ $# -ne 2 ] && write_log 12 "Error calling 'verify_host_port()' - wrong number of parameters"
-
-	# check if ip or FQDN was given
-	__IPV4=$(echo $__HOST | grep -m 1 -o "$IPV4_REGEX$")	# do not detect ip in 0.0.0.0.example.com
-	__IPV6=$(echo $__HOST | grep -m 1 -o "$IPV6_REGEX")
-	# if FQDN given get IP address
-	[ -z "$__IPV4" -a -z "$__IPV6" ] && {
-		if [ -n "$BIND_HOST" ]; then	# use BIND host if installed
-			__PROG="BIND host"
-			__RUNPROG="$BIND_HOST $__HOST >$DATFILE 2>$ERRFILE"
-		elif [ -n "$KNOT_HOST" ]; then	# use Knot host if installed
-			__PROG="Knot host"
-			__RUNPROG="$KNOT_HOST $__HOST >$DATFILE 2>$ERRFILE"
-		elif [ -n "$DRILL" ]; then	# use drill if installed
-			__PROG="drill"
-			__RUNPROG="$DRILL -V0 $__HOST A >$DATFILE 2>$ERRFILE"			# IPv4
-			__RUNPROG="$__RUNPROG; $DRILL -V0 $__HOST AAAA >>$DATFILE 2>>$ERRFILE"	# IPv6
-		elif [ -n "$HOSTIP" ]; then	# use hostip if installed
-			__PROG="hostip"
-			__RUNPROG="$HOSTIP $__HOST >$DATFILE 2>$ERRFILE"			# IPv4
-			__RUNPROG="$__RUNPROG; $HOSTIP -6 $__HOST >>$DATFILE 2>>$ERRFILE"	# IPv6
-		else	# use BusyBox nslookup
-			__PROG="BusyBox nslookup"
-			__RUNPROG="$NSLOOKUP $__HOST >$DATFILE 2>$ERRFILE"
-		fi
-		write_log 7 "#> $__RUNPROG"
-		eval $__RUNPROG
-		__ERR=$?
-		# command error
-		[ $__ERR -gt 0 ] && {
-			write_log 3 "DNS Resolver Error - $__PROG Error '$__ERR'"
-			write_log 7 "$(cat $ERRFILE)"
-			return 2
-		}
-		# extract IP address
-		if [ -n "$BIND_HOST" -o -n "$KNOT_HOST" ]; then	# use BIND host or Knot host if installed
-			__IPV4=$(cat $DATFILE | awk -F "address " '/has address/ {print $2; exit}' )
-			__IPV6=$(cat $DATFILE | awk -F "address " '/has IPv6/ {print $2; exit}' )
-		elif [ -n "$DRILL" ]; then	# use drill if installed
-			__IPV4=$(cat $DATFILE | awk '/^'"$lookup_host"'/ {print $5}' | grep -m 1 -o "$IPV4_REGEX")
-			__IPV6=$(cat $DATFILE | awk '/^'"$lookup_host"'/ {print $5}' | grep -m 1 -o "$IPV6_REGEX")
-		elif [ -n "$HOSTIP" ]; then	# use hostip if installed
-			__IPV4=$(cat $DATFILE | grep -m 1 -o "$IPV4_REGEX")
-			__IPV6=$(cat $DATFILE | grep -m 1 -o "$IPV6_REGEX")
-		else	# use BusyBox nslookup
-			__IPV4=$(cat $DATFILE | sed -ne "/^Name:/,\$ { s/^Address[0-9 ]\{0,\}: \($IPV4_REGEX\).*$/\\1/p }")
-			__IPV6=$(cat $DATFILE | sed -ne "/^Name:/,\$ { s/^Address[0-9 ]\{0,\}: \($IPV6_REGEX\).*$/\\1/p }")
-		fi
-	}
-
-	# check IP version if forced
-	if [ $force_ipversion -ne 0 ]; then
-		__ERR=0
-		[ $use_ipv6 -eq 0 -a -z "$__IPV4" ] && __ERR=4
-		[ $use_ipv6 -eq 1 -a -z "$__IPV6" ] && __ERR=6
-		[ $__ERR -gt 0 ] && {
-			[ -n "$LUCI_HELPER" ] && return 4
-			write_log 14 "Verify host Error '4' - Forced IP Version IPv$__ERR don't match"
-		}
-	fi
-
-	# verify nc command
-	# busybox nc compiled without -l option "NO OPT l!" -> critical error
-	$__NC --help 2>&1 | grep -i "NO OPT l!" >/dev/null 2>&1 && \
-		write_log 12 "Busybox nc (netcat) compiled without '-l' option, error 'NO OPT l!'"
-	# busybox nc compiled with extensions
-	$__NC --help 2>&1 | grep "\-w" >/dev/null 2>&1 && __NCEXT="TRUE"
-
-	# connectivity test
-	# run busybox nc to HOST PORT
-	# busybox might be compiled with "FEATURE_PREFER_IPV4_ADDRESS=n"
-	# then nc will try to connect via IPv6 if there is any IPv6 available on any host interface
-	# not worrying, if there is an IPv6 wan address
-	# so if not "force_ipversion" to use_ipv6 then connect test via ipv4, if available
-	[ $force_ipversion -ne 0 -a $use_ipv6 -ne 0 -o -z "$__IPV4" ] && __IP=$__IPV6 || __IP=$__IPV4
-
-	if [ -n "$__NCEXT" ]; then	# BusyBox nc compiled with extensions (timeout support)
-		__RUNPROG="$__NC -w 1 $__IP $__PORT </dev/null >$DATFILE 2>$ERRFILE"
-		write_log 7 "#> $__RUNPROG"
-		eval $__RUNPROG
-		__ERR=$?
-		[ $__ERR -eq 0 ] && return 0
-		write_log 3 "Connect error - BusyBox nc (netcat) Error '$__ERR'"
-		write_log 7 "$(cat $ERRFILE)"
-		return 3
-	else		# nc compiled without extensions (no timeout support)
-		__RUNPROG="timeout 2 -- $__NC $__IP $__PORT </dev/null >$DATFILE 2>$ERRFILE"
-		write_log 7 "#> $__RUNPROG"
-		eval $__RUNPROG
-		__ERR=$?
-		[ $__ERR -eq 0 ] && return 0
-		write_log 3 "Connect error - BusyBox nc (netcat) timeout Error '$__ERR'"
-		return 3
-	fi
-}
-
-# verify given DNS server if connectable
-# $1	DNS server to verify
-verify_dns() {
-	local __ERR=255	# last error buffer
-	local __CNT=0	# error counter
-
-	[ $# -ne 1 ] && write_log 12 "Error calling 'verify_dns()' - wrong number of parameters"
-	write_log 7 "Verify DNS server '$1'"
-
-	while [ $__ERR -ne 0 ]; do
-		# DNS uses port 53
-		verify_host_port "$1" "53"
-		__ERR=$?
-		if [ -n "$LUCI_HELPER" ]; then	# no retry if called by LuCI helper script
-			return $__ERR
-		elif [ $__ERR -ne 0 -a $VERBOSE -gt 1 ]; then	# VERBOSE > 1 then NO retry
-			write_log 4 "Verify DNS server '$1' failed - Verbose Mode: $VERBOSE - NO retry on error"
-			return $__ERR
-		elif [ $__ERR -ne 0 ]; then
-			__CNT=$(( $__CNT + 1 ))	# increment error counter
-			# if error count > retry_count leave here
-			[ $retry_count -gt 0 -a $__CNT -gt $retry_count ] && \
-				write_log 14 "Verify DNS server '$1' failed after $retry_count retries"
-
-			write_log 4 "Verify DNS server '$1' failed - retry $__CNT/$retry_count in $RETRY_SECONDS seconds"
-			sleep $RETRY_SECONDS &
-			PID_SLEEP=$!
-			wait $PID_SLEEP	# enable trap-handler
-			PID_SLEEP=0
-		fi
-	done
-	return 0
-}
-
-# analyze and verify given proxy string
-# $1	Proxy-String to verify
-verify_proxy() {
-	#	complete entry		user:password@host:port
-	# 				inside user and password NO '@' of ":" allowed
-	#	host and port only	host:port
-	#	host only		host		ERROR unsupported
-	#	IPv4 address instead of host	123.234.234.123
-	#	IPv6 address instead of host	[xxxx:....:xxxx]	in square bracket
-	local __TMP __HOST __PORT
-	local __ERR=255	# last error buffer
-	local __CNT=0	# error counter
-
-	[ $# -ne 1 ] && write_log 12 "Error calling 'verify_proxy()' - wrong number of parameters"
-	write_log 7 "Verify Proxy server 'http://$1'"
-
-	# try to split user:password "@" host:port
-	__TMP=$(echo $1 | awk -F "@" '{print $2}')
-	# no "@" found - only host:port is given
-	[ -z "$__TMP" ] && __TMP="$1"
-	# now lets check for IPv6 address
-	__HOST=$(echo $__TMP | grep -m 1 -o "$IPV6_REGEX")
-	# IPv6 host address found read port
-	if [ -n "$__HOST" ]; then
-		# IPv6 split at "]:"
-		__PORT=$(echo $__TMP | awk -F "]:" '{print $2}')
-	else
-		__HOST=$(echo $__TMP | awk -F ":" '{print $1}')
-		__PORT=$(echo $__TMP | awk -F ":" '{print $2}')
-	fi
-	# No Port detected - EXITING
-	[ -z "$__PORT" ] && {
-		[ -n "$LUCI_HELPER" ] && return 5
-		write_log 14 "Invalid Proxy server Error '5' - proxy port missing"
-	}
-
-	while [ $__ERR -gt 0 ]; do
-		verify_host_port "$__HOST" "$__PORT"
-		__ERR=$?
-		if [ -n "$LUCI_HELPER" ]; then	# no retry if called by LuCI helper script
-			return $__ERR
-		elif [ $__ERR -gt 0 -a $VERBOSE -gt 1 ]; then	# VERBOSE > 1 then NO retry
-			write_log 4 "Verify Proxy server '$1' failed - Verbose Mode: $VERBOSE - NO retry on error"
-			return $__ERR
-		elif [ $__ERR -gt 0 ]; then
-			__CNT=$(( $__CNT + 1 ))	# increment error counter
-			# if error count > retry_count leave here
-			[ $retry_count -gt 0 -a $__CNT -gt $retry_count ] && \
-				write_log 14 "Verify Proxy server '$1' failed after $retry_count retries"
-
-			write_log 4 "Verify Proxy server '$1' failed - retry $__CNT/$retry_count in $RETRY_SECONDS seconds"
-			sleep $RETRY_SECONDS &
-			PID_SLEEP=$!
-			wait $PID_SLEEP	# enable trap-handler
-			PID_SLEEP=0
-		fi
-	done
-	return 0
-}
-
-do_transfer() {
-	# $1	# URL to use
-	local __URL="$1"
-	local __ERR=0
-	local __CNT=0	# error counter
-	local __PROG  __RUNPROG
-
-	[ $# -ne 1 ] && write_log 12 "Error in 'do_transfer()' - wrong number of parameters"
-
-	# lets prefer GNU Wget because it does all for us - IPv4/IPv6/HTTPS/PROXY/force IP version
-	if [ -n "$WGET_SSL" -a $USE_CURL -eq 0 ]; then 			# except global option use_curl is set to "1"
-		__PROG="$WGET_SSL -nv -t 1 -O $DATFILE -o $ERRFILE"	# non_verbose no_retry outfile errfile
-		# force network/ip to use for communication
-		if [ -n "$bind_network" ]; then
-			local __BINDIP
-			# set correct program to detect IP
-			[ $use_ipv6 -eq 0 ] && __RUNPROG="network_get_ipaddr" || __RUNPROG="network_get_ipaddr6"
-			eval "$__RUNPROG __BINDIP $bind_network" || \
-				write_log 13 "Can not detect local IP using '$__RUNPROG $bind_network' - Error: '$?'"
-			write_log 7 "Force communication via IP '$__BINDIP'"
-			__PROG="$__PROG --bind-address=$__BINDIP"
-		fi
-		# force ip version to use
-		if [ $force_ipversion -eq 1 ]; then
-			[ $use_ipv6 -eq 0 ] && __PROG="$__PROG -4" || __PROG="$__PROG -6"	# force IPv4/IPv6
-		fi
-		# set certificate parameters
-		if [ $use_https -eq 1 ]; then
-			if [ "$cacert" = "IGNORE" ]; then	# idea from Ticket #15327 to ignore server cert
-				__PROG="$__PROG --no-check-certificate"
-			elif [ -f "$cacert" ]; then
-				__PROG="$__PROG --ca-certificate=${cacert}"
-			elif [ -d "$cacert" ]; then
-				__PROG="$__PROG --ca-directory=${cacert}"
-			elif [ -n "$cacert" ]; then		# it's not a file and not a directory but given
-				write_log 14 "No valid certificate(s) found at '$cacert' for HTTPS communication"
-			fi
-		fi
-		# disable proxy if no set (there might be .wgetrc or .curlrc or wrong environment set)
-		[ -z "$proxy" ] && __PROG="$__PROG --no-proxy"
-
-		__RUNPROG="$__PROG '$__URL'"	# build final command
-		__PROG="GNU Wget"		# reuse for error logging
-
-	# 2nd choice is cURL IPv4/IPv6/HTTPS
-	# libcurl might be compiled without Proxy or HTTPS Support
-	elif [ -n "$CURL" ]; then
-		# CURL_SSL not empty then SSL support available
-		CURL_SSL=$($(which curl) -V 2>/dev/null | grep "Protocols:" | grep -F "https")
-		__PROG="$CURL -RsS -o $DATFILE --stderr $ERRFILE"
-		# check HTTPS support
-		[ -z "$CURL_SSL" -a $use_https -eq 1 ] && \
-			write_log 13 "cURL: libcurl compiled without https support"
-		# force network/interface-device to use for communication
-		if [ -n "$bind_network" ]; then
-			local __DEVICE
-			network_get_physdev __DEVICE $bind_network || \
-				write_log 13 "Can not detect local device using 'network_get_physdev $bind_network' - Error: '$?'"
-			write_log 7 "Force communication via device '$__DEVICE'"
-			__PROG="$__PROG --interface $__DEVICE"
-		fi
-		# force ip version to use
-		if [ $force_ipversion -eq 1 ]; then
-			[ $use_ipv6 -eq 0 ] && __PROG="$__PROG -4" || __PROG="$__PROG -6"	# force IPv4/IPv6
-		fi
-		# set certificate parameters
-		if [ $use_https -eq 1 ]; then
-			if [ "$cacert" = "IGNORE" ]; then	# idea from Ticket #15327 to ignore server cert
-				__PROG="$__PROG --insecure"	# but not empty better to use "IGNORE"
-			elif [ -f "$cacert" ]; then
-				__PROG="$__PROG --cacert $cacert"
-			elif [ -d "$cacert" ]; then
-				__PROG="$__PROG --capath $cacert"
-			elif [ -n "$cacert" ]; then		# it's not a file and not a directory but given
-				write_log 14 "No valid certificate(s) found at '$cacert' for HTTPS communication"
-			fi
-		fi
-		# disable proxy if no set (there might be .wgetrc or .curlrc or wrong environment set)
-		# or check if libcurl compiled with proxy support
-		if [ -z "$proxy" ]; then
-			__PROG="$__PROG --noproxy '*'"
-		elif [ -z "$CURL_PROXY" ]; then
-			# if libcurl has no proxy support and proxy should be used then force ERROR
-			write_log 13 "cURL: libcurl compiled without Proxy support"
-		fi
-
-		__RUNPROG="$__PROG '$__URL'"	# build final command
-		__PROG="cURL"			# reuse for error logging
-
-	# uclient-fetch possibly with ssl support if /lib/libustream-ssl.so installed
-	elif [ -n "$UCLIENT_FETCH" ]; then
-		# UCLIENT_FETCH_SSL not empty then SSL support available
-		UCLIENT_FETCH_SSL=$(find /lib /usr/lib -name libustream-ssl.so* 2>/dev/null)
-		__PROG="$UCLIENT_FETCH -q -O $DATFILE"
-		# force network/ip not supported
-		[ -n "$__BINDIP" ] && \
-			write_log 14 "uclient-fetch: FORCE binding to specific address not supported"
-		# force ip version to use
-		if [ $force_ipversion -eq 1 ]; then
-			[ $use_ipv6 -eq 0 ] && __PROG="$__PROG -4" || __PROG="$__PROG -6"       # force IPv4/IPv6
-		fi
-		# https possibly not supported
-		[ $use_https -eq 1 -a -z "$UCLIENT_FETCH_SSL" ] && \
-			write_log 14 "uclient-fetch: no HTTPS support! Additional install one of ustream-ssl packages"
-		# proxy support
-		[ -z "$proxy" ] && __PROG="$__PROG -Y off" || __PROG="$__PROG -Y on"
-		# https & certificates
-		if [ $use_https -eq 1 ]; then
-			if [ "$cacert" = "IGNORE" ]; then
-				__PROG="$__PROG --no-check-certificate"
-			elif [ -f "$cacert" ]; then
-				__PROG="$__PROG --ca-certificate=$cacert"
-			elif [ -n "$cacert" ]; then		# it's not a file; nothing else supported
-				write_log 14 "No valid certificate file '$cacert' for HTTPS communication"
-			fi
-		fi
-		__RUNPROG="$__PROG '$__URL' 2>$ERRFILE"		# build final command
-		__PROG="uclient-fetch"				# reuse for error logging
-
-	# Busybox Wget or any other wget in search $PATH (did not support neither IPv6 nor HTTPS)
-	elif [ -n "$WGET" ]; then
-		__PROG="$WGET -q -O $DATFILE"
-		# force network/ip not supported
-		[ -n "$__BINDIP" ] && \
-			write_log 14 "BusyBox Wget: FORCE binding to specific address not supported"
-		# force ip version not supported
-		[ $force_ipversion -eq 1 ] && \
-			write_log 14 "BusyBox Wget: Force connecting to IPv4 or IPv6 addresses not supported"
-		# https not supported
-		[ $use_https -eq 1 ] && \
-			write_log 14 "BusyBox Wget: no HTTPS support"
-		# disable proxy if no set (there might be .wgetrc or .curlrc or wrong environment set)
-		[ -z "$proxy" ] && __PROG="$__PROG -Y off"
-
-		__RUNPROG="$__PROG '$__URL' 2>$ERRFILE"		# build final command
-		__PROG="Busybox Wget"				# reuse for error logging
-
-	else
-		write_log 13 "Neither 'Wget' nor 'cURL' nor 'uclient-fetch' installed or executable"
-	fi
-
-	while : ; do
-		write_log 7 "#> $__RUNPROG"
-		eval $__RUNPROG			# DO transfer
-		__ERR=$?			# save error code
-		[ $__ERR -eq 0 ] && return 0	# no error leave
-		[ -n "$LUCI_HELPER" ] && return 1	# no retry if called by LuCI helper script
-
-		write_log 3 "$__PROG Error: '$__ERR'"
-		write_log 7 "$(cat $ERRFILE)"		# report error
-
-		[ $VERBOSE -gt 1 ] && {
-			# VERBOSE > 1 then NO retry
-			write_log 4 "Transfer failed - Verbose Mode: $VERBOSE - NO retry on error"
-			return 1
-		}
-
-		__CNT=$(( $__CNT + 1 ))	# increment error counter
-		# if error count > retry_count leave here
-		[ $retry_count -gt 0 -a $__CNT -gt $retry_count ] && \
-			write_log 14 "Transfer failed after $retry_count retries"
-
-		write_log 4 "Transfer failed - retry $__CNT/$retry_count in $RETRY_SECONDS seconds"
-		sleep $RETRY_SECONDS &
-		PID_SLEEP=$!
-		wait $PID_SLEEP	# enable trap-handler
-		PID_SLEEP=0
-	done
-	# we should never come here there must be a programming error
-	write_log 12 "Error in 'do_transfer()' - program coding error"
-}
-
-send_update() {
-	# $1	# IP to set at DDNS service provider
-	local __IP
-
-	[ $# -ne 1 ] && write_log 12 "Error calling 'send_update()' - wrong number of parameters"
-
-	if [ $upd_privateip -eq 0 ]; then
-		# verify given IP / no private IPv4's / no IPv6 addr starting with fxxx of with ":"
-		[ $use_ipv6 -eq 0 ] && __IP=$(echo $1 | grep -v -E "(^0|^10\.|^100\.6[4-9]\.|^100\.[7-9][0-9]\.|^100\.1[0-1][0-9]\.|^100\.12[0-7]\.|^127|^169\.254|^172\.1[6-9]\.|^172\.2[0-9]\.|^172\.3[0-1]\.|^192\.168)")
-		[ $use_ipv6 -eq 1 ] && __IP=$(echo $1 | grep "^[0-9a-eA-E]")
-	else
-		__IP=$(echo $1 | grep -m 1 -o "$IPV4_REGEX")		# valid IPv4 or
-		[ -z "$__IP" ] && __IP=$(echo $1 | grep -m 1 -o "$IPV6_REGEX")	# IPv6
-	fi
-	[ -z "$__IP" ] && {
-		write_log 3 "No or private or invalid IP '$1' given! Please check your configuration"
-		return 127
-	}
-
-	if [ -n "$update_script" ]; then
-		write_log 7 "parsing script '$update_script'"
-		. $update_script
-	else
-		local __URL __ERR
-
-		# do replaces in URL
-		__URL=$(echo $update_url | sed -e "s#\[USERNAME\]#$URL_USER#g"	-e "s#\[PASSWORD\]#$URL_PASS#g" \
-					       -e "s#\[PARAMENC\]#$URL_PENC#g"	-e "s#\[PARAMOPT\]#$param_opt#g" \
-					       -e "s#\[DOMAIN\]#$domain#g"	-e "s#\[IP\]#$__IP#g")
-		[ $use_https -ne 0 ] && __URL=$(echo $__URL | sed -e 's#^http:#https:#')
-
-		do_transfer "$__URL" || return 1
-
-		write_log 7 "DDNS Provider answered:${N}$(cat $DATFILE)"
-
-		[ -z "$UPD_ANSWER" ] && return 0	# not set then ignore
-
-		grep -i -E "$UPD_ANSWER" $DATFILE >/dev/null 2>&1
-		return $?	# "0" if found
-	fi
-}
-
-get_local_ip () {
-	# $1	Name of Variable to store local IP (LOCAL_IP)
-	local __CNT=0	# error counter
-	local __RUNPROG __DATA __URL __ERR
-
-	[ $# -ne 1 ] && write_log 12 "Error calling 'get_local_ip()' - wrong number of parameters"
-	write_log 7 "Detect local IP on '$ip_source'"
-
-	while : ; do
-		if [ -n "$ip_network" ]; then
-			# set correct program
-			network_flush_cache	# force re-read data from ubus
-			[ $use_ipv6 -eq 0 ] && __RUNPROG="network_get_ipaddr" \
-					    || __RUNPROG="network_get_ipaddr6"
-			eval "$__RUNPROG __DATA $ip_network" || \
-				write_log 13 "Can not detect local IP using $__RUNPROG '$ip_network' - Error: '$?'"
-			[ -n "$__DATA" ] && write_log 7 "Local IP '$__DATA' detected on network '$ip_network'"
-		elif [ -n "$ip_interface" ]; then
-			local __DATA4=""; local __DATA6=""
-			if [ -n "$(which ip)" ]; then		# ip program installed
-				write_log 7 "#> ip -o addr show dev $ip_interface scope global >$DATFILE 2>$ERRFILE"
-				ip -o addr show dev $ip_interface scope global >$DATFILE 2>$ERRFILE
-				__ERR=$?
-				if [ $__ERR -eq 0 ]; then
-					# DATFILE (sample)
-					# 10: l2tp-inet: <POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP> mtu 1456 qdisc fq_codel state UNKNOWN qlen 3\    link/ppp
-					# 10: l2tp-inet    inet 95.30.176.51 peer 95.30.176.1/32 scope global l2tp-inet\       valid_lft forever preferred_lft forever
-					# 5: eth1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP qlen 1000\    link/ether 08:00:27:d0:10:32 brd ff:ff:ff:ff:ff:ff
-					# 5: eth1    inet 172.27.10.128/24 brd 172.27.10.255 scope global eth1\       valid_lft forever preferred_lft forever
-					# 5: eth1    inet 172.55.55.155/24 brd 172.27.10.255 scope global eth1\       valid_lft 12345sec preferred_lft 12345sec
-					# 5: eth1    inet6 2002:b0c7:f326::806b:c629:b8b9:433/128 scope global dynamic \       valid_lft 8026sec preferred_lft 8026sec
-					# 5: eth1    inet6 fd43:5368:6f6d:6500:806b:c629:b8b9:433/128 scope global dynamic \       valid_lft 8026sec preferred_lft 8026sec
-					# 5: eth1    inet6 fd43:5368:6f6d:6500:a00:27ff:fed0:1032/64 scope global dynamic \       valid_lft 14352sec preferred_lft 14352sec
-					# 5: eth1    inet6 2002:b0c7:f326::a00:27ff:fed0:1032/64 scope global dynamic \       valid_lft 14352sec preferred_lft 14352sec
-
-					#    remove      remove     remove      replace     replace
-					#     link     inet6 fxxx    sec      forever=>-1   / => ' ' to separate subnet from ip
-					sed "/link/d; /inet6 f/d; s/sec//g; s/forever/-1/g; s/\// /g" $DATFILE | \
-						awk '{ print $3" "$4" "$NF }' > $ERRFILE	# temp reuse ERRFILE
-					# we only need    inet?   IP  prefered time
-
-					local __TIME4=0;  local __TIME6=0
-					local __TYP __ADR __TIME
-					while read __TYP __ADR __TIME; do
-						__TIME=${__TIME:-0}	# supress shell errors on last (empty) line of DATFILE
-						#    IPversion       no "-1" record stored - now "-1" record or new time > oldtime
-						[ "$__TYP" = "inet6" -a $__TIME6 -ge 0 -a \( $__TIME -lt 0 -o $__TIME -gt $__TIME6 \) ] && {
-							__DATA6="$__ADR"
-							__TIME6="$__TIME"
-						}
-						[ "$__TYP" = "inet" -a $__TIME4 -ge 0 -a \( $__TIME -lt 0 -o $__TIME -gt $__TIME4 \) ] && {
-							__DATA4="$__ADR"
-							__TIME4="$__TIME"
-						}
-					done < $ERRFILE
-				else
-					write_log 3 "ip Error: '$__ERR'"
-					write_log 7 "$(cat $ERRFILE)"		# report error
-				fi
-			else					# use deprecated ifconfig
-				write_log 7 "#> ifconfig $ip_interface >$DATFILE 2>$ERRFILE"
-				ifconfig $ip_interface >$DATFILE 2>$ERRFILE
-				__ERR=$?
-				if [ $__ERR -eq 0 ]; then
-					__DATA4=$(awk '
-						/inet addr:/ {	# Filter IPv4
-						#   inet addr:192.168.1.1  Bcast:192.168.1.255  Mask:255.255.255.0
-						$1="";		# remove inet
-						$3="";		# remove Bcast: ...
-						$4="";		# remove Mask: ...
-						FS=":";		# separator ":"
-						$0=$0;		# reread to activate separator
-						$1="";		# remove addr
-						FS=" ";		# set back separator to default " "
-						$0=$0;		# reread to activate separator (remove whitespaces)
-						print $1;	# print IPv4 addr
-						}' $DATFILE
-					)
-					__DATA6=$(awk '
-						/inet6/ && /: [0-9a-eA-E]/ {	# Filter IPv6 exclude fxxx
-						#   inet6 addr: 2001:db8::xxxx:xxxx/32 Scope:Global
-						FS="/";		# separator "/"
-						$0=$0;		# reread to activate separator
-						$2="";		# remove everything behind "/"
-						FS=" ";		# set back separator to default " "
-						$0=$0;		# reread to activate separator
-						print $3;	# print IPv6 addr
-						}' $DATFILE
-					)
-				else
-					write_log 3 "ifconfig Error: '$__ERR'"
-					write_log 7 "$(cat $ERRFILE)"		# report error
-				fi
-			fi
-			[ $use_ipv6 -eq 0 ] && __DATA="$__DATA4" || __DATA="$__DATA6"
-			[ -n "$__DATA" ] && write_log 7 "Local IP '$__DATA' detected on interface '$ip_interface'"
-		elif [ -n "$ip_script" ]; then
-			write_log 7 "#> $ip_script >$DATFILE 2>$ERRFILE"
-			eval $ip_script >$DATFILE 2>$ERRFILE
-			__ERR=$?
-			if [ $__ERR -eq 0 ]; then
-				__DATA=$(cat $DATFILE)
-				[ -n "$__DATA" ] && write_log 7 "Local IP '$__DATA' detected via script '$ip_script'"
-			else
-				write_log 3 "$ip_script Error: '$__ERR'"
-				write_log 7 "$(cat $ERRFILE)"		# report error
-			fi
-		elif [ -n "$ip_url" ]; then
-			do_transfer "$ip_url"
-			# use correct regular expression
-			[ $use_ipv6 -eq 0 ] \
-				&& __DATA=$(grep -m 1 -o "$IPV4_REGEX" $DATFILE) \
-				|| __DATA=$(grep -m 1 -o "$IPV6_REGEX" $DATFILE)
-			[ -n "$__DATA" ] && write_log 7 "Local IP '$__DATA' detected on web at '$ip_url'"
-		else
-			write_log 12 "Error in 'get_local_ip()' - unhandled ip_source '$ip_source'"
-		fi
-		# valid data found return here
-		[ -n "$__DATA" ] && {
-			eval "$1=\"$__DATA\""
-			return 0
-		}
-
-		[ -n "$LUCI_HELPER" ] && return 1	# no retry if called by LuCI helper script
-
-		write_log 7 "Data detected:"
-		write_log 7 "$(cat $DATFILE)"
-
-		[ $VERBOSE -gt 1 ] && {
-			# VERBOSE > 1 then NO retry
-			write_log 4 "Get local IP via '$ip_source' failed - Verbose Mode: $VERBOSE - NO retry on error"
-			return 1
-		}
-
-		__CNT=$(( $__CNT + 1 ))	# increment error counter
-		# if error count > retry_count leave here
-		[ $retry_count -gt 0 -a $__CNT -gt $retry_count ] && \
-			write_log 14 "Get local IP via '$ip_source' failed after $retry_count retries"
-		write_log 4 "Get local IP via '$ip_source' failed - retry $__CNT/$retry_count in $RETRY_SECONDS seconds"
-		sleep $RETRY_SECONDS &
-		PID_SLEEP=$!
-		wait $PID_SLEEP	# enable trap-handler
-		PID_SLEEP=0
-	done
-	# we should never come here there must be a programming error
-	write_log 12 "Error in 'get_local_ip()' - program coding error"
-}
-
-get_registered_ip() {
-	# $1	Name of Variable to store public IP (REGISTERED_IP)
-	# $2	(optional) if set, do not retry on error
-	local __CNT=0	# error counter
-	local __ERR=255
-	local __REGEX  __PROG  __RUNPROG  __DATA  __IP
-	# return codes
-	# 1	no IP detected
-
-	[ $# -lt 1 -o $# -gt 2 ] && write_log 12 "Error calling 'get_registered_ip()' - wrong number of parameters"
-	[ $is_glue -eq 1 -a -z "$BIND_HOST" ] && write_log 14 "Lookup of glue records is only supported using BIND host"
-	write_log 7 "Detect registered/public IP"
-
-	# set correct regular expression
-	[ $use_ipv6 -eq 0 ] && __REGEX="$IPV4_REGEX" || __REGEX="$IPV6_REGEX"
-
-	if [ -n "$BIND_HOST" ]; then
-		__PROG="$BIND_HOST"
-		[ $use_ipv6 -eq 0 ] && __PROG="$__PROG -t A"  || __PROG="$__PROG -t AAAA"
-		if [ $force_ipversion -eq 1 ]; then			# force IP version
-			[ $use_ipv6 -eq 0 ] && __PROG="$__PROG -4"  || __PROG="$__PROG -6"
-		fi
-		[ $force_dnstcp -eq 1 ] && __PROG="$__PROG -T"	# force TCP
-		[ $is_glue -eq 1 ] && __PROG="$__PROG -v" # use verbose output to get additional section
-
-		__RUNPROG="$__PROG $lookup_host $dns_server >$DATFILE 2>$ERRFILE"
-		__PROG="BIND host"
-	elif [ -n "$KNOT_HOST" ]; then
-		__PROG="$KNOT_HOST"
-		[ $use_ipv6 -eq 0 ] && __PROG="$__PROG -t A"  || __PROG="$__PROG -t AAAA"
-		if [ $force_ipversion -eq 1 ]; then			# force IP version
-			[ $use_ipv6 -eq 0 ] && __PROG="$__PROG -4"  || __PROG="$__PROG -6"
-		fi
-		[ $force_dnstcp -eq 1 ] && __PROG="$__PROG -T"	# force TCP
-
-		__RUNPROG="$__PROG $lookup_host $dns_server >$DATFILE 2>$ERRFILE"
-		__PROG="Knot host"
-	elif [ -n "$DRILL" ]; then
-		__PROG="$DRILL -V0"			# drill options name @server type
-		if [ $force_ipversion -eq 1 ]; then			# force IP version
-			[ $use_ipv6 -eq 0 ] && __PROG="$__PROG -4"  || __PROG="$__PROG -6"
-		fi
-		[ $force_dnstcp -eq 1 ] && __PROG="$__PROG -t" || __PROG="$__PROG -u"	# force TCP
-		__PROG="$__PROG $lookup_host"
-		[ -n "$dns_server" ] && __PROG="$__PROG @$dns_server"
-		[ $use_ipv6 -eq 0 ] && __PROG="$__PROG A"  || __PROG="$__PROG AAAA"
-
-		__RUNPROG="$__PROG >$DATFILE 2>$ERRFILE"
-		__PROG="drill"
-	elif [ -n "$HOSTIP" ]; then	# hostip package installed
-		__PROG="$HOSTIP"
-		[ $force_dnstcp -ne 0 ] && \
-			write_log 14 "hostip - no support for 'DNS over TCP'"
-
-		# is IP given as dns_server ?
-		__IP=$(echo $dns_server | grep -m 1 -o "$IPV4_REGEX")
-		[ -z "$__IP" ] && __IP=$(echo $dns_server | grep -m 1 -o "$IPV6_REGEX")
-
-		# we got NO ip for dns_server, so build command
-		[ -z "$__IP" -a -n "$dns_server" ] && {
-			__IP="\`$HOSTIP"
-			[ $use_ipv6 -eq 1 -a $force_ipversion -eq 1 ] && __IP="$__IP -6"
-			__IP="$__IP $dns_server | grep -m 1 -o"
-			[ $use_ipv6 -eq 1 -a $force_ipversion -eq 1 ] \
-				&& __IP="$__IP '$IPV6_REGEX'" \
-				|| __IP="$__IP '$IPV4_REGEX'"
-			__IP="$__IP \`"
-		}
-
-		[ $use_ipv6 -eq 1 ] && __PROG="$__PROG -6"
-		[ -n "$dns_server" ] && __PROG="$__PROG -r $__IP"
-		__RUNPROG="$__PROG $lookup_host >$DATFILE 2>$ERRFILE"
-		__PROG="hostip"
-	elif [ -n "$NSLOOKUP" ]; then	# last use BusyBox nslookup
-		NSLOOKUP_MUSL=$($(which nslookup) localhost 2>&1 | grep -F "(null)")	# not empty busybox compiled with musl
-		[ $force_dnstcp -ne 0 ] && \
-			write_log 14 "Busybox nslookup - no support for 'DNS over TCP'"
-		[ -n "$NSLOOKUP_MUSL" -a -n "$dns_server" ] && \
-			write_log 14 "Busybox compiled with musl - nslookup don't support the use of DNS Server"
-		[ $force_ipversion -ne 0 ] && \
-			write_log 5 "Busybox nslookup - no support to 'force IP Version' (ignored)"
-
-		__RUNPROG="$NSLOOKUP $lookup_host $dns_server >$DATFILE 2>$ERRFILE"
-		__PROG="BusyBox nslookup"
-	else	# there must be an error
-		write_log 12 "Error in 'get_registered_ip()' - no supported Name Server lookup software accessible"
-	fi
-
-	while : ; do
-		write_log 7 "#> $__RUNPROG"
-		eval $__RUNPROG
-		__ERR=$?
-		if [ $__ERR -ne 0 ]; then
-			write_log 3 "$__PROG error: '$__ERR'"
-			write_log 7 "$(cat $ERRFILE)"
-		else
-			if [ -n "$BIND_HOST" -o -n "$KNOT_HOST" ]; then
-				if [ $is_glue -eq 1 ]; then
-					__DATA=$(cat $DATFILE | grep "^$lookup_host" | grep -om1 "$__REGEX" )
-				else
-					__DATA=$(cat $DATFILE | awk -F "address " '/has/ {print $2; exit}' )
-				fi
-			elif [ -n "$DRILL" ]; then
-				__DATA=$(cat $DATFILE | awk '/^'"$lookup_host"'/ {print $5; exit}' )
-			elif [ -n "$HOSTIP" ]; then
-				__DATA=$(cat $DATFILE | grep -om1 "$__REGEX")
-			elif [ -n "$NSLOOKUP" ]; then
-				__DATA=$(cat $DATFILE | sed -ne "/^Name:/,\$ { s/^Address[0-9 ]\{0,\}: \($__REGEX\).*$/\\1/p }" )
-			fi
-			[ -n "$__DATA" ] && {
-				write_log 7 "Registered IP '$__DATA' detected"
-				[ -z "$IPFILE" ] || echo "$__DATA" > $IPFILE
-				eval "$1=\"$__DATA\""	# valid data found
-				return 0		# leave here
-			}
-			write_log 4 "NO valid IP found"
-			__ERR=127
-		fi
-		[ -z "$IPFILE" ] || echo "" > $IPFILE
-
-		[ -n "$LUCI_HELPER" ] && return $__ERR	# no retry if called by LuCI helper script
-		[ -n "$2" ] && return $__ERR		# $2 is given -> no retry
-		[ $VERBOSE -gt 1 ] && {
-			# VERBOSE > 1 then NO retry
-			write_log 4 "Get registered/public IP for '$lookup_host' failed - Verbose Mode: $VERBOSE - NO retry on error"
-			return $__ERR
-		}
-
-		__CNT=$(( $__CNT + 1 ))	# increment error counter
-		# if error count > retry_count leave here
-		[ $retry_count -gt 0 -a $__CNT -gt $retry_count ] && \
-			write_log 14 "Get registered/public IP for '$lookup_host' failed after $retry_count retries"
-
-		write_log 4 "Get registered/public IP for '$lookup_host' failed - retry $__CNT/$retry_count in $RETRY_SECONDS seconds"
-		sleep $RETRY_SECONDS &
-		PID_SLEEP=$!
-		wait $PID_SLEEP	# enable trap-handler
-		PID_SLEEP=0
-	done
-	# we should never come here there must be a programming error
-	write_log 12 "Error in 'get_registered_ip()' - program coding error"
-}
-
-get_uptime() {
-	# $1	Variable to store result in
-	[ $# -ne 1 ] && write_log 12 "Error calling 'verify_host_port()' - wrong number of parameters"
-	local __UPTIME=$(cat /proc/uptime)
-	eval "$1=\"${__UPTIME%%.*}\""
-}
-
-trap_handler() {
-	# $1	trap signal
-	# $2	optional (exit status)
-	local __PIDS __PID
-	local __ERR=${2:-0}
-	local __OLD_IFS=$IFS
-	local __NEWLINE_IFS='
-' # __NEWLINE_IFS
-
-	[ $PID_SLEEP -ne 0 ] && kill -$1 $PID_SLEEP 2>/dev/null	# kill pending sleep if exist
-
-	case $1 in
-		 0)	if [ $__ERR -eq 0 ]; then
-				write_log 5 "PID '$$' exit normal at $(eval $DATE_PROG)${N}"
-			else
-				write_log 4 "PID '$$' exit WITH ERROR '$__ERR' at $(eval $DATE_PROG)${N}"
-			fi ;;
-		 1)	write_log 6 "PID '$$' received 'SIGHUP' at $(eval $DATE_PROG)"
-			# reload config via starting the script again
-			/usr/lib/ddns/dynamic_dns_updater.sh -v "0" -S "$__SECTIONID" -- start || true
-			exit 0 ;;	# and leave this one
-		 2)	write_log 5 "PID '$$' terminated by 'SIGINT' at $(eval $DATE_PROG)${N}";;
-		 3)	write_log 5 "PID '$$' terminated by 'SIGQUIT' at $(eval $DATE_PROG)${N}";;
-		15)	write_log 5 "PID '$$' terminated by 'SIGTERM' at $(eval $DATE_PROG)${N}";;
-		 *)	write_log 13 "Unhandled signal '$1' in 'trap_handler()'";;
-	esac
-
-	__PIDS=$(pgrep -P $$)	# get my childs (pgrep prints with "newline")
-	IFS=$__NEWLINE_IFS
-	for __PID in $__PIDS; do
-		kill -$1 $__PID	# terminate it
-	done
-	IFS=$__OLD_IFS
-
-	# remove out and err file
-	[ -f $DATFILE ] && rm -f $DATFILE
-	[ -f $ERRFILE ] && rm -f $ERRFILE
-
-	# exit with correct handling:
-	# remove trap handling settings and send kill to myself
-	trap - 0 1 2 3 15
-	[ $1 -gt 0 ] && kill -$1 $$
-}
-
-split_FQDN() {
-	# $1	FQDN to split
-	# $2	name of variable to store TLD
-	# $3	name of variable to store (reg)Domain
-	# $4	name of variable to store Host/Subdomain
-
-	[ $# -ne 4 ] && write_log 12 "Error calling 'split_FQDN()' - wrong number of parameters"
-	[ -z "$1"  ] && write_log 12 "Error calling 'split_FQDN()' - missing FQDN to split"
-	[ -f $TLDFILE ] || write_log 12 "Error calling 'split_FQDN()' - missing file '$TLDFILE'"
-
-	local _HOST _FDOM _CTLD _FTLD
-	local _SET="$@"					# save given function parameters
-
-	local _PAR=$(echo "$1" | tr [A-Z] [a-z] | tr "." " ")	# to lower and replace DOT with SPACE
-	set -- $_PAR					# set new as function parameters
-	_PAR=""						# clear variable for later reuse
-	while [ -n "$1" ] ; do				# as long we have parameters
-		_PAR="$1 $_PAR"				# invert order of parameters
-		shift
-	done
-	set -- $_PAR					# use new as function parameters
-	_PAR=""						# clear variable
-
-	while [ -n "$1" ] ; do				# as long we have parameters
-		if [ -z "$_CTLD" ]; then 		# first loop
-			_CTLD="$1"			# CURRENT TLD to look at
-			shift
-		else
-			_CTLD="$1.$_CTLD"		# Next TLD to look at
-			shift
-		fi
-		# check if TLD exact match in tld_names.dat, save TLD
-		zcat $TLDFILE | grep -E "^$_CTLD$" >/dev/null 2>&1 && {
-			_FTLD="$_CTLD"		# save found
-			_FDOM="$1"		# save domain next step might be invalid
-			continue
-		}
-		# check if match any "*" in tld_names.dat,
-		zcat $TLDFILE | grep -E "^\*.$_CTLD$" >/dev/null 2>&1 && {
-			[ -z "$1" ] && break	# no more data break
-			# check if next level TLD match excludes "!" in tld_names.dat
-			if zcat $TLDFILE | grep -E "^!$1.$_CTLD$" >/dev/null 2>&1 ; then
-				_FTLD="$_CTLD"	# Yes
-			else
-				_FTLD="$1.$_CTLD"
-				shift
-			fi
-			_FDOM="$1"; shift
-		}
-		[ -n "$_FTLD" ] && break	# we have something valid, break
-	done
-
-	# the leftover parameters are the HOST/SUBDOMAIN
-	while [ -n "$1" ]; do
-		_HOST="$1 $_HOST"		# remember we need to invert
-		shift
-	done
-	_HOST=$(echo $_HOST | tr " " ".")	# insert DOT
-
-	set -- $_SET				# set back parameters from function call
-	[ -n "$_FTLD" ] && {
-		eval "$2=$_FTLD"		# set TLD
-		eval "$3=$_FDOM"		# set registrable domain
-		eval "$4=$_HOST"		# set HOST/SUBDOMAIN
-		return 0
-	}
-	eval "$2=''"		# clear TLD
-	eval "$3=''"		# clear registrable domain
-	eval "$4=''"		# clear HOST/SUBDOMAIN
-	return 1
-}
-
-expand_ipv6() {
-	# Original written for bash by
-	#.Author:  Florian Streibelt <florian@f-streibelt.de>
-	# Date:    08.04.2012
-	# License: Public Domain, but please be fair and
-	#          attribute the original author(s) and provide
-	#          a link to the original source for corrections:
-	#.         https://github.com/mutax/IPv6-Address-checks
-
-	# $1	IPv6 to expand
-	# $2	name of variable to store expanded IPv6
-	[ $# -ne 2 ] && write_log 12 "Error calling 'expand_ipv6()' - wrong number of parameters"
-
-	INPUT="$(echo "$1" | tr 'A-F' 'a-f')"
-	[ "$INPUT" = "::" ] && INPUT="::0"	# special case ::
-
-	O=""
-
-	while [ "$O" != "$INPUT" ]; do
-		O="$INPUT"
-
-		# fill all words with zeroes
-		INPUT=$( echo "$INPUT" | sed	-e 's|:\([0-9a-f]\{3\}\):|:0\1:|g' \
-						-e 's|:\([0-9a-f]\{3\}\)$|:0\1|g' \
-						-e 's|^\([0-9a-f]\{3\}\):|0\1:|g' \
-						-e 's|:\([0-9a-f]\{2\}\):|:00\1:|g' \
-						-e 's|:\([0-9a-f]\{2\}\)$|:00\1|g' \
-						-e 's|^\([0-9a-f]\{2\}\):|00\1:|g' \
-						-e 's|:\([0-9a-f]\):|:000\1:|g' \
-						-e 's|:\([0-9a-f]\)$|:000\1|g' \
-						-e 's|^\([0-9a-f]\):|000\1:|g' )
-
-	done
-
-	# now expand the ::
-	ZEROES=""
-
-	echo "$INPUT" | grep -qs "::"
-	if [ "$?" -eq 0 ]; then
-		GRPS="$( echo "$INPUT" | sed  's|[0-9a-f]||g' | wc -m )"
-		GRPS=$(( GRPS-1 ))		# remove carriage return
-		MISSING=$(( 8-GRPS ))
-		while [ $MISSING -gt 0 ]; do
-			ZEROES="$ZEROES:0000"
-			MISSING=$(( MISSING-1 ))
-		done
-
-		# be careful where to place the :
-		INPUT=$( echo "$INPUT" | sed	-e 's|\(.\)::\(.\)|\1'$ZEROES':\2|g' \
-						-e 's|\(.\)::$|\1'$ZEROES':0000|g' \
-						-e 's|^::\(.\)|'$ZEROES':0000:\1|g;s|^:||g' )
-	fi
-
-	# an expanded address has 39 chars + CR
-	if [ $(echo $INPUT | wc -m) != 40 ]; then
-		write_log 4 "Error in 'expand_ipv6()' - invalid IPv6 found: '$1' expanded: '$INPUT'"
-		eval "$2='invalid'"
-		return 1
-	fi
-
-	# echo the fully expanded version of the address
-	eval "$2=$INPUT"
-	return 0
-}
diff --recursive --unified --new-file --no-dereference orig/dynamic_dns_lucihelper.sh src/dynamic_dns_lucihelper.sh
--- orig/dynamic_dns_lucihelper.sh	2023-11-08 12:46:52.000000000 +0000
+++ src/dynamic_dns_lucihelper.sh	1970-01-01 00:00:00.000000000 +0000
@@ -1,172 +0,0 @@
-#!/bin/sh
-# /usr/lib/ddns/dynamic_dns_lucihelper.sh
-#
-#.Distributed under the terms of the GNU General Public License (GPL) version 2.0
-#.2014-2018 Christian Schoenebeck <christian dot schoenebeck at gmail dot com>
-# This script is used by luci-app-ddns
-#
-# variables in small chars are read from /etc/config/ddns as parameter given here
-# variables in big chars are defined inside these scripts as gloval vars
-# variables in big chars beginning with "__" are local defined inside functions only
-# set -vx  	#script debugger
-
-. /usr/lib/ddns/dynamic_dns_functions.sh	# global vars are also defined here
-
-usage() {
-	cat << EOF
-
-Usage:
- $MYPROG [options] -- command
-
-Commands:
- get_local_ip        using given INTERFACE or NETWORK or SCRIPT or URL
- get_registered_ip   for given FQDN
- verify_dns          given DNS-SERVER
- verify_proxy        given PROXY
- start               start given SECTION
- reload              force running ddns processes to reload changed configuration
- restart             restart all ddns processes
-
-Parameters:
- -6                  => use_ipv6=1          (default 0)
- -d DNS-SERVER       => dns_server=SERVER[:PORT]
- -f                  => force_ipversion=1   (default 0)
- -g                  => is_glue=1           (default 0)
- -i INTERFACE        => ip_interface=INTERFACE; ip_source="interface"
- -l FQDN             => lookup_host=FQDN
- -n NETWORK          => ip_network=NETWORK; ip_source="network"
- -p PROXY            => proxy=[USER:PASS@]PROXY:PORT
- -s SCRIPT           => ip_script=SCRIPT; ip_source="script"
- -t                  => force_dnstcp=1      (default 0)
- -u URL              => ip_url=URL; ip_source="web"
- -S SECTION          SECTION to start
-
- -h                  => show this help and exit
- -L                  => use_logfile=1    (default 0)
- -v LEVEL            => VERBOSE=LEVEL    (default 0)
- -V                  => show version and exit
-
-EOF
-}
-
-usage_err() {
-	printf %s\\n "$MYPROG: $@" >&2
-	usage >&2
-	exit 255
-}
-
-# preset some variables, wrong or not set in ddns-functions.sh
-SECTION_ID="lucihelper"
-LOGFILE="$ddns_logdir/$SECTION_ID.log"
-DATFILE="$ddns_rundir/$SECTION_ID.$$.dat"	# save stdout data of WGet and other extern programs called
-ERRFILE="$ddns_rundir/$SECTION_ID.$$.err"	# save stderr output of WGet and other extern programs called
-DDNSPRG="/usr/lib/ddns/dynamic_dns_updater.sh"
-VERBOSE=0		# no console logging
-# global variables normally set by reading DDNS UCI configuration
-use_syslog=0		# no syslog
-use_logfile=0		# no logfile
-
-use_ipv6=0		# Use IPv6 - default IPv4
-force_ipversion=0	# Force IP Version - default 0 - No
-force_dnstcp=0		# Force TCP on DNS - default 0 - No
-is_glue=0		# Is glue record - default 0 - No
-use_https=0		# not needed but must be set
-
-while getopts ":6d:fghi:l:n:p:s:S:tu:Lv:V" OPT; do
-	case "$OPT" in
-		6)	use_ipv6=1;;
-		d)	dns_server="$OPTARG";;
-		f)	force_ipversion=1;;
-		g)	is_glue=1;;
-		i)	ip_interface="$OPTARG"; ip_source="interface";;
-		l)	lookup_host="$OPTARG";;
-		n)	ip_network="$OPTARG"; ip_source="network";;
-		p)	proxy="$OPTARG";;
-		s)	ip_script="$OPTARG"; ip_source="script";;
-		t)	force_dnstcp=1;;
-		u)	ip_url="$OPTARG"; ip_source="web";;
-		h)	usage; exit 255;;
-		L)	use_logfile=1;;
-		v)	VERBOSE=$OPTARG;;
-		S)	SECTION=$OPTARG;;
-		V)	printf %s\\n "ddns-scripts $VERSION"; exit 255;;
-		:)	usage_err "option -$OPTARG missing argument";;
-		\?)	usage_err "invalid option -$OPTARG";;
-		*)	usage_err "unhandled option -$OPT $OPTARG";;
-	esac
-done
-shift $((OPTIND - 1 ))	# OPTIND is 1 based
-
-[ $# -eq 0 ] && usage_err "missing command"
-
-__RET=0
-case "$1" in
-	get_registered_ip)
-		[ -z "$lookup_host" ] && usage_err "command 'get_registered_ip': 'lookup_host' not set" 
-		write_log 7 "-----> get_registered_ip IP"
-		[ -z "$SECTION" ] || IPFILE="$ddns_rundir/$SECTION.ip"
-		IP=""
-		get_registered_ip IP
-		__RET=$?
-		[ $__RET -ne 0 ] && IP=""
-		printf "%s" "$IP"
-		;;
-	verify_dns)
-		[ -z "$dns_server" ] && usage_err "command 'verify_dns': 'dns_server' not set" 
-		write_log 7 "-----> verify_dns '$dns_server'"
-		verify_dns "$dns_server"
-		__RET=$?
-		;;
-	verify_proxy)
-		[ -z "$proxy" ] && usage_err "command 'verify_proxy': 'proxy' not set" 
-		write_log 7 "-----> verify_proxy '$proxy'"
-		verify_proxy "$proxy"
-		__RET=$?
-		;;
-	get_local_ip)
-		[ -z "$ip_source" ] && usage_err "command 'get_local_ip': 'ip_source' not set" 
-		[ -n "$proxy" -a "$ip_source" = "web" ] && {
-			# proxy defined, used for ip_source=web
-			export HTTP_PROXY="http://$proxy"
-			export HTTPS_PROXY="http://$proxy"
-			export http_proxy="http://$proxy"
-			export https_proxy="http://$proxy"
-		}
-		# don't need IP only the return code
-		IP=""
-		if [ "$ip_source" = "web" -o  "$ip_source" = "script" ]; then
-			# we wait only 3 seconds for an
-			# answer from "web" or "script"
-			write_log 7 "-----> timeout 3 -- get_local_ip IP"
-			timeout 3 -- get_local_ip IP
-		else
-			write_log 7 "-----> get_local_ip IP"
-			get_local_ip IP
-		fi
-		__RET=$?
-		;;
-	start)
-		[ -z "$SECTION" ] &&  usage_err "command 'start': 'SECTION' not set"
-		if [ $VERBOSE -eq 0 ]; then	# start in background
-			$DDNSPRG -v 0 -S $SECTION -- start &
-		else
-			$DDNSPRG -v $VERBOSE -S $SECTION -- start
-		fi
-		;;
-	reload)
-		$DDNSPRG -- reload
-		;;
-	restart)
-		$DDNSPRG -- stop
-		sleep 1
-		$DDNSPRG -- start
-		;;
-	*)
-		__RET=255
-		;;
-esac
-
-# remove out and err file
-[ -f $DATFILE ] && rm -f $DATFILE
-[ -f $ERRFILE ] && rm -f $ERRFILE
-return $__RET
diff --recursive --unified --new-file --no-dereference orig/dynamic_dns_updater.sh src/dynamic_dns_updater.sh
--- orig/dynamic_dns_updater.sh	2023-11-08 12:46:52.000000000 +0000
+++ src/dynamic_dns_updater.sh	1970-01-01 00:00:00.000000000 +0000
@@ -1,420 +0,0 @@
-#!/bin/sh
-# /usr/lib/ddns/dynamic_dns_updater.sh
-#
-#.Distributed under the terms of the GNU General Public License (GPL) version 2.0
-# Original written by Eric Paul Bishop, January 2008
-# (Loosely) based on the script on the one posted by exobyte in the forums here:
-# http://forum.openwrt.org/viewtopic.php?id=14040
-# extended and partial rewritten
-#.2014-2018 Christian Schoenebeck <christian dot schoenebeck at gmail dot com>
-#
-# variables in small chars are read from /etc/config/ddns
-# variables in big chars are defined inside these scripts as global vars
-# variables in big chars beginning with "__" are local defined inside functions only
-# set -vx  	#script debugger
-
-. $(dirname $0)/dynamic_dns_functions.sh	# global vars are also defined here
-
-usage() {
-	cat << EOF
-
-Usage:
- $MYPROG [options] -- command
-
-Commands:
-start                Start SECTION or NETWORK or all
-stop                 Stop NETWORK or all
-
-Parameters:
- -n NETWORK          Start/Stop sections in background monitoring NETWORK, force VERBOSE=0
- -S SECTION          SECTION to start
-                     use either -N NETWORK or -S SECTION
-
- -h                  show this help and exit
- -V                  show version and exit
- -v LEVEL            VERBOSE=LEVEL (default 1)
-                        '0' NO output to console
-                        '1' output to console
-                        '2' output to console AND logfile
-                            + run once WITHOUT retry on error
-                        '3' output to console AND logfile
-                            + run once WITHOUT retry on error
-                            + NOT sending update to DDNS service
-
-EOF
-}
-
-usage_err() {
-	printf %s\\n "$MYPROG: $@" >&2
-	usage >&2
-	exit 1
-}
-
-while getopts ":hv:n:S:V" OPT; do
-	case "$OPT" in
-		h)	usage; exit 0;;
-		v)	VERBOSE=$OPTARG;;
-		n)	NETWORK=$OPTARG;;
-		S)	SECTION_ID=$OPTARG;;
-		V)	printf %s\\n "ddns-scripts $VERSION"; exit 0;;
-		:)	usage_err "option -$OPTARG missing argument";;
-		\?)	usage_err "invalid option -$OPTARG";;
-		*)	usage_err "unhandled option -$OPT $OPTARG";;
-	esac
-done
-shift $((OPTIND - 1 ))	# OPTIND is 1 based
-
-[ -n "$NETWORK" -a -n "$SECTION_ID" ] && usage_err "use either option '-N' or '-S' not both"
-[ $# -eq 0 ] && usage_err "missing command"
-[ $# -gt 1 ] && usage_err "to much commands"
-
-case "$1" in
-	start)
-		if [ -n "$NETWORK" ]; then
-			start_daemon_for_all_ddns_sections "$NETWORK"
-			exit 0
-		fi
-		if [ -z "$SECTION_ID" ]; then
-			start_daemon_for_all_ddns_sections
-			exit 0
-		fi
-		;;
-	stop)
-		if [ -n "$INTERFACE" ]; then
-			stop_daemon_for_all_ddns_sections "$NETWORK"
-			exit 0
-		else
-			stop_daemon_for_all_ddns_sections
-			exit 0
-		fi
-		exit 1
-		;;
-	reload)
-		killall -1 dynamic_dns_updater.sh 2>/dev/null
-		exit $?
-		;;
-	*)	usage_err "unknown command - $1";;
-esac
-
-# set file names
-PIDFILE="$ddns_rundir/$SECTION_ID.pid"	# Process ID file
-UPDFILE="$ddns_rundir/$SECTION_ID.update"	# last update successful send (system uptime)
-DATFILE="$ddns_rundir/$SECTION_ID.dat"	# save stdout data of WGet and other extern programs called
-ERRFILE="$ddns_rundir/$SECTION_ID.err"	# save stderr output of WGet and other extern programs called
-IPFILE="$ddns_rundir/$SECTION_ID.ip"	#
-LOGFILE="$ddns_logdir/$SECTION_ID.log"	# log file
-
-# VERBOSE > 1 delete logfile if exist to create an empty one
-# only with this data of this run for easier diagnostic
-# new one created by write_log function
-[ $VERBOSE -gt 1 -a -f $LOGFILE ] && rm -f $LOGFILE
-
-# TRAP handler
-trap "trap_handler 0 \$?" 0	# handle script exit with exit status
-trap "trap_handler 1"  1	# SIGHUP	Hangup / reload config
-trap "trap_handler 2"  2	# SIGINT	Terminal interrupt
-trap "trap_handler 3"  3	# SIGQUIT	Terminal quit
-# trap "trap_handler 9"  9	# SIGKILL	no chance to trap
-trap "trap_handler 15" 15	# SIGTERM	Termination
-
-################################################################################
-# Leave this comment here, to clearly document variable names that are expected/possible
-# Use load_all_config_options to load config options, which is a much more flexible solution.
-#
-# config_load "ddns"
-# config_get <variable> $SECTION_ID <option>
-#
-# defined options (also used as variable):
-#
-# enabled	self-explanatory
-# interface 	network interface used by hotplug.d i.e. 'wan' or 'wan6'
-#
-# service_name	Which DDNS service do you use or "custom"
-# update_url	URL to use to update your "custom" DDNS service
-# update_script SCRIPT to use to update your "custom" DDNS service
-#
-# lookup_host	FQDN of ONE of your at DDNS service defined host / required to validate if IP update happen/necessary
-# domain 	Nomally your DDNS hostname / replace [DOMAIN] in update_url
-# username 	Username of your DDNS service account / urlenceded and replace [USERNAME] in update_url
-# password 	Password of your DDNS service account / urlencoded and replace [PASSWORD] in update_url
-# param_enc	Optional parameter for (later) usage  / urlencoded and replace [PARAMENC] in update_url
-# param_opt	Optional parameter for (later) usage  / replace [PARAMOPT] in update_url
-#
-# use_https	use HTTPS to update DDNS service
-# cacert	file or directory where HTTPS can find certificates to verify server; 'IGNORE' ignore check of server certificate
-#
-# use_syslog	log activity to syslog
-#
-# ip_source	source to detect current local IP ('network' or 'web' or 'script' or 'interface')
-# ip_network	local defined network to read IP from i.e. 'wan' or 'wan6'
-# ip_url	URL to read local address from i.e. http://checkip.dyndns.com/ or http://checkipv6.dyndns.com/
-# ip_script	full path and name of your script to detect local IP
-# ip_interface	physical interface to use for detecting
-#
-# check_interval	check for changes every  !!! checks below 10 minutes make no sense because the Internet
-# check_unit		'days' 'hours' 'minutes' !!! needs about 5-10 minutes to sync an IP-change for an DNS entry
-#
-# force_interval	force to send an update to your service if no change was detected
-# force_unit		'days' 'hours' 'minutes' !!! force_interval="0" runs this script once for use i.e. with cron
-#
-# retry_interval	if error was detected retry in
-# retry_unit		'days' 'hours' 'minutes' 'seconds'
-# retry_count 		number of retries before scripts stops
-#
-# use_ipv6		detecting/sending IPv6 address
-# force_ipversion	force usage of IPv4 or IPv6 for the whole detection and update communication
-# dns_server		using a non default dns server to get Registered IP from Internet
-# force_dnstcp		force communication with DNS server via TCP instead of default UDP
-# proxy			using a proxy for communication !!! ALSO used to detect local IP via web => return proxy's IP !!!
-# use_logfile		self-explanatory "/var/log/ddns/$SECTION_ID.log"
-# is_glue			the record that should be updated is a glue record
-#
-# some functionality needs
-# - GNU Wget or cURL installed for sending updates to DDNS service
-# - BIND host installed to detect Registered IP
-#
-################################################################################
-
-load_all_config_options "ddns" "$SECTION_ID"
-ERR_LAST=$?	# save return code - equal 0 if SECTION_ID found
-
-# set defaults if not defined
-[ -z "$enabled" ]	  && enabled=0
-[ -z "$retry_count" ]	  && retry_count=0	# endless retry
-[ -z "$use_syslog" ]      && use_syslog=2	# syslog "Notice"
-[ -z "$use_https" ]       && use_https=0	# not use https
-[ -z "$use_logfile" ]     && use_logfile=1	# use logfile by default
-[ -z "$use_ipv6" ]	  && use_ipv6=0		# use IPv4 by default
-[ -z "$force_ipversion" ] && force_ipversion=0	# default let system decide
-[ -z "$force_dnstcp" ]	  && force_dnstcp=0	# default UDP
-[ -z "$ip_source" ]	  && ip_source="network"
-[ -z "$is_glue" ]	  && is_glue=0		# default the ddns record is not a glue record
-[ "$ip_source" = "network" -a -z "$ip_network" -a $use_ipv6 -eq 0 ] && ip_network="wan"  # IPv4: default wan
-[ "$ip_source" = "network" -a -z "$ip_network" -a $use_ipv6 -eq 1 ] && ip_network="wan6" # IPv6: default wan6
-[ "$ip_source" = "web" -a -z "$ip_url" -a $use_ipv6 -eq 0 ] && ip_url="http://checkip.dyndns.com"
-[ "$ip_source" = "web" -a -z "$ip_url" -a $use_ipv6 -eq 1 ] && ip_url="http://checkipv6.dyndns.com"
-[ "$ip_source" = "interface" -a -z "$ip_interface" ] && ip_interface="eth1"
-
-# url encode username (might be email or something like this)
-# and password (might have special chars for security reason)
-# and optional parameter "param_enc"
-[ -n "$username" ] && urlencode URL_USER "$username"
-[ -n "$password" ] && urlencode URL_PASS "$password"
-[ -n "$param_enc" ] && urlencode URL_PENC "$param_enc"
-
-# SECTION_ID does not exists
-[ $ERR_LAST -ne 0 ] && {
-	[ $VERBOSE -le 1 ] && VERBOSE=2		# force console out and logfile output
-	[ -f $LOGFILE ] && rm -f $LOGFILE	# clear logfile before first entry
-	write_log  7 "************ ************** ************** **************"
-	write_log  5 "PID '$$' started at $(eval $DATE_PROG)"
-	write_log  7 "ddns version  : $VERSION"
-	write_log  7 "uci configuration:${N}$(uci -q show ddns | grep '=service' | sort)"
-	write_log 14 "Service section '$SECTION_ID' not defined"
-}
-
-write_log 7 "************ ************** ************** **************"
-write_log 5 "PID '$$' started at $(eval $DATE_PROG)"
-write_log 7 "ddns version  : $VERSION"
-write_log 7 "uci configuration:${N}$(uci -q show ddns.$SECTION_ID | sort)"
-# write_log 7 "ddns version  : $(opkg list-installed ddns-scripts | cut -d ' ' -f 3)"
-case $VERBOSE in
-	0) write_log  7 "verbose mode  : 0 - run normal, NO console output";;
-	1) write_log  7 "verbose mode  : 1 - run normal, console mode";;
-	2) write_log  7 "verbose mode  : 2 - run once, NO retry on error";;
-	3) write_log  7 "verbose mode  : 3 - run once, NO retry on error, NOT sending update";;
-	*) write_log 14 "error detecting VERBOSE '$VERBOSE'";;
-esac
-
-# check enabled state otherwise we don't need to continue
-[ $enabled -eq 0 ] && write_log 14 "Service section disabled!"
-
-# determine what update url we're using if a service_name is supplied
-# otherwise update_url is set inside configuration (custom update url)
-# or update_script is set inside configuration (custom update script)
-[ -n "$service_name" ] && get_service_data update_url update_script UPD_ANSWER
-[ -z "$update_url" -a -z "$update_script" ] && write_log 14 "No update_url found/defined or no update_script found/defined!"
-[ -n "$update_script" -a ! -f "$update_script" ] && write_log 14 "Custom update_script not found!"
-
-# temporary needed to convert existing uci settings
-[ -z "$lookup_host" ] && {
-	uci -q set ddns.$SECTION_ID.lookup_host="$domain"
-	uci -q commit ddns
-	lookup_host="$domain"
-}
-# later versions only check if configured correctly
-
-# without lookup host and possibly other required options we can do nothing for you
-[ -z "$lookup_host" ] && write_log 14 "Service section not configured correctly! Missing 'lookup_host'"
-
-[ -n "$update_url" ] && {
-	# only check if update_url is given, update_scripts have to check themselves
-	[ -z "$domain" ] && $(echo "$update_url" | grep "\[DOMAIN\]" >/dev/null 2>&1) && \
-		write_log 14 "Service section not configured correctly! Missing 'domain'"
-	[ -z "$username" ] && $(echo "$update_url" | grep "\[USERNAME\]" >/dev/null 2>&1) && \
-		write_log 14 "Service section not configured correctly! Missing 'username'"
-	[ -z "$password" ] && $(echo "$update_url" | grep "\[PASSWORD\]" >/dev/null 2>&1) && \
-		write_log 14 "Service section not configured correctly! Missing 'password'"
-	[ -z "$param_enc" ] && $(echo "$update_url" | grep "\[PARAMENC\]" >/dev/null 2>&1) && \
-		write_log 14 "Service section not configured correctly! Missing 'param_enc'"
-	[ -z "$param_opt" ] && $(echo "$update_url" | grep "\[PARAMOPT\]" >/dev/null 2>&1) && \
-		write_log 14 "Service section not configured correctly! Missing 'param_opt'"
-}
-
-# verify ip_source 'script' if script is configured and executable
-if [ "$ip_source" = "script" ]; then
-	set -- $ip_script	#handling script with parameters, we need a trick
-	[ -z "$1" ] && write_log 14 "No script defined to detect local IP!"
-	[ -x "$1" ] || write_log 14 "Script to detect local IP not executable!"
-fi
-
-# compute update interval in seconds
-get_seconds CHECK_SECONDS ${check_interval:-10} ${check_unit:-"minutes"} # default 10 min
-get_seconds FORCE_SECONDS ${force_interval:-72} ${force_unit:-"hours"}	 # default 3 days
-get_seconds RETRY_SECONDS ${retry_interval:-60} ${retry_unit:-"seconds"} # default 60 sec
-[ $CHECK_SECONDS -lt 300 ] && CHECK_SECONDS=300		# minimum 5 minutes
-[ $FORCE_SECONDS -gt 0 -a $FORCE_SECONDS -lt $CHECK_SECONDS ] && FORCE_SECONDS=$CHECK_SECONDS	# FORCE_SECONDS >= CHECK_SECONDS or 0
-write_log 7 "check interval: $CHECK_SECONDS seconds"
-write_log 7 "force interval: $FORCE_SECONDS seconds"
-write_log 7 "retry interval: $RETRY_SECONDS seconds"
-write_log 7 "retry counter : $retry_count times"
-
-# kill old process if it exists & set new pid file
-stop_section_processes "$SECTION_ID"
-[ $? -gt 0 ] && write_log 7 "'SIGTERM' was send to old process" || write_log 7 "No old process"
-echo $$ > $PIDFILE
-
-# determine when the last update was
-# the following lines should prevent multiple updates if hotplug fires multiple startups
-# as described in Ticket #7820, but did not function if never an update take place
-# i.e. after a reboot (/var is linked to /tmp)
-# using uptime as reference because date might not be updated via NTP client
-get_uptime CURR_TIME
-[ -e "$UPDFILE" ] && {
-	LAST_TIME=$(cat $UPDFILE)
-	# check also LAST > CURR because link of /var/run to /tmp might be removed
-	# i.e. boxes with larger filesystems
-	[ -z "$LAST_TIME" ] && LAST_TIME=0
-	[ $LAST_TIME -gt $CURR_TIME ] && LAST_TIME=0
-}
-if [ $LAST_TIME -eq 0 ]; then
-	write_log 7 "last update: never"
-else
-	EPOCH_TIME=$(( $(date +%s) - $CURR_TIME + $LAST_TIME ))
-	EPOCH_TIME="date -d @$EPOCH_TIME +'$ddns_dateformat'"
-	write_log 7 "last update: $(eval $EPOCH_TIME)"
-fi
-
-# verify DNS server
-[ -n "$dns_server" ] && verify_dns "$dns_server"
-
-# verify Proxy server and set environment
-[ -n "$proxy" ] && {
-	verify_proxy "$proxy" && {
-		# everything ok set proxy
-		export HTTP_PROXY="http://$proxy"
-		export HTTPS_PROXY="http://$proxy"
-		export http_proxy="http://$proxy"
-		export https_proxy="http://$proxy"
-	}
-}
-
-# let's check if there is already an IP registered on the web
-get_registered_ip REGISTERED_IP "NO_RETRY"
-ERR_LAST=$?
-#     No error    or     No IP set	 otherwise retry
-[ $ERR_LAST -eq 0 -o $ERR_LAST -eq 127 ] || get_registered_ip REGISTERED_IP
-# on IPv6 we use expanded version to be shure when comparing
-[ $use_ipv6 -eq 1 ] && expand_ipv6 "$REGISTERED_IP" REGISTERED_IP
-
-# loop endlessly, checking ip every check_interval and forcing an updating once every force_interval
-write_log 6 "Starting main loop at $(eval $DATE_PROG)"
-while : ; do
-
-	get_local_ip LOCAL_IP		# read local IP
-	[ $use_ipv6 -eq 1 ] && expand_ipv6 "$LOCAL_IP" LOCAL_IP	# on IPv6 we use expanded version
-
-	# prepare update
-	# never updated or forced immediate then NEXT_TIME = 0
-	[ $FORCE_SECONDS -eq 0 -o $LAST_TIME -eq 0 ] \
-		&& NEXT_TIME=0 \
-		|| NEXT_TIME=$(( $LAST_TIME + $FORCE_SECONDS ))
-
-	get_uptime CURR_TIME		# get current uptime
-
-	# send update when current time > next time or local ip different from registered ip
-	if [ $CURR_TIME -ge $NEXT_TIME -o "$LOCAL_IP" != "$REGISTERED_IP" ]; then
-		if [ $VERBOSE -gt 2 ]; then
-			write_log 7 "Verbose Mode: $VERBOSE - NO UPDATE send"
-		elif [ "$LOCAL_IP" != "$REGISTERED_IP" ]; then
-			write_log 7 "Update needed - L: '$LOCAL_IP' <> R: '$REGISTERED_IP'"
-		else
-			write_log 7 "Forced Update - L: '$LOCAL_IP' == R: '$REGISTERED_IP'"
-		fi
-
-		ERR_LAST=0
-		[ $VERBOSE -lt 3 ] && {
-			# only send if VERBOSE < 3
-			send_update "$LOCAL_IP"
-			ERR_LAST=$?	# save return value
-		}
-
-		# error sending local IP to provider
-		# we have no communication error (handled inside send_update/do_transfer)
-		# but update was not recognized
-		# do NOT retry after RETRY_SECONDS, do retry after CHECK_SECONDS
-		# to early retrys will block most DDNS provider
-		# providers answer is checked inside send_update() function
-		if [ $ERR_LAST -eq 0 ]; then
-			get_uptime LAST_TIME		# we send update, so
-			echo $LAST_TIME > $UPDFILE	# save LASTTIME to file
-			[ "$LOCAL_IP" != "$REGISTERED_IP" ] \
-				&& write_log 6 "Update successful - IP '$LOCAL_IP' send" \
-				|| write_log 6 "Forced update successful - IP: '$LOCAL_IP' send"
-		elif [ $ERR_LAST -eq 127 ]; then
-			write_log 3 "No update send to DDNS Provider"
-		else
-			write_log 3 "IP update not accepted by DDNS Provider"
-		fi
-	fi
-
-	# now we wait for check interval before testing if update was recognized
-	# only sleep if VERBOSE <= 2 because otherwise nothing was send
-	[ $VERBOSE -le 2 ] && {
-		write_log 7 "Waiting $CHECK_SECONDS seconds (Check Interval)"
-		sleep $CHECK_SECONDS &
-		PID_SLEEP=$!
-		wait $PID_SLEEP	# enable trap-handler
-		PID_SLEEP=0
-	} || write_log 7 "Verbose Mode: $VERBOSE - NO Check Interval waiting"
-
-	REGISTERED_IP=""		# clear variable
-	get_registered_ip REGISTERED_IP	# get registered/public IP
-	[ $use_ipv6 -eq 1 ] && expand_ipv6 "$REGISTERED_IP" REGISTERED_IP	# on IPv6 we use expanded version
-
-	# IP's are still different
-	if [ "$LOCAL_IP" != "$REGISTERED_IP" ]; then
-		if [ $VERBOSE -le 1 ]; then	# VERBOSE <=1 then retry
-			ERR_UPDATE=$(( $ERR_UPDATE + 1 ))
-			[ $retry_count -gt 0 -a $ERR_UPDATE -gt $retry_count ] && \
-				write_log 14 "Updating IP at DDNS provider failed after $retry_count retries"
-			write_log 4 "Updating IP at DDNS provider failed - starting retry $ERR_UPDATE/$retry_count"
-			continue # loop to beginning
-		else
-			write_log 4 "Updating IP at DDNS provider failed"
-			write_log 7 "Verbose Mode: $VERBOSE - NO retry"; exit 1
-		fi
-	else
-		# we checked successful the last update
-		ERR_UPDATE=0			# reset error counter
-	fi
-
-	# force_update=0 or VERBOSE > 1 - leave here
-	[ $VERBOSE -gt 1 ]  && write_log 7 "Verbose Mode: $VERBOSE - NO reloop"
-	[ $FORCE_SECONDS -eq 0 ] && write_log 6 "Configured to run once"
-	[ $VERBOSE -gt 1 -o $FORCE_SECONDS -eq 0 ] && exit 0
-
-	write_log 6 "Rerun IP check at $(eval $DATE_PROG)"
-done
-# we should never come here there must be a programming error
-write_log 12 "Error in 'dynamic_dns_updater.sh - program coding error"
diff --recursive --unified --new-file --no-dereference orig/files/ddns.config src/files/ddns.config
--- orig/files/ddns.config	1970-01-01 00:00:00.000000000 +0000
+++ src/files/ddns.config	2022-10-07 06:31:35.000000000 +0000
@@ -0,0 +1,20 @@
+#
+# Please read http://wiki.openwrt.org/doc/uci/ddns
+#
+config ddns "global"
+	option ddns_dateformat "%F %R"
+#	option ddns_rundir "/var/run/ddns"
+#	option ddns_logdir "/var/log/ddns"
+	option ddns_loglines "250"
+	option upd_privateip "1"
+	option use_curl "1"
+
+config service "myddns"
+	option service_name	"dyndns.org"
+	option lookup_host	"yourhost.example.com"
+	option domain		"yourhost.example.com"
+	option username		"your_username"
+	option password		"your_password"
+	option interface	"wan"
+	option ip_source	"network"
+	option ip_network	"wan"
diff --recursive --unified --new-file --no-dereference orig/files/ddns.defaults src/files/ddns.defaults
--- orig/files/ddns.defaults	1970-01-01 00:00:00.000000000 +0000
+++ src/files/ddns.defaults	2022-10-07 06:31:35.000000000 +0000
@@ -0,0 +1,201 @@
+#!/bin/sh
+
+. /lib/functions.sh
+
+g_pslfile=/usr/share/public_suffix_list.dat.gz
+[ -f "$g_pslfile" ] || g_pslfile="$(dirname "$0")/public_suffix_list.dat.gz"
+
+g_pslerr="0"
+g_cfgfile="ddns"
+
+# modify timer settings from interval and unit to dhms format
+timer2dhms() {
+# $1	Number and
+# $2	Unit of time interval
+	local t="0"
+	case "$2" in
+		days)		t=$(( $1 * 86400 ));;
+		hours)		t=$(( $1 * 3600 ));;
+		minutes)	t=$(( $1 * 60 ));;
+		*)		t=$1;;
+	esac
+
+	local d=$(( t / 86400 ))
+	local h=$(( t % 86400 / 3600 ))
+	local m=$(( t % 3600 / 60 ))
+	local s=$(( t % 60 ))
+	if [ "$d" -gt 0 ]; then printf "%dd %02dh %02dm %02ds" "$d" "$h" "$m" "$s"
+	elif [ "$h" -gt 0 ]; then printf "%dh %02dm %02ds" "$h" "$m" "$s"
+	elif [ "$m" -gt 0 ]; then printf "%dm %02ds" "$m" "$s"
+	else printf "%ds" "$s"; fi
+
+	unset d h m s t
+	return 0
+}
+
+update_config() {
+	uc_cfg=""
+	uc_name=""
+	uc_var=""
+	uc_val=""
+	package() { return 0; }
+	config () {
+		uc_cfg="$1"
+		uc_name="$2"
+
+		# Type = ddns	Name = global
+		if [ "$uc_cfg" = "$g_cfgfile" ] && [ "$uc_name" = "global" ]; then
+			option() {
+				uc_var="$1"; shift
+				uc_val="$*"
+				case "$uc_var" in
+					allow_local_ip)	uci_rename "$g_cfgfile" "$uc_name" "$uc_var" "upd_privateip";;
+					date_format)	uci_rename "$g_cfgfile" "$uc_name" "$uc_var" "ddns_dateformat";;
+					log_lines)	uci_rename "$g_cfgfile" "$uc_name" "$uc_var" "ddns_loglines";;
+					log_dir)	uci_rename "$g_cfgfile" "$uc_name" "$uc_var" "ddns_logdir";;
+					run_dir)	uci_rename "$g_cfgfile" "$uc_name" "$uc_var" "ddns_rundir";;
+					# leave all other options currently unchanged
+					*)	;;
+				esac
+			}
+
+		# Type = service	Name = ???
+		elif [ "$uc_cfg" = "service" ]; then
+			option() {
+				uc_var="$1"; shift
+				uc_val="$*"
+				case "$uc_var" in
+					# fix some option service_name values
+					# and some settings for specific providers
+					service_name|upd_provider)
+						case "$uc_val" in
+							freedns\.afraid\.org|afraid\.org)
+								uci_set "$g_cfgfile" "$uc_name" "$uc_var" "afraid.org-keyauth";;
+							Bind-nsupdate)
+								uci_set "$g_cfgfile" "$uc_name" "$uc_var" "bind-nsupdate";;
+							dyndns\.org|dyndns\.com)
+								uci_set "$g_cfgfile" "$uc_name" "$uc_var" "dyn.com";;
+							free\.editdns\.net)
+								uci_set "$g_cfgfile" "$uc_name" "$uc_var" "editdns.net";;
+							FreeDNS\.42\.pl)
+								uci_set "$g_cfgfile" "$uc_name" "$uc_var" "freedns.42.pl";;
+							domains\.google\.com)
+								uci_set "$g_cfgfile" "$uc_name" "$uc_var" "google.com";;
+							loopia\.com)
+								uci_set "$g_cfgfile" "$uc_name" "$uc_var" "loopia.se";;
+							NoIP\.com|No-IP\.com)
+								uci_set "$g_cfgfile" "$uc_name" "$uc_var" "no-ip.com";;
+							spdns\.de)
+								uci_set "$g_cfgfile" "$uc_name" "$uc_va" "spdyn.de";;
+							strato\.de)
+								uci_set "$g_cfgfile" "$uc_name" "$uc_var" "strato.com";;
+							*)
+								# all others leave unchanged
+								;;
+						esac
+						# rename option service_name to option upd_provider
+#						$uc_uci rename $g_cfgfile.$uc_name.$uc_var="upd_provider"
+						;;
+					domain|upd_object)
+						# verify if lookup_host is set
+						uci_get "$g_cfgfile" "$uc_name" "lookup_host" >/dev/null 2>&1 || \
+							uci_set "$g_cfgfile" "$uc_name" "lookup_host" "$uc_val"
+						if [ -f "$g_pslfile" ]; then
+							# if service_name/upd_provider cloudflare_v1 then change domain/upd_object to new syntax
+							# there is no sort order inside uci data so we need multiple checks
+							uco_provider=$(uci_get "$g_cfgfile" "$uc_name" "upd_provider" 2>/dev/null) || \
+								uco_provider=$(uci_get "$g_cfgfile" "$uc_name" "service_name" 2>/dev/null)
+							unset uco_provider
+						fi
+						# rename option domain to option upd_object
+#						$uc_uci rename $g_cfgfile.$uc_name.$uc_var="upd_object"
+						;;
+#					dns_server)
+#						# if bind-nsupdate takeover old "dns_server" value as new "upd_nsupd_server" value
+#						uco_provider=$($uc_uci get $g_cfgfile.$uc_name.upd_provider 2>/dev/null) || \
+#							uco_provider=$($uc_uci get $g_cfgfile.$uc_name.service_name 2>/dev/null)
+#						[ "$uco_provider" = "Bind-nsupdate" -o \
+#						  "$uco_provider" = "bind-nsupdate" ] && \
+#							$uc_uci set $g_cfgfile.$uc_name.upd_nsupd_server="$uc_val"
+#						# rename option dns_server to new option global_dnssvr
+#						$udc_uci rename $g_cfgfile.$uc_name.$uc_var="global_dnssvr"
+#						;;
+#					bind_network)
+#						$udc_uci set $g_cfgfile.$uc_name.upd_url_bindnet="$uc_val"
+#						$udc_uci rename $g_cfgfile.$uc_name.$uc_var="lip_url_bindnet"
+#						;;
+#					proxy)
+#						# proxy value must include protocoll
+#						$udc_uci set $g_cfgfile.$uc_name.$uc_var="http://$uc_val"
+#						$udc_uci rename $g_cfgfile.$uc_name.$uc_var="upd_url_proxy"
+#						;;
+#					use_ipv6)
+#						$udc_uci set $g_cfgfile.$uc_name.$uc_var="$(( 4 + ( 2 * $uc_val ) ))"
+#						$udc_uci rename $g_cfgfile.$uc_name.$uc_var="upd_ipversion"
+#				TODO	update_url)
+#				TODO	update_script)
+					# other renames
+#				TODO	lookup_host)	-> rip_host
+#					enabled)	$udc_uci rename $g_cfgfile.$uc_name.$uc_var="upd_enabled";;
+#					force_dnstcp)	$udc_uci rename $g_cfgfile.$uc_name.$uc_var="rip_host_dnstcp";;
+#					is_glue)	$udc_uci rename $g_cfgfile.$uc_name.$uc_var="rip_host_isglue";;
+#					ip_interface)	$udc_uci rename $g_cfgfile.$uc_name.$uc_var="lip_iface";;
+#					ip_network)	$udc_uci rename $g_cfgfile.$uc_name.$uc_var="lip_net";;
+#					use_https)	$udc_uci rename $g_cfgfile.$uc_name.$uc_var="upd_url_secure";;
+#					cacert)		$udc_uci rename $g_cfgfile.$uc_name.$uc_var="upd_url_cacert";;
+#					username)	$udc_uci rename $g_cfgfile.$uc_name.$uc_var="upd_username";;
+#					password)	$udc_uci rename $g_cfgfile.$uc_name.$uc_var="upd_password";;
+#					param_opt)	$udc_uci rename $g_cfgfile.$uc_name.$uc_var="upd_paramopt";;
+#					param_enc)	$udc_uci rename $g_cfgfile.$uc_name.$uc_var="upd_paramenc";;
+
+					# leave all other options currently unchanged
+					*)	;;
+				esac
+				return 0
+			}
+			return 0
+
+		# ignore unknown
+		else
+			return 0
+		fi
+	}
+
+	# read config file
+	uc_data=$(uci -q -S -n export "$g_cfgfile")
+	uc_ret="$?"
+	# Error then create config file
+	[ "$uc_ret" -ne 0 ] && {
+		touch "/etc/config/${uc_cfgfile}"
+		chmod 644 "/etc/config/${uc_cfgfile}"
+	}
+	# No error and uc_data then execute (eval)
+	# this will call functions defined above
+	[ "$uc_ret" -eq 0 ] && [ -n "$uc_data" ] && eval "$uc_data"
+
+	# add config ddns "global" (ignore error if exists)
+	uci -q set "ddns.global=${g_cfgfile}"
+
+	# write changes to config file
+	uci_commit "$g_cfgfile"
+
+	unset uc_uci uc_cfg uc_name uc_var uc_val uc_ret uc_data
+	return 0
+}
+
+# clear LuCI indexcache
+rm -fr /tmp/luci-indexcache/
+
+# do config update
+update_config
+
+#cleanup
+[ "$g_pslerr" -ne 0 ] && {
+	unset g_pslfile g_pslerr g_cfgfile
+	return 1
+}
+
+[ -f "$g_pslfile" ] && rm -f "$g_pslfile"
+unset g_pslfile g_pslerr g_cfgfile
+return 0
+
diff --recursive --unified --new-file --no-dereference orig/files/ddns.hotplug src/files/ddns.hotplug
--- orig/files/ddns.hotplug	1970-01-01 00:00:00.000000000 +0000
+++ src/files/ddns.hotplug	2022-10-07 06:31:35.000000000 +0000
@@ -0,0 +1,16 @@
+#!/bin/sh /etc/rc.common
+
+enabled="0"
+
+check_enabled() {
+	local service="$1"
+	config_get enabled "$service" enabled "0"
+}
+
+config_load ddns
+config_foreach check_enabled service
+
+if [ "$enabled" = "1" ]; then
+    /usr/lib/ddns/dynamic_dns_updater.sh -- stop
+    /usr/lib/ddns/dynamic_dns_updater.sh -- start
+fi
\ No newline at end of file
diff --recursive --unified --new-file --no-dereference orig/files/ddns.init src/files/ddns.init
--- orig/files/ddns.init	1970-01-01 00:00:00.000000000 +0000
+++ src/files/ddns.init	2022-10-07 06:31:35.000000000 +0000
@@ -0,0 +1,36 @@
+#!/bin/sh /etc/rc.common
+
+START=95
+STOP=10
+
+USE_PROCD=1
+STATUS=""
+
+check_enabled() {
+        [ "$STATUS" = "1" ] && return
+        config_get STATUS "$1" "enabled"
+}
+
+start_service() {
+        config_load "ddns"
+        config_foreach check_enabled service
+        [ "$STATUS" != "1" ] && return
+
+        procd_open_instance
+        procd_set_param command /usr/lib/ddns/dynamic_dns_updater.sh -- start
+        procd_close_instance
+}
+
+stop_service() {
+        /usr/lib/ddns/dynamic_dns_updater.sh -- stop
+        sleep 1
+}
+
+reload_service() {
+        pgrep -f /usr/lib/ddns/dynamic_dns_updater.sh | xargs kill
+        start
+}
+
+service_triggers() {
+        procd_add_reload_trigger "ddns"
+}
diff --recursive --unified --new-file --no-dereference orig/files/dynamic_dns_functions.sh src/files/dynamic_dns_functions.sh
--- orig/files/dynamic_dns_functions.sh	1970-01-01 00:00:00.000000000 +0000
+++ src/files/dynamic_dns_functions.sh	2022-10-07 06:31:35.000000000 +0000
@@ -0,0 +1,1391 @@
+#!/bin/sh
+# /usr/lib/ddns/dynamic_dns_functions.sh
+#
+#.Distributed under the terms of the GNU General Public License (GPL) version 2.0
+# Original written by Eric Paul Bishop, January 2008
+# (Loosely) based on the script on the one posted by exobyte in the forums here:
+# http://forum.openwrt.org/viewtopic.php?id=14040
+# extended and partial rewritten
+#.2014-2018 Christian Schoenebeck <christian dot schoenebeck at gmail dot com>
+#
+# function timeout
+# copied from http://www.ict.griffith.edu.au/anthony/software/timeout.sh
+# @author Anthony Thyssen  6 April 2011
+#
+# variables in small chars are read from /etc/config/ddns
+# variables in big chars are defined inside these scripts as global vars
+# variables in big chars beginning with "__" are local defined inside functions only
+# set -vx  	#script debugger
+
+. /lib/functions.sh
+. /lib/functions/network.sh
+
+# GLOBAL VARIABLES #
+VERSION="2.7.8-5"
+SECTION_ID=""		# hold config's section name
+VERBOSE=0		# default mode is log to console, but easily changed with parameter
+MYPROG=$(basename $0)	# my program call name
+
+LOGFILE=""		# logfile - all files are set in dynamic_dns_updater.sh
+PIDFILE=""		# pid file
+UPDFILE=""		# store UPTIME of last update
+DATFILE=""		# save stdout data of WGet and other external programs called
+ERRFILE=""		# save stderr output of WGet and other external programs called
+IPFILE=""		# store registered IP for read by LuCI status
+TLDFILE=/usr/share/public_suffix_list.dat.gz	# TLD file used by split_FQDN
+
+CHECK_SECONDS=0		# calculated seconds out of given
+FORCE_SECONDS=0		# interval and unit
+RETRY_SECONDS=0		# in configuration
+
+LAST_TIME=0		# holds the uptime of last successful update
+CURR_TIME=0		# holds the current uptime
+NEXT_TIME=0		# calculated time for next FORCED update
+EPOCH_TIME=0		# seconds since 1.1.1970 00:00:00
+
+REGISTERED_IP=""	# holds the IP read from DNS
+LOCAL_IP=""		# holds the local IP read from the box
+
+URL_USER=""		# url encoded $username from config file
+URL_PASS=""		# url encoded $password from config file
+URL_PENC=""		# url encoded $param_enc from config file
+
+UPD_ANSWER=""		# Answer given by service on success
+
+ERR_LAST=0		# used to save $? return code of program and function calls
+ERR_UPDATE=0		# error counter on different local and registered ip
+
+PID_SLEEP=0		# ProcessID of current background "sleep"
+
+# regular expression to detect IPv4 / IPv6
+# IPv4       0-9   1-3x "." 0-9  1-3x "." 0-9  1-3x "." 0-9  1-3x
+IPV4_REGEX="[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}"
+# IPv6       ( ( 0-9a-f  1-4char ":") min 1x) ( ( 0-9a-f  1-4char   )optional) ( (":" 0-9a-f 1-4char  ) min 1x)
+IPV6_REGEX="\(\([0-9A-Fa-f]\{1,4\}:\)\{1,\}\)\(\([0-9A-Fa-f]\{1,4\}\)\{0,1\}\)\(\(:[0-9A-Fa-f]\{1,4\}\)\{1,\}\)"
+
+# characters that are dangerous to pass to a shell command line
+SHELL_ESCAPE="[\"\'\`\$\!();><{}?|\[\]\*\\\\]"
+
+# dns character set
+DNS_CHARSET="[@a-zA-Z0-9._-]"
+
+# detect if called by ddns-lucihelper.sh script, disable retrys (empty variable == false)
+LUCI_HELPER=$(printf %s "$MYPROG" | grep -i "luci")
+
+# Name Server Lookup Programs
+BIND_HOST=$(which host)
+KNOT_HOST=$(which khost)
+DRILL=$(which drill)
+HOSTIP=$(which hostip)
+NSLOOKUP=$(which nslookup)
+
+# Transfer Programs
+WGET=$(which wget)
+WGET_SSL=$(which wget-ssl)
+
+CURL=$(which curl)
+# CURL_SSL not empty then SSL support available
+CURL_SSL=$($CURL -V 2>/dev/null | grep -F "https")
+# CURL_PROXY not empty then Proxy support available
+CURL_PROXY=$(find /lib /usr/lib -name libcurl.so* -exec strings {} 2>/dev/null \; | grep -im1 "all_proxy")
+
+UCLIENT_FETCH=$(which uclient-fetch)
+
+# Global configuration settings
+# allow NON-public IP's
+upd_privateip=$(uci -q get ddns.global.upd_privateip) || upd_privateip=1
+
+# directory to store run information to.
+ddns_rundir=$(uci -q get ddns.global.ddns_rundir) || ddns_rundir="/var/run/ddns"
+[ -d $ddns_rundir ] || mkdir -p -m755 $ddns_rundir
+
+# directory to store log files
+ddns_logdir=$(uci -q get ddns.global.ddns_logdir) || ddns_logdir="/var/log/ddns"
+[ -d $ddns_logdir ] || mkdir -p -m755 $ddns_logdir
+
+# number of lines to before rotate logfile
+ddns_loglines=$(uci -q get ddns.global.ddns_loglines) || ddns_loglines=250
+ddns_loglines=$((ddns_loglines + 1))	# correct sed handling
+
+# format to show date information in log and luci-app-ddns default ISO 8601 format
+ddns_dateformat=$(uci -q get ddns.global.ddns_dateformat) || ddns_dateformat="%F %R"
+DATE_PROG="date +'$ddns_dateformat'"
+
+# USE_CURL if GNU Wget and cURL installed normally Wget is used by do_transfer()
+# to change this use global option use_curl '1'
+USE_CURL=$(uci -q get ddns.global.use_curl) || USE_CURL=0	# read config
+[ -n "$CURL" ] || USE_CURL=0					# check for cURL
+
+# loads all options for a given package and section
+# also, sets all_option_variables to a list of the variable names
+# $1 = ddns, $2 = SECTION_ID
+load_all_config_options()
+{
+	local __PKGNAME="$1"
+	local __SECTIONID="$2"
+	local __VAR
+	local __ALL_OPTION_VARIABLES=""
+
+	# this callback loads all the variables in the __SECTIONID section when we do
+	# config_load. We need to redefine the option_cb for different sections
+	# so that the active one isn't still active after we're done with it.  For reference
+	# the $1 variable is the name of the option and $2 is the name of the section
+	config_cb()
+	{
+		if [ ."$2" = ."$__SECTIONID" ]; then
+			option_cb()
+			{
+				__ALL_OPTION_VARIABLES="$__ALL_OPTION_VARIABLES $1"
+			}
+		else
+			option_cb() { return 0; }
+		fi
+	}
+
+	config_load "$__PKGNAME"
+
+	# Given SECTION_ID not found so no data, so return 1
+	[ -z "$__ALL_OPTION_VARIABLES" ] && return 1
+
+	for __VAR in $__ALL_OPTION_VARIABLES
+	do
+		config_get "$__VAR" "$__SECTIONID" "$__VAR"
+	done
+	return 0
+}
+
+# read's all service sections from ddns config
+# $1 = Name of variable to store
+load_all_service_sections() {
+	local __DATA=""
+	config_cb()
+	{
+		# only look for section type "service", ignore everything else
+		[ "$1" = "service" ] && __DATA="$__DATA $2"
+	}
+	config_load "ddns"
+
+	eval "$1=\"$__DATA\""
+	return
+}
+
+# starts updater script for all given sections or only for the one given
+# $1 = interface (Optional: when given only scripts are started
+# configured for that interface)
+# used by /etc/hotplug.d/iface/95-ddns on IFUP
+# and by /etc/init.d/ddns start
+start_daemon_for_all_ddns_sections()
+{
+	local __EVENTIF="$1"
+	local __SECTIONS=""
+	local __SECTIONID=""
+	local __IFACE=""
+
+	load_all_service_sections __SECTIONS
+	for __SECTIONID in $__SECTIONS; do
+		config_get __IFACE "$__SECTIONID" interface "wan"
+		[ -z "$__EVENTIF" -o "$__IFACE" = "$__EVENTIF" ] || continue
+		if [ $VERBOSE -eq 0 ]; then	# start in background
+			/usr/lib/ddns/dynamic_dns_updater.sh -v 0 -S "$__SECTIONID" -- start &
+		else
+			/usr/lib/ddns/dynamic_dns_updater.sh -v "$VERBOSE" -S "$__SECTIONID" -- start
+		fi
+	done
+}
+
+# stop sections process incl. childs (sleeps)
+# $1 = section
+stop_section_processes() {
+	local __PID=0
+	local __PIDFILE="$ddns_rundir/$1.pid"
+	[ $# -ne 1 ] && write_log 12 "Error calling 'stop_section_processes()' - wrong number of parameters"
+
+	[ -e "$__PIDFILE" ] && {
+		__PID=$(cat $__PIDFILE)
+		ps | grep "^[\t ]*$__PID" >/dev/null 2>&1 && kill $__PID || __PID=0	# terminate it
+	}
+	[ $__PID -eq 0 ] # report if process was running
+}
+
+# stop updater script for all defines sections or only for one given
+# $1 = interface (optional)
+# used by /etc/hotplug.d/iface/95-ddns on 'ifdown'
+# and by /etc/init.d/ddns stop
+# needed because we also need to kill "sleep" child processes
+stop_daemon_for_all_ddns_sections() {
+	local __EVENTIF="$1"
+	local __SECTIONS=""
+	local __SECTIONID=""
+	local __IFACE=""
+
+	load_all_service_sections __SECTIONS
+	for __SECTIONID in $__SECTIONS;	do
+		config_get __IFACE "$__SECTIONID" interface "wan"
+		[ -z "$__EVENTIF" -o "$__IFACE" = "$__EVENTIF" ] || continue
+		stop_section_processes "$__SECTIONID"
+	done
+}
+
+# reports to console, logfile, syslog
+# $1	loglevel 7 == Debug to 0 == EMERG
+#	value +10 will exit the scripts
+# $2..n	text to report
+write_log() {
+	local __LEVEL __EXIT __CMD __MSG __MSE
+	local __TIME=$(date +%H%M%S)
+	[ $1 -ge 10 ] && {
+		__LEVEL=$(($1-10))
+		__EXIT=1
+	} || {
+		__LEVEL=$1
+		__EXIT=0
+	}
+	shift	# remove loglevel
+	[ $__EXIT -eq 0 ] && __MSG="$*" || __MSG="$* - terminate"
+	case $__LEVEL in		# create log message and command depending on loglevel
+		0)	__CMD="logger -p user.emerg -t ddns-scripts[$$] $SECTION_ID: $__MSG"
+			__MSG=" $__TIME emerg : $__MSG" ;;
+		1)	__CMD="logger -p user.alert -t ddns-scripts[$$] $SECTION_ID: $__MSG"
+			__MSG=" $__TIME alert : $__MSG" ;;
+		2)	__CMD="logger -p user.crit -t ddns-scripts[$$] $SECTION_ID: $__MSG"
+			__MSG=" $__TIME  crit : $__MSG" ;;
+		3)	__CMD="logger -p user.err -t ddns-scripts[$$] $SECTION_ID: $__MSG"
+			__MSG=" $__TIME error : $__MSG" ;;
+		4)	__CMD="logger -p user.warn -t ddns-scripts[$$] $SECTION_ID: $__MSG"
+			__MSG=" $__TIME  warn : $__MSG" ;;
+		5)	__CMD="logger -p user.notice -t ddns-scripts[$$] $SECTION_ID: $__MSG"
+			__MSG=" $__TIME  note : $__MSG" ;;
+		6)	__CMD="logger -p user.info -t ddns-scripts[$$] $SECTION_ID: $__MSG"
+			__MSG=" $__TIME  info : $__MSG" ;;
+		7)	__MSG=" $__TIME       : $__MSG";;
+		*) 	return;;
+	esac
+
+	# verbose echo
+	[ $VERBOSE -gt 0 -o $__EXIT -gt 0 ] && echo -e "$__MSG"
+	# write to logfile
+	if [ ${use_logfile:-1} -eq 1 -o $VERBOSE -gt 1 ]; then
+		if [ -n "$password" ]; then
+			# url encode __MSG, password already done
+			urlencode __MSE "$__MSG"
+			# replace encoded password inside encoded message
+			# and url decode (newline was encoded as %00)
+			__MSG=$( echo -e "$__MSE" \
+				| sed -e "s/$URL_PASS/***PW***/g" \
+				| sed -e "s/+/ /g; s/%00/\n/g; s/%/\\\\x/g" | xargs -0 printf "%b" )
+		fi
+		printf "%s\n" "$__MSG" >> $LOGFILE
+		# VERBOSE > 1 then NO loop so NO truncate log to $ddns_loglines lines
+		[ $VERBOSE -gt 1 ] || sed -i -e :a -e '$q;N;'$ddns_loglines',$D;ba' $LOGFILE
+	fi
+	[ -n "$LUCI_HELPER" ] && return	# nothing else todo when running LuCI helper script
+	[ $__LEVEL -eq 7 ] && return	# no syslog for debug messages
+	__CMD=$(echo -e "$__CMD" | tr -d '\n' | tr '\t' '     ')        # remove \n \t chars
+	[ $__EXIT  -eq 1 ] && {
+		eval "$__CMD"	# force syslog before exit
+		exit 1
+	}
+	[ $use_syslog -eq 0 ] && return
+	[ $((use_syslog + __LEVEL)) -le 7 ] && eval "$__CMD"
+
+	return
+}
+
+# replace all special chars to their %hex value
+# used for USERNAME and PASSWORD in update_url
+# unchanged: "-"(minus) "_"(underscore) "."(dot) "~"(tilde)
+# to verify: "'"(single quote) '"'(double quote)	# because shell delimiter
+#            "$"(Dollar)				# because used as variable output
+# tested with the following string stored via Luci Application as password / username
+# A B!"#AA$1BB%&'()*+,-./:;<=>?@[\]^_`{|}~	without problems at Dollar or quotes
+urlencode() {
+	# $1	Name of Variable to store encoded string to
+	# $2	string to encode
+	local __ENC
+
+	[ $# -ne 2 ] && write_log 12 "Error calling 'urlencode()' - wrong number of parameters"
+
+	__ENC="$(awk -v str="$2" 'BEGIN{ORS="";for(i=32;i<=127;i++)lookup[sprintf("%c",i)]=i
+		for(k=1;k<=length(str);++k){enc=substr(str,k,1);if(enc!~"[-_.~a-zA-Z0-9]")enc=sprintf("%%%02x", lookup[enc]);print enc}}')"
+
+	eval "$1=\"$__ENC\""	# transfer back to variable
+	return 0
+}
+
+# extract url or script for given DDNS Provider from
+# file /etc/ddns/services for IPv4 or from
+# file /etc/ddns/services_ipv6 for IPv6
+# $1	Name of Variable to store url to
+# $2	Name of Variable to store script to
+# $3	Name of Variable to store service answer to
+get_service_data() {
+	[ $# -ne 3 ] && write_log 12 "Error calling 'get_service_data()' - wrong number of parameters"
+
+	__FILE="/etc/ddns/services"				# IPv4
+	[ $use_ipv6 -ne 0 ] && __FILE="/etc/ddns/services_ipv6"	# IPv6
+
+	# workaround with variables; pipe create subshell with no give back of variable content
+	mkfifo pipe_$$
+	# only grep without # or whitespace at linestart | remove "
+#	grep -v -E "(^#|^[[:space:]]*$)" $__FILE | sed -e s/\"//g > pipe_$$ &
+	sed '/^#/d; /^[ \t]*$/d; s/\"//g' $__FILE  > pipe_$$ &
+
+	while read __SERVICE __DATA __ANSWER; do
+		if [ "$__SERVICE" = "$service_name" ]; then
+			# check if URL or SCRIPT is given
+			__URL=$(echo "$__DATA" | grep "^http")
+			[ -z "$__URL" ] && __SCRIPT="/usr/lib/ddns/$__DATA"
+
+			eval "$1=\"$__URL\""
+			eval "$2=\"$__SCRIPT\""
+			eval "$3=\"$__ANSWER\""
+			rm pipe_$$
+			return 0
+		fi
+	done < pipe_$$
+	rm pipe_$$
+
+	eval "$1=\"\""	# no service match clear variables
+	eval "$2=\"\""
+	eval "$3=\"\""
+	return 1
+}
+
+# Calculate seconds from interval and unit
+# $1	Name of Variable to store result in
+# $2	Number and
+# $3	Unit of time interval
+get_seconds() {
+	[ $# -ne 3 ] && write_log 12 "Error calling 'get_seconds()' - wrong number of parameters"
+	case "$3" in
+		"days" )	eval "$1=$(( $2 * 86400 ))";;
+		"hours" )	eval "$1=$(( $2 * 3600 ))";;
+		"minutes" )	eval "$1=$(( $2 * 60 ))";;
+		* )		eval "$1=$2";;
+	esac
+	return 0
+}
+
+timeout() {
+	#.copied from http://www.ict.griffith.edu.au/anthony/software/timeout.sh
+	# only did the following changes
+	#	- commented out "#!/bin/bash" and usage section
+	#	- replace exit by return for usage as function
+	#	- some reformatting
+	#
+	# timeout [-SIG] time [--] command args...
+	#
+	# Run the given command until completion, but kill it if it runs too long.
+	# Specifically designed to exit immediately (no sleep interval) and clean up
+	# nicely without messages or leaving any extra processes when finished.
+	#
+	# Example use
+	#    timeout 5 countdown
+	#
+	# Based on notes in my "Shell Script Hints", section "Command Timeout"
+	#   http://www.ict.griffith.edu.au/~anthony/info/shell/script.hints
+	#
+	# This script uses a lot of tricks to terminate both the background command,
+	# the timeout script, and even the sleep process.  It also includes trap
+	# commands to prevent sub-shells reporting expected "Termination Errors".
+	#
+	# It took years of occasional trials, errors and testing to get a pure bash
+	# timeout command working as well as this does.
+	#
+	#.Anthony Thyssen     6 April 2011
+	#
+#	PROGNAME=$(type $0 | awk '{print $3}')	# search for executable on path
+#	PROGDIR=$(dirname $PROGNAME)		# extract directory of program
+#	PROGNAME=$(basename $PROGNAME)		# base name of program
+
+	# output the script comments as docs
+#	Usage() {
+#		echo >&2 "$PROGNAME:" "$@"
+#		sed >&2 -n '/^###/q; /^#/!q; s/^#//; s/^ //; 3s/^/Usage: /; 2,$ p' "$PROGDIR/$PROGNAME"
+#		exit 10;
+#	}
+
+	SIG=-TERM
+
+	while [ $# -gt 0 ]; do
+		case "$1" in
+			--)
+				# forced end of user options
+				shift;
+				break ;;
+#			-\?|--help|--doc*)
+#				Usage ;;
+			[0-9]*)
+				TIMEOUT="$1" ;;
+			-*)
+				SIG="$1" ;;
+			*)
+				# unforced  end of user options
+				break ;;
+		esac
+		shift	# next option
+	done
+
+	# run main command in backgrounds and get its pid
+	"$@" &
+	command_pid=$!
+
+	# timeout sub-process abort countdown after ABORT seconds! also backgrounded
+	sleep_pid=0
+	(
+		# cleanup sleep process
+		trap 'kill -TERM $sleep_pid; return 1' 1 2 3 15
+		# sleep timeout period in background
+		sleep $TIMEOUT &
+		sleep_pid=$!
+		wait $sleep_pid
+		# Abort the command
+		kill $SIG $command_pid >/dev/null 2>&1
+		return 1
+	) &
+	timeout_pid=$!
+
+	# Wait for main command to finished or be timed out
+	wait $command_pid
+	status=$?
+
+	# Clean up timeout sub-shell - if it is still running!
+	kill $timeout_pid 2>/dev/null
+	wait $timeout_pid 2>/dev/null
+
+	# Uncomment to check if a LONG sleep still running (no sleep should be)
+	# sleep 1
+	# echo "-----------"
+	# /bin/ps j  # uncomment to show if abort "sleep" is still sleeping
+
+	return $status
+}
+
+# sanitize a variable
+# $1	variable name
+# $2	allowed shell pattern
+# $3	disallowed shell pattern
+sanitize_variable() {
+	local __VAR=$1
+	eval __VALUE=\$$__VAR
+	local __ALLOWED=$2
+	local __REJECT=$3
+
+	# removing all allowed should give empty string
+	if [ -n "$__ALLOWED" ]; then
+		[ -z "${__VALUE//$__ALLOWED}" ] || write_log 12 "sanitize on $__VAR found characters outside allowed subset"
+	fi
+
+	# removing rejected pattern should give the same string as the input
+	if [ -n "$__REJECT" ]; then
+		[ "$__VALUE" = "${__VALUE//$__REJECT}" ] || write_log 12 "sanitize on $__VAR found rejected characters"
+	fi
+}
+
+# verify given host and port is connectable
+# $1	Host/IP to verify
+# $2	Port to verify
+verify_host_port() {
+	local __HOST=$1
+	local __PORT=$2
+	local __NC=$(which nc)
+	local __NCEXT=$($(which nc) --help 2>&1 | grep "\-w" 2>/dev/null)	# busybox nc compiled with extensions
+	local __IP __IPV4 __IPV6 __RUNPROG __PROG __ERR
+	# return codes
+	# 1	system specific error
+	# 2	nslookup/host error
+	# 3	nc (netcat) error
+	# 4	unmatched IP version
+
+	[ $# -ne 2 ] && write_log 12 "Error calling 'verify_host_port()' - wrong number of parameters"
+
+	# check if ip or FQDN was given
+	__IPV4=$(echo $__HOST | grep -m 1 -o "$IPV4_REGEX$")	# do not detect ip in 0.0.0.0.example.com
+	__IPV6=$(echo $__HOST | grep -m 1 -o "$IPV6_REGEX")
+	# if FQDN given get IP address
+	[ -z "$__IPV4" -a -z "$__IPV6" ] && {
+		if [ -n "$BIND_HOST" ]; then	# use BIND host if installed
+			__PROG="BIND host"
+			__RUNPROG="$BIND_HOST $__HOST >$DATFILE 2>$ERRFILE"
+		elif [ -n "$KNOT_HOST" ]; then	# use Knot host if installed
+			__PROG="Knot host"
+			__RUNPROG="$KNOT_HOST $__HOST >$DATFILE 2>$ERRFILE"
+		elif [ -n "$DRILL" ]; then	# use drill if installed
+			__PROG="drill"
+			__RUNPROG="$DRILL -V0 $__HOST A >$DATFILE 2>$ERRFILE"			# IPv4
+			__RUNPROG="$__RUNPROG; $DRILL -V0 $__HOST AAAA >>$DATFILE 2>>$ERRFILE"	# IPv6
+		elif [ -n "$HOSTIP" ]; then	# use hostip if installed
+			__PROG="hostip"
+			__RUNPROG="$HOSTIP $__HOST >$DATFILE 2>$ERRFILE"			# IPv4
+			__RUNPROG="$__RUNPROG; $HOSTIP -6 $__HOST >>$DATFILE 2>>$ERRFILE"	# IPv6
+		else	# use BusyBox nslookup
+			__PROG="BusyBox nslookup"
+			__RUNPROG="$NSLOOKUP $__HOST >$DATFILE 2>$ERRFILE"
+		fi
+		write_log 7 "#> $__RUNPROG"
+		eval $__RUNPROG
+		__ERR=$?
+		# command error
+		[ $__ERR -gt 0 ] && {
+			write_log 3 "DNS Resolver Error - $__PROG Error '$__ERR'"
+			write_log 7 "$(cat $ERRFILE)"
+			return 2
+		}
+		# extract IP address
+		if [ -n "$BIND_HOST" -o -n "$KNOT_HOST" ]; then	# use BIND host or Knot host if installed
+			__IPV4=$(cat $DATFILE | awk -F "address " '/has address/ {print $2; exit}' )
+			__IPV6=$(cat $DATFILE | awk -F "address " '/has IPv6/ {print $2; exit}' )
+		elif [ -n "$DRILL" ]; then	# use drill if installed
+			__IPV4=$(cat $DATFILE | awk '/^'"$lookup_host"'/ {print $5}' | grep -m 1 -o "$IPV4_REGEX")
+			__IPV6=$(cat $DATFILE | awk '/^'"$lookup_host"'/ {print $5}' | grep -m 1 -o "$IPV6_REGEX")
+		elif [ -n "$HOSTIP" ]; then	# use hostip if installed
+			__IPV4=$(cat $DATFILE | grep -m 1 -o "$IPV4_REGEX")
+			__IPV6=$(cat $DATFILE | grep -m 1 -o "$IPV6_REGEX")
+		else	# use BusyBox nslookup
+			__IPV4=$(cat $DATFILE | sed -ne "/^Name:/,\$ { s/^Address[0-9 ]\{0,\}: \($IPV4_REGEX\).*$/\\1/p }")
+			__IPV6=$(cat $DATFILE | sed -ne "/^Name:/,\$ { s/^Address[0-9 ]\{0,\}: \($IPV6_REGEX\).*$/\\1/p }")
+		fi
+	}
+
+	# check IP version if forced
+	if [ $force_ipversion -ne 0 ]; then
+		__ERR=0
+		[ $use_ipv6 -eq 0 -a -z "$__IPV4" ] && __ERR=4
+		[ $use_ipv6 -eq 1 -a -z "$__IPV6" ] && __ERR=6
+		[ $__ERR -gt 0 ] && {
+			[ -n "$LUCI_HELPER" ] && return 4
+			write_log 14 "Verify host Error '4' - Forced IP Version IPv$__ERR don't match"
+		}
+	fi
+
+	# verify nc command
+	# busybox nc compiled without -l option "NO OPT l!" -> critical error
+	$__NC --help 2>&1 | grep -i "NO OPT l!" >/dev/null 2>&1 && \
+		write_log 12 "Busybox nc (netcat) compiled without '-l' option, error 'NO OPT l!'"
+	# busybox nc compiled with extensions
+	$__NC --help 2>&1 | grep "\-w" >/dev/null 2>&1 && __NCEXT="TRUE"
+
+	# connectivity test
+	# run busybox nc to HOST PORT
+	# busybox might be compiled with "FEATURE_PREFER_IPV4_ADDRESS=n"
+	# then nc will try to connect via IPv6 if there is any IPv6 available on any host interface
+	# not worrying, if there is an IPv6 wan address
+	# so if not "force_ipversion" to use_ipv6 then connect test via ipv4, if available
+	[ $force_ipversion -ne 0 -a $use_ipv6 -ne 0 -o -z "$__IPV4" ] && __IP=$__IPV6 || __IP=$__IPV4
+
+	if [ -n "$__NCEXT" ]; then	# BusyBox nc compiled with extensions (timeout support)
+		__RUNPROG="$__NC -w 1 $__IP $__PORT </dev/null >$DATFILE 2>$ERRFILE"
+		write_log 7 "#> $__RUNPROG"
+		eval $__RUNPROG
+		__ERR=$?
+		[ $__ERR -eq 0 ] && return 0
+		write_log 3 "Connect error - BusyBox nc (netcat) Error '$__ERR'"
+		write_log 7 "$(cat $ERRFILE)"
+		return 3
+	else		# nc compiled without extensions (no timeout support)
+		__RUNPROG="timeout 2 -- $__NC $__IP $__PORT </dev/null >$DATFILE 2>$ERRFILE"
+		write_log 7 "#> $__RUNPROG"
+		eval $__RUNPROG
+		__ERR=$?
+		[ $__ERR -eq 0 ] && return 0
+		write_log 3 "Connect error - BusyBox nc (netcat) timeout Error '$__ERR'"
+		return 3
+	fi
+}
+
+# verify given DNS server if connectable
+# $1	DNS server to verify
+verify_dns() {
+	local __ERR=255	# last error buffer
+	local __CNT=0	# error counter
+
+	[ $# -ne 1 ] && write_log 12 "Error calling 'verify_dns()' - wrong number of parameters"
+	write_log 7 "Verify DNS server '$1'"
+
+	while [ $__ERR -ne 0 ]; do
+		# DNS uses port 53
+		verify_host_port "$1" "53"
+		__ERR=$?
+		if [ -n "$LUCI_HELPER" ]; then	# no retry if called by LuCI helper script
+			return $__ERR
+		elif [ $__ERR -ne 0 -a $VERBOSE -gt 1 ]; then	# VERBOSE > 1 then NO retry
+			write_log 4 "Verify DNS server '$1' failed - Verbose Mode: $VERBOSE - NO retry on error"
+			return $__ERR
+		elif [ $__ERR -ne 0 ]; then
+			__CNT=$(( $__CNT + 1 ))	# increment error counter
+			# if error count > retry_count leave here
+			[ $retry_count -gt 0 -a $__CNT -gt $retry_count ] && \
+				write_log 14 "Verify DNS server '$1' failed after $retry_count retries"
+
+			write_log 4 "Verify DNS server '$1' failed - retry $__CNT/$retry_count in $RETRY_SECONDS seconds"
+			sleep $RETRY_SECONDS &
+			PID_SLEEP=$!
+			wait $PID_SLEEP	# enable trap-handler
+			PID_SLEEP=0
+		fi
+	done
+	return 0
+}
+
+# analyze and verify given proxy string
+# $1	Proxy-String to verify
+verify_proxy() {
+	#	complete entry		user:password@host:port
+	# 				inside user and password NO '@' of ":" allowed
+	#	host and port only	host:port
+	#	host only		host		ERROR unsupported
+	#	IPv4 address instead of host	123.234.234.123
+	#	IPv6 address instead of host	[xxxx:....:xxxx]	in square bracket
+	local __TMP __HOST __PORT
+	local __ERR=255	# last error buffer
+	local __CNT=0	# error counter
+
+	[ $# -ne 1 ] && write_log 12 "Error calling 'verify_proxy()' - wrong number of parameters"
+	write_log 7 "Verify Proxy server 'http://$1'"
+
+	# try to split user:password "@" host:port
+	__TMP=$(echo $1 | awk -F "@" '{print $2}')
+	# no "@" found - only host:port is given
+	[ -z "$__TMP" ] && __TMP="$1"
+	# now lets check for IPv6 address
+	__HOST=$(echo $__TMP | grep -m 1 -o "$IPV6_REGEX")
+	# IPv6 host address found read port
+	if [ -n "$__HOST" ]; then
+		# IPv6 split at "]:"
+		__PORT=$(echo $__TMP | awk -F "]:" '{print $2}')
+	else
+		__HOST=$(echo $__TMP | awk -F ":" '{print $1}')
+		__PORT=$(echo $__TMP | awk -F ":" '{print $2}')
+	fi
+	# No Port detected - EXITING
+	[ -z "$__PORT" ] && {
+		[ -n "$LUCI_HELPER" ] && return 5
+		write_log 14 "Invalid Proxy server Error '5' - proxy port missing"
+	}
+
+	while [ $__ERR -gt 0 ]; do
+		verify_host_port "$__HOST" "$__PORT"
+		__ERR=$?
+		if [ -n "$LUCI_HELPER" ]; then	# no retry if called by LuCI helper script
+			return $__ERR
+		elif [ $__ERR -gt 0 -a $VERBOSE -gt 1 ]; then	# VERBOSE > 1 then NO retry
+			write_log 4 "Verify Proxy server '$1' failed - Verbose Mode: $VERBOSE - NO retry on error"
+			return $__ERR
+		elif [ $__ERR -gt 0 ]; then
+			__CNT=$(( $__CNT + 1 ))	# increment error counter
+			# if error count > retry_count leave here
+			[ $retry_count -gt 0 -a $__CNT -gt $retry_count ] && \
+				write_log 14 "Verify Proxy server '$1' failed after $retry_count retries"
+
+			write_log 4 "Verify Proxy server '$1' failed - retry $__CNT/$retry_count in $RETRY_SECONDS seconds"
+			sleep $RETRY_SECONDS &
+			PID_SLEEP=$!
+			wait $PID_SLEEP	# enable trap-handler
+			PID_SLEEP=0
+		fi
+	done
+	return 0
+}
+
+do_transfer() {
+	# $1	# URL to use
+	local __URL="$1"
+	local __ERR=0
+	local __CNT=0	# error counter
+	local __PROG  __RUNPROG
+
+	[ $# -ne 1 ] && write_log 12 "Error in 'do_transfer()' - wrong number of parameters"
+
+	# lets prefer GNU Wget because it does all for us - IPv4/IPv6/HTTPS/PROXY/force IP version
+	if [ -n "$WGET_SSL" -a $USE_CURL -eq 0 ]; then 			# except global option use_curl is set to "1"
+		__PROG="$WGET_SSL -nv -t 1 -O $DATFILE -o $ERRFILE"	# non_verbose no_retry outfile errfile
+		# force network/ip to use for communication
+		if [ -n "$bind_network" ]; then
+			local __BINDIP
+			# set correct program to detect IP
+			[ $use_ipv6 -eq 0 ] && __RUNPROG="network_get_ipaddr" || __RUNPROG="network_get_ipaddr6"
+			eval "$__RUNPROG __BINDIP $bind_network" || \
+				write_log 13 "Can not detect local IP using '$__RUNPROG $bind_network' - Error: '$?'"
+			write_log 7 "Force communication via IP '$__BINDIP'"
+			__PROG="$__PROG --bind-address=$__BINDIP"
+		fi
+		# force ip version to use
+		if [ $force_ipversion -eq 1 ]; then
+			[ $use_ipv6 -eq 0 ] && __PROG="$__PROG -4" || __PROG="$__PROG -6"	# force IPv4/IPv6
+		fi
+		# set certificate parameters
+		if [ $use_https -eq 1 ]; then
+			if [ "$cacert" = "IGNORE" ]; then	# idea from Ticket #15327 to ignore server cert
+				__PROG="$__PROG --no-check-certificate"
+			elif [ -f "$cacert" ]; then
+				__PROG="$__PROG --ca-certificate=${cacert}"
+			elif [ -d "$cacert" ]; then
+				__PROG="$__PROG --ca-directory=${cacert}"
+			elif [ -n "$cacert" ]; then		# it's not a file and not a directory but given
+				write_log 14 "No valid certificate(s) found at '$cacert' for HTTPS communication"
+			fi
+		fi
+		# disable proxy if no set (there might be .wgetrc or .curlrc or wrong environment set)
+		[ -z "$proxy" ] && __PROG="$__PROG --no-proxy"
+
+		__RUNPROG="$__PROG '$__URL'"	# build final command
+		__PROG="GNU Wget"		# reuse for error logging
+
+	# 2nd choice is cURL IPv4/IPv6/HTTPS
+	# libcurl might be compiled without Proxy or HTTPS Support
+	elif [ -n "$CURL" ]; then
+		__PROG="$CURL -RsS -o $DATFILE --stderr $ERRFILE"
+		# check HTTPS support
+		[ -z "$CURL_SSL" -a $use_https -eq 1 ] && \
+			write_log 13 "cURL: libcurl compiled without https support"
+		# force network/interface-device to use for communication
+		if [ -n "$bind_network" ]; then
+			local __DEVICE
+			network_get_physdev __DEVICE $bind_network || \
+				write_log 13 "Can not detect local device using 'network_get_physdev $bind_network' - Error: '$?'"
+			write_log 7 "Force communication via device '$__DEVICE'"
+			__PROG="$__PROG --interface $__DEVICE"
+		fi
+		# force ip version to use
+		if [ $force_ipversion -eq 1 ]; then
+			[ $use_ipv6 -eq 0 ] && __PROG="$__PROG -4" || __PROG="$__PROG -6"	# force IPv4/IPv6
+		fi
+		# set certificate parameters
+		if [ $use_https -eq 1 ]; then
+			if [ "$cacert" = "IGNORE" ]; then	# idea from Ticket #15327 to ignore server cert
+				__PROG="$__PROG --insecure"	# but not empty better to use "IGNORE"
+			elif [ -f "$cacert" ]; then
+				__PROG="$__PROG --cacert $cacert"
+			elif [ -d "$cacert" ]; then
+				__PROG="$__PROG --capath $cacert"
+			elif [ -n "$cacert" ]; then		# it's not a file and not a directory but given
+				write_log 14 "No valid certificate(s) found at '$cacert' for HTTPS communication"
+			fi
+		fi
+		# disable proxy if no set (there might be .wgetrc or .curlrc or wrong environment set)
+		# or check if libcurl compiled with proxy support
+		if [ -z "$proxy" ]; then
+			__PROG="$__PROG --noproxy '*'"
+		elif [ -z "$CURL_PROXY" ]; then
+			# if libcurl has no proxy support and proxy should be used then force ERROR
+			write_log 13 "cURL: libcurl compiled without Proxy support"
+		fi
+
+		__RUNPROG="$__PROG '$__URL'"	# build final command
+		__PROG="cURL"			# reuse for error logging
+
+	# uclient-fetch possibly with ssl support if /lib/libustream-ssl.so installed
+	elif [ -n "$UCLIENT_FETCH" ]; then
+		# UCLIENT_FETCH_SSL not empty then SSL support available
+		UCLIENT_FETCH_SSL=$(find /lib /usr/lib -name libustream-ssl.so* 2>/dev/null)
+		__PROG="$UCLIENT_FETCH -q -O $DATFILE"
+		# force network/ip not supported
+		[ -n "$__BINDIP" ] && \
+			write_log 14 "uclient-fetch: FORCE binding to specific address not supported"
+		# force ip version to use
+		if [ $force_ipversion -eq 1 ]; then
+			[ $use_ipv6 -eq 0 ] && __PROG="$__PROG -4" || __PROG="$__PROG -6"       # force IPv4/IPv6
+		fi
+		# https possibly not supported
+		[ $use_https -eq 1 -a -z "$UCLIENT_FETCH_SSL" ] && \
+			write_log 14 "uclient-fetch: no HTTPS support! Additional install one of ustream-ssl packages"
+		# proxy support
+		[ -z "$proxy" ] && __PROG="$__PROG -Y off" || __PROG="$__PROG -Y on"
+		# https & certificates
+		if [ $use_https -eq 1 ]; then
+			if [ "$cacert" = "IGNORE" ]; then
+				__PROG="$__PROG --no-check-certificate"
+			elif [ -f "$cacert" ]; then
+				__PROG="$__PROG --ca-certificate=$cacert"
+			elif [ -n "$cacert" ]; then		# it's not a file; nothing else supported
+				write_log 14 "No valid certificate file '$cacert' for HTTPS communication"
+			fi
+		fi
+		__RUNPROG="$__PROG '$__URL' 2>$ERRFILE"		# build final command
+		__PROG="uclient-fetch"				# reuse for error logging
+
+	# Busybox Wget or any other wget in search $PATH (did not support neither IPv6 nor HTTPS)
+	elif [ -n "$WGET" ]; then
+		__PROG="$WGET -q -O $DATFILE"
+		# force network/ip not supported
+		[ -n "$__BINDIP" ] && \
+			write_log 14 "BusyBox Wget: FORCE binding to specific address not supported"
+		# force ip version not supported
+		[ $force_ipversion -eq 1 ] && \
+			write_log 14 "BusyBox Wget: Force connecting to IPv4 or IPv6 addresses not supported"
+		# https not supported
+		[ $use_https -eq 1 ] && \
+			write_log 14 "BusyBox Wget: no HTTPS support"
+		# disable proxy if no set (there might be .wgetrc or .curlrc or wrong environment set)
+		[ -z "$proxy" ] && __PROG="$__PROG -Y off"
+
+		__RUNPROG="$__PROG '$__URL' 2>$ERRFILE"		# build final command
+		__PROG="Busybox Wget"				# reuse for error logging
+
+	else
+		write_log 13 "Neither 'Wget' nor 'cURL' nor 'uclient-fetch' installed or executable"
+	fi
+
+	while : ; do
+		write_log 7 "#> $__RUNPROG"
+		eval $__RUNPROG			# DO transfer
+		__ERR=$?			# save error code
+		[ $__ERR -eq 0 ] && return 0	# no error leave
+		[ -n "$LUCI_HELPER" ] && return 1	# no retry if called by LuCI helper script
+
+		write_log 3 "$__PROG Error: '$__ERR'"
+		write_log 7 "$(cat $ERRFILE)"		# report error
+
+		[ $VERBOSE -gt 1 ] && {
+			# VERBOSE > 1 then NO retry
+			write_log 4 "Transfer failed - Verbose Mode: $VERBOSE - NO retry on error"
+			return 1
+		}
+
+		__CNT=$(( $__CNT + 1 ))	# increment error counter
+		# if error count > retry_count leave here
+		[ $retry_count -gt 0 -a $__CNT -gt $retry_count ] && \
+			write_log 14 "Transfer failed after $retry_count retries"
+
+		write_log 4 "Transfer failed - retry $__CNT/$retry_count in $RETRY_SECONDS seconds"
+		sleep $RETRY_SECONDS &
+		PID_SLEEP=$!
+		wait $PID_SLEEP	# enable trap-handler
+		PID_SLEEP=0
+	done
+	# we should never come here there must be a programming error
+	write_log 12 "Error in 'do_transfer()' - program coding error"
+}
+
+send_update() {
+	# $1	# IP to set at DDNS service provider
+	local __IP
+
+	[ $# -ne 1 ] && write_log 12 "Error calling 'send_update()' - wrong number of parameters"
+
+	if [ $upd_privateip -eq 0 ]; then
+		# verify given IP / no private IPv4's / no IPv6 addr starting with fxxx of with ":"
+		[ $use_ipv6 -eq 0 ] && __IP=$(echo $1 | grep -v -E "(^0|^10\.|^100\.6[4-9]\.|^100\.[7-9][0-9]\.|^100\.1[0-1][0-9]\.|^100\.12[0-7]\.|^127|^169\.254|^172\.1[6-9]\.|^172\.2[0-9]\.|^172\.3[0-1]\.|^192\.168)")
+		[ $use_ipv6 -eq 1 ] && __IP=$(echo $1 | grep "^[0-9a-eA-E]")
+	else
+		__IP=$(echo $1 | grep -m 1 -o "$IPV4_REGEX")		# valid IPv4 or
+		[ -z "$__IP" ] && __IP=$(echo $1 | grep -m 1 -o "$IPV6_REGEX")	# IPv6
+	fi
+	[ -z "$__IP" ] && {
+		write_log 3 "No or private or invalid IP '$1' given! Please check your configuration"
+		return 127
+	}
+
+	if [ -n "$update_script" ]; then
+		write_log 7 "parsing script '$update_script'"
+		. $update_script
+	else
+		local __URL __ERR
+
+		# do replaces in URL
+		__URL=$(echo $update_url | sed -e "s#\[USERNAME\]#$URL_USER#g"	-e "s#\[PASSWORD\]#$URL_PASS#g" \
+					       -e "s#\[PARAMENC\]#$URL_PENC#g"	-e "s#\[PARAMOPT\]#$param_opt#g" \
+					       -e "s#\[DOMAIN\]#$domain#g"	-e "s#\[IP\]#$__IP#g")
+		[ $use_https -ne 0 ] && __URL=$(echo $__URL | sed -e 's#^http:#https:#')
+
+		do_transfer "$__URL" || return 1
+
+		write_log 7 "DDNS Provider answered:${N}$(cat $DATFILE)"
+
+		[ -z "$UPD_ANSWER" ] && return 0	# not set then ignore
+
+		grep -i -E "$UPD_ANSWER" $DATFILE >/dev/null 2>&1
+		return $?	# "0" if found
+	fi
+}
+
+get_local_ip () {
+	# $1	Name of Variable to store local IP (LOCAL_IP)
+	local __CNT=0	# error counter
+	local __RUNPROG __DATA __URL __ERR
+
+	[ $# -ne 1 ] && write_log 12 "Error calling 'get_local_ip()' - wrong number of parameters"
+	write_log 7 "Detect local IP on '$ip_source'"
+
+	while : ; do
+		if [ -n "$ip_network" -a "$ip_source" = "network" ]; then
+			# set correct program
+			network_flush_cache	# force re-read data from ubus
+			[ $use_ipv6 -eq 0 ] && __RUNPROG="network_get_ipaddr" \
+						|| __RUNPROG="network_get_ipaddr6"
+			write_log 7 "#> $__RUNPROG __DATA '$ip_network'"
+
+			ifconfig_name=`ubus call network.interface.$ip_network status | grep -m 1 "device" | cut -f 4 -d '"' | tr -d $'\n'`
+			ifconfig_ip=`ifconfig | grep -A1 $ifconfig_name | grep 'inet addr:' | cut -f 2 -d ':' | cut -f 1 -d ' ' | tr -d $'\n'`
+			write_log 7 "ifconfig_name=$ifconfig_name; ifconfig_ip=$ifconfig_ip"
+
+			eval "$__RUNPROG __DATA $ip_network" || [ -n "$ifconfig_ip" ] && __DATA="$ifconfig_ip" && write_log 7 "Used ifconfig IP $ifconfig_ip instead" || write_log 3 "$__RUNPROG Error: '$?'"
+			[ -n "$__DATA" ] && write_log 7 "Local IP '$__DATA' detected on network '$ip_network'"
+		elif [ -n "$ip_interface" -a "$ip_source" = "interface" ]; then
+			local __DATA4=""; local __DATA6=""
+			ip_interface=""
+			for i in $(route -n | awk '$4 == "UG" {print $8,"\n"}' | tr -d $'\n'); do
+                res=$(ping -c 1 -I $i 8.8.8.8 > /dev/null 2> /dev/null; echo $?)
+                if [ "$res" = "0" -a -z "$ip_interface" ]; then
+                    ip_interface=$i
+                fi
+            done
+			if [ -n "$(which ip)" ]; then		# ip program installed
+				write_log 7 "#> ip -o addr show dev $ip_interface scope global >$DATFILE 2>$ERRFILE"
+				ip -o addr show dev $ip_interface scope global >$DATFILE 2>$ERRFILE
+				__ERR=$?
+				if [ $__ERR -eq 0 ]; then
+					# DATFILE (sample)
+					# 10: l2tp-inet: <POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP> mtu 1456 qdisc fq_codel state UNKNOWN qlen 3\    link/ppp
+					# 10: l2tp-inet    inet 95.30.176.51 peer 95.30.176.1/32 scope global l2tp-inet\       valid_lft forever preferred_lft forever
+					# 5: eth1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP qlen 1000\    link/ether 08:00:27:d0:10:32 brd ff:ff:ff:ff:ff:ff
+					# 5: eth1    inet 172.27.10.128/24 brd 172.27.10.255 scope global eth1\       valid_lft forever preferred_lft forever
+					# 5: eth1    inet 172.55.55.155/24 brd 172.27.10.255 scope global eth1\       valid_lft 12345sec preferred_lft 12345sec
+					# 5: eth1    inet6 2002:b0c7:f326::806b:c629:b8b9:433/128 scope global dynamic \       valid_lft 8026sec preferred_lft 8026sec
+					# 5: eth1    inet6 fd43:5368:6f6d:6500:806b:c629:b8b9:433/128 scope global dynamic \       valid_lft 8026sec preferred_lft 8026sec
+					# 5: eth1    inet6 fd43:5368:6f6d:6500:a00:27ff:fed0:1032/64 scope global dynamic \       valid_lft 14352sec preferred_lft 14352sec
+					# 5: eth1    inet6 2002:b0c7:f326::a00:27ff:fed0:1032/64 scope global dynamic \       valid_lft 14352sec preferred_lft 14352sec
+
+					#    remove      remove     remove      replace     replace
+					#     link     inet6 fxxx    sec      forever=>-1   / => ' ' to separate subnet from ip
+					sed "/link/d; /inet6 f/d; s/sec//g; s/forever/-1/g; s/\// /g" $DATFILE | \
+						awk '{ print $3" "$4" "$NF }' > $ERRFILE	# temp reuse ERRFILE
+					# we only need    inet?   IP  prefered time
+
+					local __TIME4=0;  local __TIME6=0
+					local __TYP __ADR __TIME
+					while read __TYP __ADR __TIME; do
+						__TIME=${__TIME:-0}	# supress shell errors on last (empty) line of DATFILE
+						#    IPversion       no "-1" record stored - now "-1" record or new time > oldtime
+						[ "$__TYP" = "inet6" -a $__TIME6 -ge 0 -a \( $__TIME -lt 0 -o $__TIME -gt $__TIME6 \) ] && {
+							__DATA6="$__ADR"
+							__TIME6="$__TIME"
+						}
+						[ "$__TYP" = "inet" -a $__TIME4 -ge 0 -a \( $__TIME -lt 0 -o $__TIME -gt $__TIME4 \) ] && {
+							__DATA4="$__ADR"
+							__TIME4="$__TIME"
+						}
+					done < $ERRFILE
+				else
+					write_log 3 "ip Error: '$__ERR'"
+					write_log 7 "$(cat $ERRFILE)"		# report error
+				fi
+			else					# use deprecated ifconfig
+				write_log 7 "#> ifconfig $ip_interface >$DATFILE 2>$ERRFILE"
+				ifconfig $ip_interface >$DATFILE 2>$ERRFILE
+				__ERR=$?
+				if [ $__ERR -eq 0 ]; then
+					__DATA4=$(awk '
+						/inet addr:/ {	# Filter IPv4
+						#   inet addr:192.168.1.1  Bcast:192.168.1.255  Mask:255.255.255.0
+						$1="";		# remove inet
+						$3="";		# remove Bcast: ...
+						$4="";		# remove Mask: ...
+						FS=":";		# separator ":"
+						$0=$0;		# reread to activate separator
+						$1="";		# remove addr
+						FS=" ";		# set back separator to default " "
+						$0=$0;		# reread to activate separator (remove whitespaces)
+						print $1;	# print IPv4 addr
+						}' $DATFILE
+					)
+					__DATA6=$(awk '
+						/inet6/ && /: [0-9a-eA-E]/ {	# Filter IPv6 exclude fxxx
+						#   inet6 addr: 2001:db8::xxxx:xxxx/32 Scope:Global
+						FS="/";		# separator "/"
+						$0=$0;		# reread to activate separator
+						$2="";		# remove everything behind "/"
+						FS=" ";		# set back separator to default " "
+						$0=$0;		# reread to activate separator
+						print $3;	# print IPv6 addr
+						}' $DATFILE
+					)
+				else
+					write_log 3 "ifconfig Error: '$__ERR'"
+					write_log 7 "$(cat $ERRFILE)"		# report error
+				fi
+			fi
+			[ $use_ipv6 -eq 0 ] && __DATA="$__DATA4" || __DATA="$__DATA6"
+			[ -n "$__DATA" ] && write_log 7 "Local IP '$__DATA' detected on interface '$ip_interface'"
+		elif [ -n "$ip_script" -a "$ip_source" = "script" ]; then
+			write_log 7 "#> $ip_script >$DATFILE 2>$ERRFILE"
+			eval $ip_script >$DATFILE 2>$ERRFILE
+			__ERR=$?
+			if [ $__ERR -eq 0 ]; then
+				__DATA=$(cat $DATFILE)
+				[ -n "$__DATA" ] && write_log 7 "Local IP '$__DATA' detected via script '$ip_script'"
+			else
+				write_log 3 "$ip_script Error: '$__ERR'"
+				write_log 7 "$(cat $ERRFILE)"		# report error
+			fi
+		elif [ -n "$ip_url" -a "$ip_source" = "web" ]; then
+			do_transfer "$ip_url"
+			# use correct regular expression
+			[ $use_ipv6 -eq 0 ] \
+				&& __DATA=$(grep -m 1 -o "$IPV4_REGEX" $DATFILE) \
+				|| __DATA=$(grep -m 1 -o "$IPV6_REGEX" $DATFILE)
+			[ -n "$__DATA" ] && write_log 7 "Local IP '$__DATA' detected on web at '$ip_url'"
+		else
+			write_log 12 "Error in 'get_local_ip()' - unhandled ip_source '$ip_source'"
+		fi
+		# valid data found return here
+		[ -n "$__DATA" ] && {
+			eval "$1=\"$__DATA\""
+			return 0
+		}
+
+		[ -n "$LUCI_HELPER" ] && return 1	# no retry if called by LuCI helper script
+
+		write_log 7 "Data detected:"
+		write_log 7 "$(cat $DATFILE)"
+
+		[ $VERBOSE -gt 1 ] && {
+			# VERBOSE > 1 then NO retry
+			write_log 4 "Get local IP via '$ip_source' failed - Verbose Mode: $VERBOSE - NO retry on error"
+			return 1
+		}
+
+		__CNT=$(( $__CNT + 1 ))	# increment error counter
+		# if error count > retry_count leave here
+		[ $retry_count -gt 0 -a $__CNT -gt $retry_count ] && \
+			write_log 14 "Get local IP via '$ip_source' failed after $retry_count retries"
+		write_log 4 "Get local IP via '$ip_source' failed - retry $__CNT/$retry_count in $RETRY_SECONDS seconds"
+		sleep $RETRY_SECONDS &
+		PID_SLEEP=$!
+		wait $PID_SLEEP	# enable trap-handler
+		PID_SLEEP=0
+	done
+	# we should never come here there must be a programming error
+	write_log 12 "Error in 'get_local_ip()' - program coding error"
+}
+
+get_registered_ip() {
+	# $1	Name of Variable to store public IP (REGISTERED_IP)
+	# $2	(optional) if set, do not retry on error
+	local __CNT=0	# error counter
+	local __ERR=255
+	local __REGEX  __PROG  __RUNPROG  __DATA  __IP
+	# return codes
+	# 1	no IP detected
+
+	[ $# -lt 1 -o $# -gt 2 ] && write_log 12 "Error calling 'get_registered_ip()' - wrong number of parameters"
+	[ $is_glue -eq 1 -a -z "$BIND_HOST" ] && write_log 14 "Lookup of glue records is only supported using BIND host"
+	write_log 7 "Detect registered/public IP"
+
+	# set correct regular expression
+	[ $use_ipv6 -eq 0 ] && __REGEX="$IPV4_REGEX" || __REGEX="$IPV6_REGEX"
+
+	if [ -n "$BIND_HOST" ]; then
+		__PROG="$BIND_HOST"
+		[ $use_ipv6 -eq 0 ] && __PROG="$__PROG -t A"  || __PROG="$__PROG -t AAAA"
+		if [ $force_ipversion -eq 1 ]; then			# force IP version
+			[ $use_ipv6 -eq 0 ] && __PROG="$__PROG -4"  || __PROG="$__PROG -6"
+		fi
+		[ $force_dnstcp -eq 1 ] && __PROG="$__PROG -T"	# force TCP
+		[ $is_glue -eq 1 ] && __PROG="$__PROG -v" # use verbose output to get additional section
+
+		__RUNPROG="$__PROG $lookup_host $dns_server >$DATFILE 2>$ERRFILE"
+		__PROG="BIND host"
+	elif [ -n "$KNOT_HOST" ]; then
+		__PROG="$KNOT_HOST"
+		[ $use_ipv6 -eq 0 ] && __PROG="$__PROG -t A"  || __PROG="$__PROG -t AAAA"
+		if [ $force_ipversion -eq 1 ]; then			# force IP version
+			[ $use_ipv6 -eq 0 ] && __PROG="$__PROG -4"  || __PROG="$__PROG -6"
+		fi
+		[ $force_dnstcp -eq 1 ] && __PROG="$__PROG -T"	# force TCP
+
+		__RUNPROG="$__PROG $lookup_host $dns_server >$DATFILE 2>$ERRFILE"
+		__PROG="Knot host"
+	elif [ -n "$DRILL" ]; then
+		__PROG="$DRILL -V0"			# drill options name @server type
+		if [ $force_ipversion -eq 1 ]; then			# force IP version
+			[ $use_ipv6 -eq 0 ] && __PROG="$__PROG -4"  || __PROG="$__PROG -6"
+		fi
+		[ $force_dnstcp -eq 1 ] && __PROG="$__PROG -t" || __PROG="$__PROG -u"	# force TCP
+		__PROG="$__PROG $lookup_host"
+		[ -n "$dns_server" ] && __PROG="$__PROG @$dns_server"
+		[ $use_ipv6 -eq 0 ] && __PROG="$__PROG A"  || __PROG="$__PROG AAAA"
+
+		__RUNPROG="$__PROG >$DATFILE 2>$ERRFILE"
+		__PROG="drill"
+	elif [ -n "$HOSTIP" ]; then	# hostip package installed
+		__PROG="$HOSTIP"
+		[ $force_dnstcp -ne 0 ] && \
+			write_log 14 "hostip - no support for 'DNS over TCP'"
+
+		# is IP given as dns_server ?
+		__IP=$(echo $dns_server | grep -m 1 -o "$IPV4_REGEX")
+		[ -z "$__IP" ] && __IP=$(echo $dns_server | grep -m 1 -o "$IPV6_REGEX")
+
+		# we got NO ip for dns_server, so build command
+		[ -z "$__IP" -a -n "$dns_server" ] && {
+			__IP="\`$HOSTIP"
+			[ $use_ipv6 -eq 1 -a $force_ipversion -eq 1 ] && __IP="$__IP -6"
+			__IP="$__IP $dns_server | grep -m 1 -o"
+			[ $use_ipv6 -eq 1 -a $force_ipversion -eq 1 ] \
+				&& __IP="$__IP '$IPV6_REGEX'" \
+				|| __IP="$__IP '$IPV4_REGEX'"
+			__IP="$__IP \`"
+		}
+
+		[ $use_ipv6 -eq 1 ] && __PROG="$__PROG -6"
+		[ -n "$dns_server" ] && __PROG="$__PROG -r $__IP"
+		__RUNPROG="$__PROG $lookup_host >$DATFILE 2>$ERRFILE"
+		__PROG="hostip"
+	elif [ -n "$NSLOOKUP" ]; then	# last use BusyBox nslookup
+		NSLOOKUP_MUSL=$($(which nslookup) localhost 2>&1 | grep -F "(null)")	# not empty busybox compiled with musl
+		[ $force_dnstcp -ne 0 ] && \
+			write_log 14 "Busybox nslookup - no support for 'DNS over TCP'"
+		[ -n "$NSLOOKUP_MUSL" -a -n "$dns_server" ] && \
+			write_log 14 "Busybox compiled with musl - nslookup don't support the use of DNS Server"
+		[ $force_ipversion -ne 0 ] && \
+			write_log 5 "Busybox nslookup - no support to 'force IP Version' (ignored)"
+
+		__RUNPROG="$NSLOOKUP $lookup_host $dns_server >$DATFILE 2>$ERRFILE"
+		__PROG="BusyBox nslookup"
+	else	# there must be an error
+		write_log 12 "Error in 'get_registered_ip()' - no supported Name Server lookup software accessible"
+	fi
+
+	while : ; do
+		write_log 7 "#> $__RUNPROG"
+		eval $__RUNPROG
+		__ERR=$?
+		if [ $__ERR -ne 0 ]; then
+			write_log 3 "$__PROG error: '$__ERR'"
+			write_log 7 "$(cat $ERRFILE)"
+		else
+			if [ -n "$BIND_HOST" -o -n "$KNOT_HOST" ]; then
+				if [ $is_glue -eq 1 ]; then
+					__DATA=$(cat $DATFILE | grep "^$lookup_host" | grep -om1 "$__REGEX" )
+				else
+					__DATA=$(cat $DATFILE | awk -F "address " '/has/ {print $2; exit}' )
+				fi
+			elif [ -n "$DRILL" ]; then
+				__DATA=$(cat $DATFILE | awk '/^'"$lookup_host"'/ {print $5; exit}' )
+			elif [ -n "$HOSTIP" ]; then
+				__DATA=$(cat $DATFILE | grep -om1 "$__REGEX")
+			elif [ -n "$NSLOOKUP" ]; then
+				__DATA=$(cat $DATFILE | sed -ne "/^Name:/,\$ { s/^Address[0-9 ]\{0,\}: \($__REGEX\).*$/\\1/p }" )
+			fi
+			[ -n "$__DATA" ] && {
+				write_log 7 "Registered IP '$__DATA' detected"
+				[ -z "$IPFILE" ] || echo "$__DATA" > $IPFILE
+				eval "$1=\"$__DATA\""	# valid data found
+				return 0		# leave here
+			}
+			write_log 4 "NO valid IP found"
+			__ERR=127
+		fi
+		[ -z "$IPFILE" ] || echo "" > $IPFILE
+
+		[ -n "$LUCI_HELPER" ] && return $__ERR	# no retry if called by LuCI helper script
+		[ -n "$2" ] && return $__ERR		# $2 is given -> no retry
+		[ $VERBOSE -gt 1 ] && {
+			# VERBOSE > 1 then NO retry
+			write_log 4 "Get registered/public IP for '$lookup_host' failed - Verbose Mode: $VERBOSE - NO retry on error"
+			return $__ERR
+		}
+
+		__CNT=$(( $__CNT + 1 ))	# increment error counter
+		# if error count > retry_count leave here
+		[ $retry_count -gt 0 -a $__CNT -gt $retry_count ] && \
+			write_log 14 "Get registered/public IP for '$lookup_host' failed after $retry_count retries"
+
+		write_log 4 "Get registered/public IP for '$lookup_host' failed - retry $__CNT/$retry_count in $RETRY_SECONDS seconds"
+		sleep $RETRY_SECONDS &
+		PID_SLEEP=$!
+		wait $PID_SLEEP	# enable trap-handler
+		PID_SLEEP=0
+	done
+	# we should never come here there must be a programming error
+	write_log 12 "Error in 'get_registered_ip()' - program coding error"
+}
+
+get_uptime() {
+	# $1	Variable to store result in
+	[ $# -ne 1 ] && write_log 12 "Error calling 'verify_host_port()' - wrong number of parameters"
+	local __UPTIME=$(cat /proc/uptime)
+	eval "$1=\"${__UPTIME%%.*}\""
+}
+
+trap_handler() {
+	# $1	trap signal
+	# $2	optional (exit status)
+	local __PIDS __PID
+	local __ERR=${2:-0}
+	local __OLD_IFS=$IFS
+	local __NEWLINE_IFS='
+' # __NEWLINE_IFS
+
+	[ $PID_SLEEP -ne 0 ] && kill -$1 $PID_SLEEP 2>/dev/null	# kill pending sleep if exist
+
+	case $1 in
+		 0)	if [ $__ERR -eq 0 ]; then
+				write_log 5 "pid '$$' exit normal at $(eval $DATE_PROG)${N}"
+			else
+				write_log 4 "pid '$$' exit with error '$__ERR' at $(eval $DATE_PROG)${N}"
+			fi ;;
+		 1)	write_log 6 "pid '$$' received 'sighup' at $(eval $DATE_PROG)"
+			# reload config via starting the script again
+			/usr/lib/ddns/dynamic_dns_updater.sh -v "0" -S "$__SECTIONID" -- start || true
+			exit 0 ;;	# and leave this one
+		 2)	write_log 5 "pid '$$' terminated by 'sigint' at $(eval $DATE_PROG)${N}";;
+		 3)	write_log 5 "pid '$$' terminated by 'sigquit' at $(eval $DATE_PROG)${N}";;
+		15)	write_log 5 "pid '$$' terminated by 'sigterm' at $(eval $DATE_PROG)${N}";;
+		 *)	write_log 13 "Unhandled signal '$1' in 'trap_handler()'";;
+	esac
+
+	__PIDS=$(pgrep -P $$)	# get my childs (pgrep prints with "newline")
+	IFS=$__NEWLINE_IFS
+	for __PID in $__PIDS; do
+		kill -$1 $__PID	# terminate it
+	done
+	IFS=$__OLD_IFS
+
+	# remove out and err file
+	[ -f $DATFILE ] && rm -f $DATFILE
+	[ -f $ERRFILE ] && rm -f $ERRFILE
+
+	# exit with correct handling:
+	# remove trap handling settings and send kill to myself
+	trap - 0 1 2 3 15
+	[ $1 -gt 0 ] && kill -$1 $$
+}
+
+split_FQDN() {
+	# $1	FQDN to split
+	# $2	name of variable to store TLD
+	# $3	name of variable to store (reg)Domain
+	# $4	name of variable to store Host/Subdomain
+
+	[ $# -ne 4 ] && write_log 12 "Error calling 'split_FQDN()' - wrong number of parameters"
+	[ -z "$1"  ] && write_log 12 "Error calling 'split_FQDN()' - missing FQDN to split"
+	[ -f $TLDFILE ] || write_log 12 "Error calling 'split_FQDN()' - missing file '$TLDFILE'"
+
+	local _HOST _FDOM _CTLD _FTLD
+	local _SET="$@"					# save given function parameters
+
+	local _PAR=$(echo "$1" | tr [A-Z] [a-z] | tr "." " ")	# to lower and replace DOT with SPACE
+	set -- $_PAR					# set new as function parameters
+	_PAR=""						# clear variable for later reuse
+	while [ -n "$1" ] ; do				# as long we have parameters
+		_PAR="$1 $_PAR"				# invert order of parameters
+		shift
+	done
+	set -- $_PAR					# use new as function parameters
+	_PAR=""						# clear variable
+
+	while [ -n "$1" ] ; do				# as long we have parameters
+		if [ -z "$_CTLD" ]; then 		# first loop
+			_CTLD="$1"			# CURRENT TLD to look at
+			shift
+		else
+			_CTLD="$1.$_CTLD"		# Next TLD to look at
+			shift
+		fi
+		# check if TLD exact match in tld_names.dat, save TLD
+		zcat $TLDFILE | grep -E "^$_CTLD$" >/dev/null 2>&1 && {
+			_FTLD="$_CTLD"		# save found
+			_FDOM="$1"		# save domain next step might be invalid
+			continue
+		}
+		# check if match any "*" in tld_names.dat,
+		zcat $TLDFILE | grep -E "^\*.$_CTLD$" >/dev/null 2>&1 && {
+			[ -z "$1" ] && break	# no more data break
+			# check if next level TLD match excludes "!" in tld_names.dat
+			if zcat $TLDFILE | grep -E "^!$1.$_CTLD$" >/dev/null 2>&1 ; then
+				_FTLD="$_CTLD"	# Yes
+			else
+				_FTLD="$1.$_CTLD"
+				shift
+			fi
+			_FDOM="$1"; shift
+		}
+		[ -n "$_FTLD" ] && break	# we have something valid, break
+	done
+
+	# the leftover parameters are the HOST/SUBDOMAIN
+	while [ -n "$1" ]; do
+		_HOST="$1 $_HOST"		# remember we need to invert
+		shift
+	done
+	_HOST=$(echo $_HOST | tr " " ".")	# insert DOT
+
+	set -- $_SET				# set back parameters from function call
+	[ -n "$_FTLD" ] && {
+		eval "$2=$_FTLD"		# set TLD
+		eval "$3=$_FDOM"		# set registrable domain
+		eval "$4=$_HOST"		# set HOST/SUBDOMAIN
+		return 0
+	}
+	eval "$2=''"		# clear TLD
+	eval "$3=''"		# clear registrable domain
+	eval "$4=''"		# clear HOST/SUBDOMAIN
+	return 1
+}
+
+expand_ipv6() {
+	# Original written for bash by
+	#.Author:  Florian Streibelt <florian@f-streibelt.de>
+	# Date:    08.04.2012
+	# License: Public Domain, but please be fair and
+	#          attribute the original author(s) and provide
+	#          a link to the original source for corrections:
+	#.         https://github.com/mutax/IPv6-Address-checks
+
+	# $1	IPv6 to expand
+	# $2	name of variable to store expanded IPv6
+	[ $# -ne 2 ] && write_log 12 "Error calling 'expand_ipv6()' - wrong number of parameters"
+
+	INPUT="$(echo "$1" | tr 'A-F' 'a-f')"
+	[ "$INPUT" = "::" ] && INPUT="::0"	# special case ::
+
+	O=""
+
+	while [ "$O" != "$INPUT" ]; do
+		O="$INPUT"
+
+		# fill all words with zeroes
+		INPUT=$( echo "$INPUT" | sed	-e 's|:\([0-9a-f]\{3\}\):|:0\1:|g' \
+						-e 's|:\([0-9a-f]\{3\}\)$|:0\1|g' \
+						-e 's|^\([0-9a-f]\{3\}\):|0\1:|g' \
+						-e 's|:\([0-9a-f]\{2\}\):|:00\1:|g' \
+						-e 's|:\([0-9a-f]\{2\}\)$|:00\1|g' \
+						-e 's|^\([0-9a-f]\{2\}\):|00\1:|g' \
+						-e 's|:\([0-9a-f]\):|:000\1:|g' \
+						-e 's|:\([0-9a-f]\)$|:000\1|g' \
+						-e 's|^\([0-9a-f]\):|000\1:|g' )
+
+	done
+
+	# now expand the ::
+	ZEROES=""
+
+	echo "$INPUT" | grep -qs "::"
+	if [ "$?" -eq 0 ]; then
+		GRPS="$( echo "$INPUT" | sed  's|[0-9a-f]||g' | wc -m )"
+		GRPS=$(( GRPS-1 ))		# remove carriage return
+		MISSING=$(( 8-GRPS ))
+		while [ $MISSING -gt 0 ]; do
+			ZEROES="$ZEROES:0000"
+			MISSING=$(( MISSING-1 ))
+		done
+
+		# be careful where to place the :
+		INPUT=$( echo "$INPUT" | sed	-e 's|\(.\)::\(.\)|\1'$ZEROES':\2|g' \
+						-e 's|\(.\)::$|\1'$ZEROES':0000|g' \
+						-e 's|^::\(.\)|'$ZEROES':0000:\1|g;s|^:||g' )
+	fi
+
+	# an expanded address has 39 chars + CR
+	if [ $(echo $INPUT | wc -m) != 40 ]; then
+		write_log 4 "Error in 'expand_ipv6()' - invalid IPv6 found: '$1' expanded: '$INPUT'"
+		eval "$2='invalid'"
+		return 1
+	fi
+
+	# echo the fully expanded version of the address
+	eval "$2=$INPUT"
+	return 0
+}
diff --recursive --unified --new-file --no-dereference orig/files/dynamic_dns_lucihelper.sh src/files/dynamic_dns_lucihelper.sh
--- orig/files/dynamic_dns_lucihelper.sh	1970-01-01 00:00:00.000000000 +0000
+++ src/files/dynamic_dns_lucihelper.sh	2022-10-07 06:31:35.000000000 +0000
@@ -0,0 +1,172 @@
+#!/bin/sh
+# /usr/lib/ddns/dynamic_dns_lucihelper.sh
+#
+#.Distributed under the terms of the GNU General Public License (GPL) version 2.0
+#.2014-2018 Christian Schoenebeck <christian dot schoenebeck at gmail dot com>
+# This script is used by luci-app-ddns
+#
+# variables in small chars are read from /etc/config/ddns as parameter given here
+# variables in big chars are defined inside these scripts as gloval vars
+# variables in big chars beginning with "__" are local defined inside functions only
+# set -vx  	#script debugger
+
+. /usr/lib/ddns/dynamic_dns_functions.sh	# global vars are also defined here
+
+usage() {
+	cat << EOF
+
+Usage:
+ $MYPROG [options] -- command
+
+Commands:
+ get_local_ip        using given INTERFACE or NETWORK or SCRIPT or URL
+ get_registered_ip   for given FQDN
+ verify_dns          given DNS-SERVER
+ verify_proxy        given PROXY
+ start               start given SECTION
+ reload              force running ddns processes to reload changed configuration
+ restart             restart all ddns processes
+
+Parameters:
+ -6                  => use_ipv6=1          (default 0)
+ -d DNS-SERVER       => dns_server=SERVER[:PORT]
+ -f                  => force_ipversion=1   (default 0)
+ -g                  => is_glue=1           (default 0)
+ -i INTERFACE        => ip_interface=INTERFACE; ip_source="interface"
+ -l FQDN             => lookup_host=FQDN
+ -n NETWORK          => ip_network=NETWORK; ip_source="network"
+ -p PROXY            => proxy=[USER:PASS@]PROXY:PORT
+ -s SCRIPT           => ip_script=SCRIPT; ip_source="script"
+ -t                  => force_dnstcp=1      (default 0)
+ -u URL              => ip_url=URL; ip_source="web"
+ -S SECTION          SECTION to start
+
+ -h                  => show this help and exit
+ -L                  => use_logfile=1    (default 0)
+ -v LEVEL            => VERBOSE=LEVEL    (default 0)
+ -V                  => show version and exit
+
+EOF
+}
+
+usage_err() {
+	printf %s\\n "$MYPROG: $@" >&2
+	usage >&2
+	exit 255
+}
+
+# preset some variables, wrong or not set in ddns-functions.sh
+SECTION_ID="lucihelper"
+LOGFILE="$ddns_logdir/$SECTION_ID.log"
+DATFILE="$ddns_rundir/$SECTION_ID.$$.dat"	# save stdout data of WGet and other extern programs called
+ERRFILE="$ddns_rundir/$SECTION_ID.$$.err"	# save stderr output of WGet and other extern programs called
+DDNSPRG="/usr/lib/ddns/dynamic_dns_updater.sh"
+VERBOSE=0		# no console logging
+# global variables normally set by reading DDNS UCI configuration
+use_syslog=0		# no syslog
+use_logfile=0		# no logfile
+
+use_ipv6=0		# Use IPv6 - default IPv4
+force_ipversion=0	# Force IP Version - default 0 - No
+force_dnstcp=0		# Force TCP on DNS - default 0 - No
+is_glue=0		# Is glue record - default 0 - No
+use_https=0		# not needed but must be set
+
+while getopts ":6d:fghi:l:n:p:s:S:tu:Lv:V" OPT; do
+	case "$OPT" in
+		6)	use_ipv6=1;;
+		d)	dns_server="$OPTARG";;
+		f)	force_ipversion=1;;
+		g)	is_glue=1;;
+		i)	ip_interface="$OPTARG"; ip_source="interface";;
+		l)	lookup_host="$OPTARG";;
+		n)	ip_network="$OPTARG"; ip_source="network";;
+		p)	proxy="$OPTARG";;
+		s)	ip_script="$OPTARG"; ip_source="script";;
+		t)	force_dnstcp=1;;
+		u)	ip_url="$OPTARG"; ip_source="web";;
+		h)	usage; exit 255;;
+		L)	use_logfile=1;;
+		v)	VERBOSE=$OPTARG;;
+		S)	SECTION=$OPTARG;;
+		V)	printf %s\\n "ddns-scripts $VERSION"; exit 255;;
+		:)	usage_err "option -$OPTARG missing argument";;
+		\?)	usage_err "invalid option -$OPTARG";;
+		*)	usage_err "unhandled option -$OPT $OPTARG";;
+	esac
+done
+shift $((OPTIND - 1 ))	# OPTIND is 1 based
+
+[ $# -eq 0 ] && usage_err "missing command"
+
+__RET=0
+case "$1" in
+	get_registered_ip)
+		[ -z "$lookup_host" ] && usage_err "command 'get_registered_ip': 'lookup_host' not set" 
+		write_log 7 "-----> get_registered_ip IP"
+		[ -z "$SECTION" ] || IPFILE="$ddns_rundir/$SECTION.ip"
+		IP=""
+		get_registered_ip IP
+		__RET=$?
+		[ $__RET -ne 0 ] && IP=""
+		printf "%s" "$IP"
+		;;
+	verify_dns)
+		[ -z "$dns_server" ] && usage_err "command 'verify_dns': 'dns_server' not set" 
+		write_log 7 "-----> verify_dns '$dns_server'"
+		verify_dns "$dns_server"
+		__RET=$?
+		;;
+	verify_proxy)
+		[ -z "$proxy" ] && usage_err "command 'verify_proxy': 'proxy' not set" 
+		write_log 7 "-----> verify_proxy '$proxy'"
+		verify_proxy "$proxy"
+		__RET=$?
+		;;
+	get_local_ip)
+		[ -z "$ip_source" ] && usage_err "command 'get_local_ip': 'ip_source' not set"
+		[ -n "$proxy" -a "$ip_source" = "web" ] && {
+			# proxy defined, used for ip_source=web
+			export HTTP_PROXY="http://$proxy"
+			export HTTPS_PROXY="http://$proxy"
+			export http_proxy="http://$proxy"
+			export https_proxy="http://$proxy"
+		}
+		# don't need IP only the return code
+		IP=""
+		if [ "$ip_source" = "web" -o  "$ip_source" = "script" ]; then
+			# we wait only 3 seconds for an
+			# answer from "web" or "script"
+			write_log 7 "-----> timeout 3 -- get_local_ip IP"
+			timeout 3 -- get_local_ip IP
+		else
+			write_log 7 "-----> get_local_ip IP"
+			get_local_ip IP
+		fi
+		__RET=$?
+		;;
+	start)
+		[ -z "$SECTION" ] &&  usage_err "command 'start': 'SECTION' not set"
+		if [ $VERBOSE -eq 0 ]; then	# start in background
+			$DDNSPRG -v 0 -S $SECTION -- start &
+		else
+			$DDNSPRG -v $VERBOSE -S $SECTION -- start
+		fi
+		;;
+	reload)
+		$DDNSPRG -- reload
+		;;
+	restart)
+		$DDNSPRG -- stop
+		sleep 1
+		$DDNSPRG -- start
+		;;
+	*)
+		__RET=255
+		;;
+esac
+
+# remove out and err file
+[ -f $DATFILE ] && rm -f $DATFILE
+[ -f $ERRFILE ] && rm -f $ERRFILE
+return $__RET
diff --recursive --unified --new-file --no-dereference orig/files/dynamic_dns_updater.sh src/files/dynamic_dns_updater.sh
--- orig/files/dynamic_dns_updater.sh	1970-01-01 00:00:00.000000000 +0000
+++ src/files/dynamic_dns_updater.sh	2022-10-07 06:31:35.000000000 +0000
@@ -0,0 +1,445 @@
+#!/bin/sh
+# /usr/lib/ddns/dynamic_dns_updater.sh
+#
+#.Distributed under the terms of the GNU General Public License (GPL) version 2.0
+# Original written by Eric Paul Bishop, January 2008
+# (Loosely) based on the script on the one posted by exobyte in the forums here:
+# http://forum.openwrt.org/viewtopic.php?id=14040
+# extended and partial rewritten
+#.2014-2018 Christian Schoenebeck <christian dot schoenebeck at gmail dot com>
+#
+# variables in small chars are read from /etc/config/ddns
+# variables in big chars are defined inside these scripts as global vars
+# variables in big chars beginning with "__" are local defined inside functions only
+# set -vx  	#script debugger
+
+. $(dirname $0)/dynamic_dns_functions.sh	# global vars are also defined here
+
+usage() {
+	cat << EOF
+
+Usage:
+ $MYPROG [options] -- command
+
+Commands:
+start                Start SECTION or NETWORK or all
+stop                 Stop NETWORK or all
+
+Parameters:
+ -n NETWORK          Start/Stop sections in background monitoring NETWORK, force VERBOSE=0
+ -S SECTION          SECTION to start
+                     use either -N NETWORK or -S SECTION
+
+ -h                  show this help and exit
+ -V                  show version and exit
+ -v LEVEL            VERBOSE=LEVEL (default 1)
+                        '0' NO output to console
+                        '1' output to console
+                        '2' output to console AND logfile
+                            + run once WITHOUT retry on error
+                        '3' output to console AND logfile
+                            + run once WITHOUT retry on error
+                            + NOT sending update to DDNS service
+
+EOF
+}
+
+usage_err() {
+	printf %s\\n "$MYPROG: $@" >&2
+	usage >&2
+	exit 1
+}
+
+while getopts ":hv:n:S:V" OPT; do
+	case "$OPT" in
+		h)	usage; exit 0;;
+		v)	VERBOSE=$OPTARG;;
+		n)	NETWORK=$OPTARG;;
+		S)	SECTION_ID=$OPTARG;;
+		V)	printf %s\\n "ddns-scripts $VERSION"; exit 0;;
+		:)	usage_err "option -$OPTARG missing argument";;
+		\?)	usage_err "invalid option -$OPTARG";;
+		*)	usage_err "unhandled option -$OPT $OPTARG";;
+	esac
+done
+shift $((OPTIND - 1 ))	# OPTIND is 1 based
+
+[ -n "$NETWORK" -a -n "$SECTION_ID" ] && usage_err "use either option '-N' or '-S' not both"
+[ $# -eq 0 ] && usage_err "missing command"
+[ $# -gt 1 ] && usage_err "to much commands"
+
+case "$1" in
+	start)
+		if [ -n "$NETWORK" ]; then
+			start_daemon_for_all_ddns_sections "$NETWORK"
+			exit 0
+		fi
+		if [ -z "$SECTION_ID" ]; then
+			start_daemon_for_all_ddns_sections
+			exit 0
+		fi
+		;;
+	stop)
+		if [ -n "$INTERFACE" ]; then
+			stop_daemon_for_all_ddns_sections "$NETWORK"
+			exit 0
+		else
+			stop_daemon_for_all_ddns_sections
+			exit 0
+		fi
+		exit 1
+		;;
+	reload)
+		killall -1 dynamic_dns_updater.sh 2>/dev/null
+		exit $?
+		;;
+	*)	usage_err "unknown command - $1";;
+esac
+
+# set file names
+PIDFILE="$ddns_rundir/$SECTION_ID.pid"	# Process ID file
+UPDFILE="$ddns_rundir/$SECTION_ID.update"	# last update successful send (system uptime)
+DATFILE="$ddns_rundir/$SECTION_ID.dat"	# save stdout data of WGet and other extern programs called
+ERRFILE="$ddns_rundir/$SECTION_ID.err"	# save stderr output of WGet and other extern programs called
+IPFILE="$ddns_rundir/$SECTION_ID.ip"	#
+LOGFILE="$ddns_logdir/$SECTION_ID.log"	# log file
+
+# VERBOSE > 1 delete logfile if exist to create an empty one
+# only with this data of this run for easier diagnostic
+# new one created by write_log function
+[ $VERBOSE -gt 1 -a -f $LOGFILE ] && rm -f $LOGFILE
+
+# TRAP handler
+trap "trap_handler 0 \$?" 0	# handle script exit with exit status
+trap "trap_handler 1"  1	# SIGHUP	Hangup / reload config
+trap "trap_handler 2"  2	# SIGINT	Terminal interrupt
+trap "trap_handler 3"  3	# SIGQUIT	Terminal quit
+# trap "trap_handler 9"  9	# SIGKILL	no chance to trap
+trap "trap_handler 15" 15	# SIGTERM	Termination
+
+################################################################################
+# Leave this comment here, to clearly document variable names that are expected/possible
+# Use load_all_config_options to load config options, which is a much more flexible solution.
+#
+# config_load "ddns"
+# config_get <variable> $SECTION_ID <option>
+#
+# defined options (also used as variable):
+#
+# enabled	self-explanatory
+# interface 	network interface used by hotplug.d i.e. 'wan' or 'wan6'
+#
+# service_name	Which DDNS service do you use or "custom"
+# update_url	URL to use to update your "custom" DDNS service
+# update_script SCRIPT to use to update your "custom" DDNS service
+#
+# lookup_host	FQDN of ONE of your at DDNS service defined host / required to validate if IP update happen/necessary
+# domain 	Nomally your DDNS hostname / replace [DOMAIN] in update_url
+# username 	Username of your DDNS service account / urlenceded and replace [USERNAME] in update_url
+# password 	Password of your DDNS service account / urlencoded and replace [PASSWORD] in update_url
+# param_enc	Optional parameter for (later) usage  / urlencoded and replace [PARAMENC] in update_url
+# param_opt	Optional parameter for (later) usage  / replace [PARAMOPT] in update_url
+#
+# use_https	use HTTPS to update DDNS service
+# cacert	file or directory where HTTPS can find certificates to verify server; 'IGNORE' ignore check of server certificate
+#
+# use_syslog	log activity to syslog
+#
+# ip_source	source to detect current local IP ('network' or 'web' or 'script' or 'interface')
+# ip_network	local defined network to read IP from i.e. 'wan' or 'wan6'
+# ip_url	URL to read local address from i.e. http://checkip.dyndns.com/ or http://checkipv6.dyndns.com/
+# ip_script	full path and name of your script to detect local IP
+# ip_interface	physical interface to use for detecting
+#
+# check_interval	check for changes every  !!! checks below 10 minutes make no sense because the Internet
+# check_unit		'days' 'hours' 'minutes' !!! needs about 5-10 minutes to sync an IP-change for an DNS entry
+#
+# force_interval	force to send an update to your service if no change was detected
+# force_unit		'days' 'hours' 'minutes' !!! force_interval="0" runs this script once for use i.e. with cron
+#
+# retry_interval	if error was detected retry in
+# retry_unit		'days' 'hours' 'minutes' 'seconds'
+# retry_count 		number of retries before scripts stops
+#
+# use_ipv6		detecting/sending IPv6 address
+# force_ipversion	force usage of IPv4 or IPv6 for the whole detection and update communication
+# dns_server		using a non default dns server to get Registered IP from Internet
+# force_dnstcp		force communication with DNS server via TCP instead of default UDP
+# proxy			using a proxy for communication !!! ALSO used to detect local IP via web => return proxy's IP !!!
+# use_logfile		self-explanatory "/var/log/ddns/$SECTION_ID.log"
+# is_glue			the record that should be updated is a glue record
+#
+# some functionality needs
+# - GNU Wget or cURL installed for sending updates to DDNS service
+# - BIND host installed to detect Registered IP
+#
+################################################################################
+
+load_all_config_options "ddns" "$SECTION_ID"
+ERR_LAST=$?	# save return code - equal 0 if SECTION_ID found
+
+# set defaults if not defined
+[ -z "$enabled" ]	  && enabled=0
+[ -z "$retry_count" ]	  && retry_count=0	# endless retry
+[ -z "$use_syslog" ]      && use_syslog=2	# syslog "Notice"
+[ -z "$use_https" ]       && use_https=0	# not use https
+[ -z "$use_logfile" ]     && use_logfile=1	# use logfile by default
+[ -z "$use_ipv6" ]	  && use_ipv6=0		# use IPv4 by default
+[ -z "$force_ipversion" ] && force_ipversion=0	# default let system decide
+[ -z "$force_dnstcp" ]	  && force_dnstcp=0	# default UDP
+[ -z "$ip_source" ]	  && ip_source="network"
+[ -z "$is_glue" ]	  && is_glue=0		# default the ddns record is not a glue record
+[ "$ip_source" = "network" -a -z "$ip_network" -a $use_ipv6 -eq 0 ] && ip_network="wan"  # IPv4: default wan
+[ "$ip_source" = "network" -a -z "$ip_network" -a $use_ipv6 -eq 1 ] && ip_network="wan6" # IPv6: default wan6
+[ "$ip_source" = "web" -a -z "$ip_url" -a $use_ipv6 -eq 0 ] && ip_url="http://checkip.dyndns.com"
+[ "$ip_source" = "web" -a -z "$ip_url" -a $use_ipv6 -eq 1 ] && ip_url="http://checkipv6.dyndns.com"
+[ "$ip_source" = "interface" ] && ip_interface="auto"
+
+# url encode username (might be email or something like this)
+# and password (might have special chars for security reason)
+# and optional parameter "param_enc"
+[ -n "$username" ] && urlencode URL_USER "$username"
+[ -n "$password" ] && urlencode URL_PASS "$password"
+[ -n "$param_enc" ] && urlencode URL_PENC "$param_enc"
+
+# SECTION_ID does not exists
+[ $ERR_LAST -ne 0 ] && {
+	[ $VERBOSE -le 1 ] && VERBOSE=2		# force console out and logfile output
+	[ -f $LOGFILE ] && rm -f $LOGFILE	# clear logfile before first entry
+	write_log  7 "************ ************** ************** **************"
+	write_log  5 "pid '$$' started at $(eval $DATE_PROG)"
+	write_log  7 "ddns version  : $VERSION"
+	write_log  7 "uci configuration:${N}$(uci -q show ddns | grep '=service' | sort)"
+	write_log 14 "Service section '$SECTION_ID' not defined"
+}
+
+write_log 7 "************ ************** ************** **************"
+write_log 5 "pid '$$' started at $(eval $DATE_PROG)"
+write_log 7 "ddns version  : $VERSION"
+write_log 7 "uci configuration:${N}$(uci -q show ddns.$SECTION_ID | sort)"
+# write_log 7 "ddns version  : $(opkg list-installed ddns-scripts | cut -d ' ' -f 3)"
+case $VERBOSE in
+	0) write_log  7 "verbose mode  : 0 - run normal, no console output";;
+	1) write_log  7 "verbose mode  : 1 - run normal, console mode";;
+	2) write_log  7 "verbose mode  : 2 - run once, no retry on error";;
+	3) write_log  7 "verbose mode  : 3 - run once, no retry on error, not sending update";;
+	*) write_log 14 "error detecting VERBOSE '$VERBOSE'";;
+esac
+
+# check enabled state otherwise we don't need to continue
+[ $enabled -eq 0 ] && write_log 14 "service section disabled"
+
+# determine what update url we're using if a service_name is supplied
+# otherwise update_url is set inside configuration (custom update url)
+# or update_script is set inside configuration (custom update script)
+[ -n "$service_name" ] && get_service_data update_url update_script UPD_ANSWER
+[ -z "$update_url" -a -z "$update_script" ] && write_log 14 "No update_url found/defined or no update_script found/defined!"
+[ -n "$update_script" -a ! -f "$update_script" ] && write_log 14 "Custom update_script not found!"
+
+# temporary needed to convert existing uci settings
+[ -z "$lookup_host" ] && {
+	uci -q set ddns.$SECTION_ID.lookup_host="$domain"
+	uci -q commit ddns
+	lookup_host="$domain"
+}
+# later versions only check if configured correctly
+
+# without lookup host and possibly other required options we can do nothing for you
+[ -z "$lookup_host" ] && write_log 14 "Service section not configured correctly! Missing 'lookup_host'"
+
+# verify validity of variables
+[ -n "$lookup_host" ] && sanitize_variable lookup_host "$DNS_CHARSET" ""
+[ -n "$dns_server" ] && sanitize_variable dns_server "$DNS_CHARSET" ""
+[ -n "$domain" ] && sanitize_variable domain "$DNS_CHARSET" ""
+
+# Filter shell escape characters, if these are required in the URL, they
+# can still be passed url encoded
+[ -n "$param_opt" ] && sanitize_variable param_opt "" "$SHELL_ESCAPE"
+
+[ -n "$update_url" ] && {
+	# only check if update_url is given, update_scripts have to check themselves
+	[ -z "$domain" ] && $(echo "$update_url" | grep "\[DOMAIN\]" >/dev/null 2>&1) && \
+		write_log 14 "Service section not configured correctly! Missing 'domain'"
+	[ -z "$username" ] && $(echo "$update_url" | grep "\[USERNAME\]" >/dev/null 2>&1) && \
+		write_log 14 "Service section not configured correctly! Missing 'username'"
+	[ -z "$password" ] && $(echo "$update_url" | grep "\[PASSWORD\]" >/dev/null 2>&1) && \
+		write_log 14 "Service section not configured correctly! Missing 'password'"
+	[ -z "$param_enc" ] && $(echo "$update_url" | grep "\[PARAMENC\]" >/dev/null 2>&1) && \
+		write_log 14 "Service section not configured correctly! Missing 'param_enc'"
+	[ -z "$param_opt" ] && $(echo "$update_url" | grep "\[PARAMOPT\]" >/dev/null 2>&1) && \
+		write_log 14 "Service section not configured correctly! Missing 'param_opt'"
+}
+
+# verify ip_source 'script' if script is configured and executable
+if [ "$ip_source" = "script" ]; then
+	set -- $ip_script	#handling script with parameters, we need a trick
+	[ -z "$1" ] && write_log 14 "No script defined to detect local IP!"
+	[ -x "$1" ] || write_log 14 "Script to detect local IP not executable!"
+fi
+
+# compute update interval in seconds
+get_seconds CHECK_SECONDS ${check_interval:-10} ${check_unit:-"minutes"} # default 10 min
+get_seconds FORCE_SECONDS ${force_interval:-72} ${force_unit:-"hours"}	 # default 3 days
+get_seconds RETRY_SECONDS ${retry_interval:-60} ${retry_unit:-"seconds"} # default 60 sec
+[ $CHECK_SECONDS -lt 300 ] && CHECK_SECONDS=300		# minimum 5 minutes
+[ $FORCE_SECONDS -gt 0 -a $FORCE_SECONDS -lt $CHECK_SECONDS ] && FORCE_SECONDS=$CHECK_SECONDS	# FORCE_SECONDS >= CHECK_SECONDS or 0
+write_log 7 "check interval: $CHECK_SECONDS seconds"
+write_log 7 "force interval: $FORCE_SECONDS seconds"
+write_log 7 "retry interval: $RETRY_SECONDS seconds"
+write_log 7 "retry counter : $retry_count times"
+
+# kill old process if it exists & set new pid file
+stop_section_processes "$SECTION_ID"
+[ $? -gt 0 ] && write_log 7 "'SIGTERM' was send to old process" || write_log 7 "No old process"
+echo $$ > $PIDFILE
+
+# determine when the last update was
+# the following lines should prevent multiple updates if hotplug fires multiple startups
+# as described in Ticket #7820, but did not function if never an update take place
+# i.e. after a reboot (/var is linked to /tmp)
+# using uptime as reference because date might not be updated via NTP client
+get_uptime CURR_TIME
+[ -e "$UPDFILE" ] && {
+	LAST_TIME=$(cat $UPDFILE)
+	# check also LAST > CURR because link of /var/run to /tmp might be removed
+	# i.e. boxes with larger filesystems
+	[ -z "$LAST_TIME" ] && LAST_TIME=0
+	[ $LAST_TIME -gt $CURR_TIME ] && LAST_TIME=0
+}
+if [ $LAST_TIME -eq 0 ]; then
+	write_log 7 "last update: never"
+else
+	EPOCH_TIME=$(( $(date +%s) - $CURR_TIME + $LAST_TIME ))
+	EPOCH_TIME="date -d @$EPOCH_TIME +'$ddns_dateformat'"
+	write_log 7 "last update: $(eval $EPOCH_TIME)"
+fi
+
+# verify DNS server
+[ -n "$dns_server" ] && verify_dns "$dns_server"
+
+# verify Proxy server and set environment
+[ -n "$proxy" ] && {
+	verify_proxy "$proxy" && {
+		# everything ok set proxy
+		export HTTP_PROXY="http://$proxy"
+		export HTTPS_PROXY="http://$proxy"
+		export http_proxy="http://$proxy"
+		export https_proxy="http://$proxy"
+	}
+}
+
+# let's check if there is already an IP registered on the web
+get_registered_ip REGISTERED_IP "NO_RETRY"
+ERR_LAST=$?
+#     No error    or     No IP set	 otherwise retry
+[ $ERR_LAST -eq 0 -o $ERR_LAST -eq 127 ] || get_registered_ip REGISTERED_IP
+# on IPv6 we use expanded version to be shure when comparing
+[ $use_ipv6 -eq 1 ] && expand_ipv6 "$REGISTERED_IP" REGISTERED_IP
+
+# loop endlessly, checking ip every check_interval and forcing an updating once every force_interval
+write_log 6 "Starting main loop at $(eval $DATE_PROG)"
+SLEEP_TIME=0
+SLEEP_AFTER_FORCE=0
+while : ; do
+
+	get_local_ip LOCAL_IP		# read local IP
+	[ $use_ipv6 -eq 1 ] && expand_ipv6 "$LOCAL_IP" LOCAL_IP	# on IPv6 we use expanded version
+
+	# prepare update
+	# never updated or forced immediate then NEXT_TIME = 0
+	[ $FORCE_SECONDS -eq 0 -o $LAST_TIME -eq 0 ] \
+		&& NEXT_TIME=0 \
+		|| NEXT_TIME=$(( $LAST_TIME + $FORCE_SECONDS ))
+
+	get_uptime CURR_TIME		# get current uptime
+
+	# send update when current time > next time or local ip different from registered ip
+	if [ $CURR_TIME -ge $NEXT_TIME -o "$LOCAL_IP" != "$REGISTERED_IP" ]; then
+		if [ $VERBOSE -gt 2 ]; then
+			write_log 7 "Verbose Mode: $VERBOSE - NO UPDATE send"
+		elif [ "$LOCAL_IP" != "$REGISTERED_IP" ]; then
+			write_log 7 "Update needed - L: '$LOCAL_IP' <> R: '$REGISTERED_IP'"
+		else
+			write_log 7 "Forced Update - L: '$LOCAL_IP' == R: '$REGISTERED_IP'"
+		fi
+
+		ERR_LAST=0
+		[ $VERBOSE -lt 3 ] && {
+			# only send if VERBOSE < 3
+			send_update "$LOCAL_IP"
+			ERR_LAST=$?	# save return value
+		}
+
+		# error sending local IP to provider
+		# we have no communication error (handled inside send_update/do_transfer)
+		# but update was not recognized
+		# do NOT retry after RETRY_SECONDS, do retry after CHECK_SECONDS
+		# to early retrys will block most DDNS provider
+		# providers answer is checked inside send_update() function
+		if [ $ERR_LAST -eq 0 ]; then
+			get_uptime LAST_TIME		# we send update, so
+			echo $LAST_TIME > $UPDFILE	# save LASTTIME to file
+			[ "$LOCAL_IP" != "$REGISTERED_IP" ] \
+				&& write_log 6 "Update successful - IP '$LOCAL_IP' send" \
+				|| write_log 6 "Forced update successful - IP: '$LOCAL_IP' send"
+		elif [ $ERR_LAST -eq 127 ]; then
+			write_log 3 "No update send to DDNS Provider"
+		else
+			write_log 3 "IP update not accepted by DDNS Provider"
+		fi
+	fi
+
+	# now we wait for check interval before testing if update was recognized
+	# only sleep if VERBOSE <= 2 because otherwise nothing was send
+	[ $VERBOSE -le 2 ] && {
+		SLEEP_TIME=`expr $SLEEP_TIME + $CHECK_SECONDS`
+        if [ $SLEEP_TIME -ge $FORCE_SECONDS ]; then
+            sleep2=`expr $SLEEP_TIME - $CHECK_SECONDS`
+            SLEEP_AFTER_FORCE=`expr $FORCE_SECONDS - $sleep2`
+            write_log 7 "Waiting $SLEEP_AFTER_FORCE seconds (force interval)"
+		    sleep $SLEEP_AFTER_FORCE &
+		    SLEEP_TIME=0
+		elif [ $SLEEP_AFTER_FORCE -ne 0 ]; then
+		    write_log 7 "Waiting `expr $CHECK_SECONDS - $SLEEP_AFTER_FORCE` seconds (after force interval)"
+		    SLEEP_TIME=`expr $CHECK_SECONDS - $SLEEP_AFTER_FORCE`
+		    sleep $SLEEP_TIME &
+		    SLEEP_AFTER_FORCE=0
+		else
+		    write_log 7 "Waiting $CHECK_SECONDS seconds (check interval)"
+		    sleep $CHECK_SECONDS &
+		fi
+		PID_SLEEP=$!
+		wait $PID_SLEEP	# enable trap-handler
+		PID_SLEEP=0
+	} || write_log 7 "Verbose Mode: $VERBOSE - NO Check Interval waiting"
+
+	REGISTERED_IP=""		# clear variable
+	get_registered_ip REGISTERED_IP	# get registered/public IP
+	[ $use_ipv6 -eq 1 ] && expand_ipv6 "$REGISTERED_IP" REGISTERED_IP	# on IPv6 we use expanded version
+
+	# IP's are still different
+	if [ "$LOCAL_IP" != "$REGISTERED_IP" ]; then
+		if [ $VERBOSE -le 1 ]; then	# VERBOSE <=1 then retry
+			ERR_UPDATE=$(( $ERR_UPDATE + 1 ))
+			[ $retry_count -gt 0 -a $ERR_UPDATE -gt $retry_count ] && \
+				write_log 14 "Updating IP at DDNS provider failed after $retry_count retries"
+			write_log 4 "Updating IP at DDNS provider failed - starting retry $ERR_UPDATE/$retry_count"
+			continue # loop to beginning
+		else
+			write_log 4 "Updating IP at DDNS provider failed"
+			write_log 7 "Verbose Mode: $VERBOSE - NO retry"; exit 1
+		fi
+	else
+		# we checked successful the last update
+		ERR_UPDATE=0			# reset error counter
+	fi
+
+	# force_update=0 or VERBOSE > 1 - leave here
+	[ $VERBOSE -gt 1 ]  && write_log 7 "Verbose Mode: $VERBOSE - NO reloop"
+	[ $FORCE_SECONDS -eq 0 ] && write_log 6 "Configured to run once"
+	[ $VERBOSE -gt 1 -o $FORCE_SECONDS -eq 0 ] && exit 0
+
+	write_log 6 "Rerun IP check at $(eval $DATE_PROG)"
+done
+# we should never come here there must be a programming error
+write_log 12 "Error in 'dynamic_dns_updater.sh - program coding error"
diff --recursive --unified --new-file --no-dereference orig/files/services src/files/services
--- orig/files/services	1970-01-01 00:00:00.000000000 +0000
+++ src/files/services	2022-10-07 06:31:35.000000000 +0000
@@ -0,0 +1,185 @@
+# 44444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444
+#
+# This file contains the update urls for various dynamic dns services.
+# Column one contains the service name, column two contains the update url.
+# within the update url there are 4 variables you can use: [USERNAME],
+# [PASSWORD], [DOMAIN] and [IP].  These are substituted for the username,
+# password, and domain name specified in the /etc/config/ddns file when an
+# update is performed.  The IP is substituted for the current ip address of the
+# router.  These variables are case sensitive, while urls generally are not, so
+# if you need to enter the same text in the url (which seems very unlikely) put
+# that text in lowercase, while the variables should remain in uppercase
+#
+# There are TONS of dynamic dns services out there. There's a huge list of them at:
+# http://www.dmoz.org/Computers/Software/Internet/Servers/Address_Management/Dynamic_DNS_Services/
+# If anyone has time they could update this file to be compatible with a bunch of them
+#
+# !!! Since ddns-scripts Version 2.x the update of IPv6 addresses is also supported
+# !!! This file is used for update of IPv4 adresses only. For IPv6 use services_ipv6
+#
+# !!! Since ddns-scripts Version 2.x the update via provider specific update scripts is supported.
+# !!! This scripts must be located at /usr/lib/ddns directory if defined inside this file.
+# !!! Use only the script name (without path). Sample:
+# !!! "example.com"	"update_sample.sh"
+#
+# !!! Since ddns-scripts Version 2.5.x additional parameters are supported
+# !!! and a given answer on success is checked (ignored by earlier versions)
+# !!! Additional parameters: [PARAMOPT] and [PARAMENC]; [PARAMENC] is send urlencoded
+#
+# Line syntax: "service" [TAB] "update_url" [TAB] "answer"
+# "service"	name used as "option service_name" inside /etc/config/ddns
+# "update_url"	update url as given by the provider; custom urls should not saved here
+# "answer"	single words inside providers answer string; use "|" to combine "or"
+#
+# 44444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444
+#
+#.cloudflare.com-v4	!!! Please install additional package "ddns-scripts_cloudflare.com-v4"
+#.FreeDNS.42.pl 	!!! Please install additional package "ddns-scripts_freedns_42_pl"
+#.godaddy.com-v1	!!! Please install additional package "ddns-scripts_godaddy.com-v1"
+#.no-ip.com / noip.com	!!! Please install additional package "ddns-scripts_no-ip_com"
+#.route53-v1		!!! Please install additional package "ddns-scripts_route53-v1"
+
+"3322.org"		"http://[USERNAME]:[PASSWORD]@members.3322.org/dyndns/update?system=dyndns&hostname=[DOMAIN]&myip=[IP]"
+
+"able.or.kr"		"http://able.or.kr/ddns/src/update.php?hostname=[DOMAIN]&myip=[IP]&ddnsuser=[USERNAME]&pwd=[PASSWORD]"
+
+"afraid.org-basicauth"	"http://[USERNAME]:[PASSWORD]@freedns.afraid.org/nic/update?hostname=[DOMAIN]&myip=[IP]"
+"afraid.org-keyauth"	"http://freedns.afraid.org/dynamic/update.php?[PASSWORD]&address=[IP]"
+"afraid.org-v2-basic"	"http://[USERNAME]:[PASSWORD]@sync.afraid.org/u/?h=[DOMAIN]&ip=[IP]"
+"afraid.org-v2-token"	"http://sync.afraid.org/u/[PASSWORD]/?address=[IP]"
+
+"all-inkl.com"		"http://[USERNAME]:[PASSWORD]@dyndns.kasserver.com/?myip=[IP]"
+
+"binero.se" 		"http://[USERNAME]:[PASSWORD]@dyndns.binero.se/nic/update?hostname=[DOMAIN]&myip=[IP]"
+
+"changeip.com"		"http://[USERNAME]:[PASSWORD]@nic.changeip.com/nic/update?u=[USERNAME]&p=[PASSWORD]&cmd=update&hostname=[DOMAIN]&ip=[IP]"	"Successful"
+
+"core-networks.de"	"http://[USERNAME]:[PASSWORD]@dyndns.core-networks.de/?hostname=[DOMAIN]&myip=[IP]&keepipv6=1"	"good"
+
+"ddns.com.br"		"http://[DOMAIN]:[PASSWORD]@members.ddns.com.br/nic/update?hostname=[DOMAIN]&myip=[IP]"
+
+# "ddnss.de"		"http://[USERNAME]:[PASSWORD]@ip4.ddnss.de/upd.php?host=[DOMAIN]&ip=[IP]"	"good|nochg"
+"ddnss.de"		"http://ip4.ddnss.de/upd.php?user=[USERNAME]&pwd=[PASSWORD]&host=[DOMAIN]&ip=[IP]"	"good|nochg"
+
+"ddo.jp"		"http://free.ddo.jp/dnsupdate.php?dn=[DOMAIN]&pw=[PASSWORD]&ip=[IP]"
+
+"desec.io"		"http://update.dedyn.io/?username=[USERNAME]&password=[PASSWORD]&hostname=[DOMAIN]&myipv4=[IP]"	"good|nochg"
+
+"dhis.org"		"http://[USERNAME]:[PASSWORD]@is.dhis.org/"
+
+"dnsdynamic.org"	"http://[USERNAME]:[PASSWORD]@www.dnsdynamic.org/api/?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
+
+"dnsever.com"		"http://[USERNAME]:[PASSWORD]@dyna.dnsever.com/update.php?host[[DOMAIN]]"
+
+"dnsexit.com"		"http://update.dnsexit.com/RemoteUpdate.sv?login=[USERNAME]&password=[PASSWORD]&host=[DOMAIN]&myip=[IP]"
+
+"dnshome.de"		"http://[USERNAME]:[PASSWORD]@www.dnshome.de/dyndns.php?hostname=[DOMAIN]&ip=[IP]"
+
+"dnsmadeeasy.com"	"http://cp.dnsmadeeasy.com/servlet/updateip?username=[USERNAME]&password=[PASSWORD]&id=[DOMAIN]&ip=[IP]"	"success|ip-same"
+
+"dnsmax.com"		"http://update.dnsmax.com/update/?username=[USERNAME]&password=[PASSWORD]&resellerid=1&clientname=openwrt&clientversion=8.09&protocolversion=2.0&updatehostname=[DOMAIN]&ip=[IP]"
+
+"dnsomatic.com"		"http://[USERNAME]:[PASSWORD]@updates.dnsomatic.com/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
+
+"dnspark.com"		"http://[USERNAME]:[PASSWORD]@control.dnspark.com/api/dynamic/update.php?hostname=[DOMAIN]&ip=[IP]"	"ok|nochange"
+
+"do.de"			"http://ddns.do.de/?myip=[IP]&hostname=[DOMAIN]&username=[USERNAME]&password=[PASSWORD]"	"good|nochg"
+
+"domopoli.de"		"http://[USERNAME]:[PASSWORD]@http://dyndns.domopoli.de/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
+
+"dtdns.com"		"http://www.dtdns.com/api/autodns.cfm?id=[DOMAIN]&pw=[PASSWORD]&ip=[IP]"
+
+"duckdns.org"		"http://www.duckdns.org/update?domains=[DOMAIN]&token=[PASSWORD]&ip=[IP]"	"OK"
+
+"duiadns.net"		"http://ip.duiadns.net/dynamic.duia?host=[DOMAIN]&password=[PASSWORD]&ip4=[IP]"
+
+"dy.fi"			"http://[USERNAME]:[PASSWORD]@www.dy.fi/nic/update?hostname=[DOMAIN]"	"good|nochg"
+
+"dyndns.it"		"http://[USERNAME]:[PASSWORD]@update.dyndns.it/nic/update?system=dyndns&hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
+
+"dyn.com"		"http://[USERNAME]:[PASSWORD]@members.dyndns.org/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
+"dyndns.org"		"http://[USERNAME]:[PASSWORD]@members.dyndns.org/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
+
+"dyndnss.net"		"http://www.dyndnss.net/?user=[USERNAME]&pass=[PASSWORD]&domain=[DOMAIN]&updater=other"
+
+"dynsip.org"		"http://[USERNAME]:[PASSWORD]@dynsip.org/nic/update?hostname=[DOMAIN]&myip=[IP]"
+
+"dyns.net"		"http://www.dyns.net/postscript011.php?username=[USERNAME]&password=[PASSWORD]&host=[DOMAIN]&ip=[IP]"	"200"
+
+"dynu.com"		"http://api.dynu.com/nic/update?hostname=[DOMAIN]&myip=[IP]&username=[USERNAME]&password=[PASSWORD]"
+
+"dynv6.com"		"http://dynv6.com/api/update?hostname=[DOMAIN]&token=[PASSWORD]&ipv4=[IP]"	"updated|unchanged"
+
+"easydns.com"		"http://[USERNAME]:[PASSWORD]@api.cp.easydns.com/dyn/generic.php?hostname=[DOMAIN]&myip=[IP]"	"OK|NOERROR"
+
+"editdns.net"		"http://dyndns-free.editdns.net/api/dynLinux.php?p=[PASSWORD]&r=[DOMAIN]"
+
+"goip.de"		"http://www.goip.de/setip?username=[USERNAME]&password=[PASSWORD]&subdomain=[DOMAIN]&ip=[IP]"
+
+"google.com"		"http://[USERNAME]:[PASSWORD]@domains.google.com/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
+
+"he.net"		"http://[DOMAIN]:[PASSWORD]@dyn.dns.he.net/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
+
+"joker.com"		"http://svc.joker.com/nic/update?username=[USERNAME]&password=[PASSWORD]&myip=[IP]&hostname=[DOMAIN]"	"good|nochg"
+
+"loopia.se"		"http://[USERNAME]:[PASSWORD]@dns.loopia.se/XDynDNSServer/XDynDNS.php?system=custom&hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
+
+"mydns.jp"		"http://www.mydns.jp/directip.html?MID=[USERNAME]&PWD=[PASSWORD]&IPV4ADDR=[IP]"
+
+"myip.co.ua"		"http://[USERNAME]:[PASSWORD]@myip.co.ua/update?hostname=[DOMAIN]&myip=[IP]"	"good"
+
+"myonlineportal.net"	"http://[USERNAME]:[PASSWORD]@myonlineportal.net/updateddns?hostname=[DOMAIN]&ip=[IP]"	"good|nochg"
+
+"mythic-beasts.com"	"http://dnsapi4.mythic-beasts.com/?domain=[USERNAME]&password=[PASSWORD]&command=REPLACE%20[DOMAIN]%2060%20A%20DYNAMIC_IP&origin=."
+
+"namecheap.com"		"http://dynamicdns.park-your-domain.com/update?host=[USERNAME]&domain=[DOMAIN]&password=[PASSWORD]&ip=[IP]"
+
+"nettica.com"		"http://www.nettica.com/Domain/Update.aspx?U=[USERNAME]&PC=[PASSWORD]&FQDN=[DOMAIN]&N=[IP]"
+
+"no-ip.pl"		"http://[USERNAME]:[PASSWORD]@update.no-ip.pl/?hostname=[DOMAIN]"
+
+"now-dns.com"		"https://[USERNAME]:[PASSWORD]@now-dns.com/update?hostname=[DOMAIN]"	"good|nochg"
+
+"nsupdate.info"		"http://[USERNAME]:[PASSWORD]@ipv4.nsupdate.info/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
+
+"nubem.com"		"http://[USERNAME]:[PASSWORD]@nubem.com/nic/update?hostname=[DOMAIN]&myip=[IP]"
+
+"opendns.com"		"http://[USERNAME]:[PASSWORD]@updates.opendns.com/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
+
+"oray.com"		"http://[USERNAME]:[PASSWORD]@ddns.oray.com/ph/update?hostname=[DOMAIN]&myip=[IP]"
+
+"ovh.com"		"http://[USERNAME]:[PASSWORD]@www.ovh.com/nic/update?system=dyndns&hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
+
+"regfish.de"		"http://dyndns.regfish.de/?fqdn=[DOMAIN]&forcehost=1&authtype=secure&token=[PASSWORD]&ipv4=[IP]"	"success|100|101"
+
+"schokokeks.org"	"http://[USERNAME]:[PASSWORD]@dyndns.schokokeks.org/nic/update?myip=[IP]"	"good|nochg"
+
+"secure.camera"	"http://[USERNAME]:[PASSWORD]@secure.camera/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
+
+"selfhost.de"		"http://carol.selfhost.de/update?username=[USERNAME]&password=[PASSWORD]&myip=[IP]&hostname=1"	"good|nochg|200|204"
+
+"sitelutions.com"	"http://www.sitelutions.com/dnsup?user=[USERNAME]&pass=[PASSWORD]&id=[DOMAIN]&ip=[IP]"	"success"
+
+"spdyn.de"		"http://[USERNAME]:[PASSWORD]@update.spdyn.de/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
+"spdns.de"	"http://[USERNAME]:[PASSWORD]@update.spdns.de/nic/update?hostname=[DOMAIN]&myip=[IP]"
+
+"strato.com"		"http://[USERNAME]:[PASSWORD]@dyndns.strato.com/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
+
+"system-ns.com"		"http://system-ns.com/api?type=dynamic&command=set&domain=[DOMAIN]&token=[PASSWORD]&ip=[IP]"	"0"
+
+"thatip.com"		"http://update.dnsmax.com/update/?username=[USERNAME]&password=[PASSWORD]&resellerid=2&clientname=openwrt&clientversion=8.09&protocolversion=2.0&updatehostname=[DOMAIN]&ip=[IP]"
+
+"twodns.de"		"http://[USERNAME]:[PASSWORD]@update.twodns.de/update?hostname=[DOMAIN]&ip=[IP]"
+
+"udmedia.de"		"http://[USERNAME]:[PASSWORD]@www.udmedia.de/nic/update?myip=[IP]"
+
+"variomedia.de" 	"http://[USERNAME]:[PASSWORD]@dyndns.variomedia.de/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
+
+"xlhost.de"		"http://[USERNAME]:[PASSWORD]@nsupdate.xlhost.de/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
+
+"zerigo.com"		"http://update.zerigo.com/dynamic?user=[USERNAME]&password=[PASSWORD]&host=[DOMAIN]&ip=[IP]"	"ok"
+
+"zoneedit.com"		"http://[USERNAME]:[PASSWORD]@dynamic.zoneedit.com/auth/dynamic.html?host=[DOMAIN]&dnsto=[IP]"
+
+"zzzz.io"		"http://zzzz.io/api/v1/update/[DOMAIN]/?token=[PASSWORD]&ip=[IP]"	"Updated|No change"
+
diff --recursive --unified --new-file --no-dereference orig/files/services_ipv6 src/files/services_ipv6
--- orig/files/services_ipv6	1970-01-01 00:00:00.000000000 +0000
+++ src/files/services_ipv6	2022-10-07 06:31:35.000000000 +0000
@@ -0,0 +1,103 @@
+# 66666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666
+#
+# This file contains the update urls for various dynamic dns services.
+# Column one contains the service name, column two contains the update url.
+# within the update url there are 4 variables you can use: [USERNAME],
+# [PASSWORD], [DOMAIN] and [IP].  These are substituted for the username,
+# password, and domain name specified in the /etc/config/ddns file when an
+# update is performed.  The IP is substituted for the current ip address of the
+# router.  These variables are case sensitive, while urls generally are not, so
+# if you need to enter the same text in the url (which seems very unlikely) put
+# that text in lowercase, while the variables should remain in uppercase
+#
+# There are TONS of dynamic dns services out there. There's a huge list of them at:
+# http://www.dmoz.org/Computers/Software/Internet/Servers/Address_Management/Dynamic_DNS_Services/
+# If anyone has time they could update this file to be compatible with a bunch of them
+#
+# !!! Since ddns-scripts Version 2.x the update of IPv6 addresses is also supported
+# !!! This file is used for update of IPv6 adresses only. For IPv4 use services
+#
+# !!! Since ddns-scripts Version 2.x the update via provider specific update scripts is supported.
+# !!! This scripts must be located at /usr/lib/ddns directory if defined inside this file.
+# !!! Use only the script name (without path). Sample:
+# !!! "example.com"	"update_sample.sh"
+#
+# !!! Since ddns-scripts Version 2.5.x additional parameters are supported
+# !!! and a given answer on success is checked (ignored by earlier versions)
+# !!! Additional parameters: [PARAMOPT] and [PARAMENC]; [PARAMENC] is send urlencoded
+#
+# Line syntax: "service" [TAB] "update_url" [TAB] "answer"
+# "service"	name used as "option service_name" inside /etc/config/ddns
+# "update_url"	update url as given by the provider; custom urls should not saved here
+# "answer"	words inside providers answer string; use "|" to combine "or"
+#
+# 66666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666
+#
+#.cloudflare.com-v4	!!! Please install additional package "ddns-scripts_cloudflare.com-v4"
+#.godaddy.com-v1	!!! Please install additional package "ddns-scripts_godaddy.com-v1"
+#.no-ip.com / noip.com	!!! Please install additional package "ddns-scripts_no-ip_com"
+#.route53-v1		!!! Please install additional package "ddns-scripts_route53-v1"
+
+"afraid.org-basicauth"	"http://[USERNAME]:[PASSWORD]@freedns.afraid.org/nic/update?hostname=[DOMAIN]&myip=[IP]"
+"afraid.org-keyauth"	"http://freedns.afraid.org/dynamic/update.php?[PASSWORD]&address=[IP]"
+"afraid.org-v2-basic"	"http://[USERNAME]:[PASSWORD]@v6.sync.afraid.org/u/?h=[DOMAIN]&ip=[IP]"
+"afraid.org-v2-token"	"http://v6.sync.afraid.org/u/[PASSWORD]/?address=[IP]"
+
+"all-inkl.com"		"http://[USERNAME]:[PASSWORD]@dyndns.kasserver.com/?myip=[IP]"
+
+"core-networks.de"	"http://[USERNAME]:[PASSWORD]@dyndns.core-networks.de/?hostname=[DOMAIN]&myip=[IP]&keepipv4=1"	"good"
+
+# "ddnss.de"		"http://[USERNAME]:[PASSWORD]@ip6.ddnss.de/upd.php?host=[DOMAIN]&ip6=[IP]"	"good|nochg"
+"ddnss.de"		"http://ip6.ddnss.de/upd.php?user=[USERNAME]&pwd=[PASSWORD]&host=[DOMAIN]&ip6=[IP]"	"good|nochg"
+
+"desec.io"		"http://update.dedyn.io/?username=[USERNAME]&password=[PASSWORD]&hostname=[DOMAIN]&myipv6=[IP]"	"good|nochg"
+
+"dhis.org"		"http://[USERNAME]:[PASSWORD]@is.dhis.org/"
+
+"dnshome.de"		"http://[USERNAME]:[PASSWORD]@www.dnshome.de/dyndns.php?hostname=[DOMAIN]&ip6=[IP]"
+
+"do.de"			"http://ddns.do.de/?myip=[IP]&hostname=[DOMAIN]&username=[USERNAME]&password=[PASSWORD]"	"good|nochg"
+
+"duckdns.org"		"http://www.duckdns.org/update?domains=[DOMAIN]&token=[PASSWORD]&ipv6=[IP]"	"OK"
+
+"duiadns.net"		"http://ip.duiadns.net/dynamic.duia?host=[DOMAIN]&password=[PASSWORD]&ip6=[IP]"
+
+"dyn.com"		"http://[USERNAME]:[PASSWORD]@members.dyndns.org/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
+"dyndns.org"		"http://[USERNAME]:[PASSWORD]@members.dyndns.org/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
+
+"dynu.com"    		"http://api.dynu.com/nic/update?hostname=[DOMAIN]&myipv6=[IP]&username=[USERNAME]&password=[PASSWORD]"
+
+"dynv6.com"		"http://dynv6.com/api/update?hostname=[DOMAIN]&token=[PASSWORD]&ipv6=[IP]"	"updated|unchanged"
+
+"goip.de"		"http://www.goip.de/setip?username=[USERNAME]&password=[PASSWORD]&subdomain=[DOMAIN]&ip6=[IP]"
+
+"google.com"		"http://[USERNAME]:[PASSWORD]@domains.google.com/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
+
+"he.net"		"http://[DOMAIN]:[PASSWORD]@dyn.dns.he.net/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
+
+"loopia.se"		"http://[USERNAME]:[PASSWORD]@dns.loopia.se/XDynDNSServer/XDynDNS.php?system=custom&hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
+
+"mydns.jp"		"http://www.mydns.jp/directip.html?MID=[USERNAME]&PWD=[PASSWORD]&IPV6ADDR=[IP]"
+
+"myonlineportal.net"	"http://[USERNAME]:[PASSWORD]@myonlineportal.net/updateddns?hostname=[DOMAIN]&ip6=[IP]"	"good|nochg"
+
+"mythic-beasts.com"	"http://dnsapi6.mythic-beasts.com/?domain=[USERNAME]&password=[PASSWORD]&command=REPLACE%20[DOMAIN]%2060%20AAAA%20DYNAMIC_IP&origin=."
+
+"no-ip.pl"		"http://[USERNAME]:[PASSWORD]@update.no-ip.pl/?hostname=[DOMAIN]"
+
+"now-dns.com"		"https://[USERNAME]:[PASSWORD]@now-dns.com/update?hostname=[DOMAIN]"	"good|nochg"
+
+"nsupdate.info"		"http://[USERNAME]:[PASSWORD]@ipv6.nsupdate.info/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
+
+"regfish.de"		"http://dyndns.regfish.de/?fqdn=[DOMAIN]&forcehost=1&authtype=secure&token=[PASSWORD]&ipv6=[IP]"	"success|100|101"
+
+"spdyn.de"		"http://[USERNAME]:[PASSWORD]@update.spdyn.de/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
+
+"udmedia.de"		"http://[USERNAME]:[PASSWORD]@www.udmedia.de/nic/update?myip=[IP]"
+
+"variomedia.de"		"http://[USERNAME]:[PASSWORD]@dyndns.variomedia.de/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
+
+"zerigo.com"		"http://update.zerigo.com/dynamic?user=[USERNAME]&password=[PASSWORD]&host=[DOMAIN]&ip=[IP]"	"ok"
+
+"zzzz.io"		"http://zzzz.io/api/v1/update/[DOMAIN]/?token=[PASSWORD]&type=aaaa&ip=[IP]"	"Updated|No change"
+
diff --recursive --unified --new-file --no-dereference orig/files/update_cloudflare_com_v4.sh src/files/update_cloudflare_com_v4.sh
--- orig/files/update_cloudflare_com_v4.sh	1970-01-01 00:00:00.000000000 +0000
+++ src/files/update_cloudflare_com_v4.sh	2022-10-07 06:31:35.000000000 +0000
@@ -0,0 +1,197 @@
+#!/bin/sh
+#
+#.Distributed under the terms of the GNU General Public License (GPL) version 2.0
+#
+# script for sending updates to cloudflare.com
+#.based on Ben Kulbertis cloudflare-update-record.sh found at http://gist.github.com/benkulbertis
+#.and on George Johnson's cf-ddns.sh found at https://github.com/gstuartj/cf-ddns.sh
+#.2016-2018 Christian Schoenebeck <christian dot schoenebeck at gmail dot com>
+# CloudFlare API documentation at https://api.cloudflare.com/
+#
+# This script is parsed by dynamic_dns_functions.sh inside send_update() function
+#
+# using following options from /etc/config/ddns
+# option username  - your cloudflare e-mail
+# option password  - cloudflare api key, you can get it from cloudflare.com/my-account/
+# option domain    - "hostname@yourdomain.TLD"	# syntax changed to remove split_FQDN() function and tld_names.dat.gz
+#
+# The proxy status would not be changed by this script. Please change it in Cloudflare dashboard manually.
+#
+# variable __IP already defined with the ip-address to use for update
+#
+
+# check parameters
+[ -z "$CURL" ] && [ -z "$CURL_SSL" ] && write_log 14 "Cloudflare communication require cURL with SSL support. Please install"
+[ -z "$username" ] && write_log 14 "Service section not configured correctly! Missing key as 'username'"
+[ -z "$password" ] && write_log 14 "Service section not configured correctly! Missing secret as 'password'"
+[ $use_https -eq 0 ] && use_https=1	# force HTTPS
+
+# used variables
+local __HOST __DOMAIN __TYPE __URLBASE __PRGBASE __RUNPROG __DATA __IPV6 __ZONEID __RECID __PROXIED
+local __URLBASE="https://api.cloudflare.com/client/v4"
+local __TTL=120
+
+# split __HOST __DOMAIN from $domain
+# given data:
+# @example.com for "domain record"
+# host.sub@example.com for a "host record"
+__HOST=$(printf %s "$domain" | cut -d@ -f1)
+__DOMAIN=$(printf %s "$domain" | cut -d@ -f2)
+
+# Cloudflare v4 needs:
+# __DOMAIN = the base domain i.e. example.com
+# __HOST   = the FQDN of record to modify
+# i.e. example.com for the "domain record" or host.sub.example.com for "host record"
+
+# handling domain record then set __HOST = __DOMAIN
+[ -z "$__HOST" ] && __HOST=$__DOMAIN
+# handling host record then rebuild fqdn host@domain.tld => host.domain.tld
+[ "$__HOST" != "$__DOMAIN" ] && __HOST="${__HOST}.${__DOMAIN}"
+
+# set record type
+[ $use_ipv6 -eq 0 ] && __TYPE="A" || __TYPE="AAAA"
+
+# transfer function to use for godaddy
+# all needed variables are set global here
+# so we can use them directly
+cloudflare_transfer() {
+	local __CNT=0
+	local __ERR
+	while : ; do
+		write_log 7 "#> $__RUNPROG"
+		eval "$__RUNPROG"
+		__ERR=$?			# save communication error
+		[ $__ERR -eq 0 ] && break	# no error break while
+
+		write_log 3 "cURL Error: '$__ERR'"
+		write_log 7 "$(cat $ERRFILE)"		# report error
+
+		[ $VERBOSE_MODE -gt 1 ] && {
+			# VERBOSE_MODE > 1 then NO retry
+			write_log 4 "Transfer failed - Verbose Mode: $VERBOSE_MODE - NO retry on error"
+			break
+		}
+
+		__CNT=$(( $__CNT + 1 ))	# increment error counter
+		# if error count > retry_count leave here
+		[ $retry_count -gt 0 -a $__CNT -gt $retry_count ] && \
+			write_log 14 "Transfer failed after $retry_count retries"
+
+		write_log 4 "Transfer failed - retry $__CNT/$retry_count in $RETRY_SECONDS seconds"
+		sleep $RETRY_SECONDS &
+		PID_SLEEP=$!
+		wait $PID_SLEEP	# enable trap-handler
+		PID_SLEEP=0
+	done
+
+	# check for error
+	grep -q '"success":\s*true' $DATFILE || {
+		write_log 4 "CloudFlare reported an error:"
+		write_log 7 "$(cat $DATFILE)"		# report error
+		return 1	# HTTP-Fehler
+	}
+}
+
+# Build base command to use
+__PRGBASE="$CURL -RsS -o $DATFILE --stderr $ERRFILE"
+# force network/interface-device to use for communication
+if [ -n "$bind_network" ]; then
+	local __DEVICE
+	network_get_physdev __DEVICE $bind_network || \
+		write_log 13 "Can not detect local device using 'network_get_physdev $bind_network' - Error: '$?'"
+	write_log 7 "Force communication via device '$__DEVICE'"
+	__PRGBASE="$__PRGBASE --interface $__DEVICE"
+fi
+# force ip version to use
+if [ $force_ipversion -eq 1 ]; then
+	[ $use_ipv6 -eq 0 ] && __PRGBASE="$__PRGBASE -4" || __PRGBASE="$__PRGBASE -6"	# force IPv4/IPv6
+fi
+# set certificate parameters
+if [ "$cacert" = "IGNORE" ]; then	# idea from Ticket #15327 to ignore server cert
+	__PRGBASE="$__PRGBASE --insecure"	# but not empty better to use "IGNORE"
+elif [ -f "$cacert" ]; then
+	__PRGBASE="$__PRGBASE --cacert $cacert"
+elif [ -d "$cacert" ]; then
+	__PRGBASE="$__PRGBASE --capath $cacert"
+elif [ -n "$cacert" ]; then		# it's not a file and not a directory but given
+	write_log 14 "No valid certificate(s) found at '$cacert' for HTTPS communication"
+fi
+# disable proxy if not set (there might be .wgetrc or .curlrc or wrong environment set)
+# or check if libcurl compiled with proxy support
+if [ -z "$proxy" ]; then
+	__PRGBASE="$__PRGBASE --noproxy '*'"
+elif [ -z "$CURL_PROXY" ]; then
+	# if libcurl has no proxy support and proxy should be used then force ERROR
+	write_log 13 "cURL: libcurl compiled without Proxy support"
+fi
+# set headers
+if [ "$username" = "Bearer" ]; then
+  write_log 7 "Found Username 'Bearer' using Password as Bearer Authorization Token"
+  __PRGBASE="$__PRGBASE --header 'Authorization: Bearer $password' "
+else
+  __PRGBASE="$__PRGBASE --header 'X-Auth-Email: $username' "
+  __PRGBASE="$__PRGBASE --header 'X-Auth-Key: $password' "
+fi
+__PRGBASE="$__PRGBASE --header 'Content-Type: application/json' "
+
+# read zone id for registered domain.TLD
+__RUNPROG="$__PRGBASE --request GET '$__URLBASE/zones?name=$__DOMAIN'"
+cloudflare_transfer || return 1
+# extract zone id
+__ZONEID=$(grep -o '"id":\s*"[^"]*' $DATFILE | grep -o '[^"]*$' | head -1)
+[ -z "$__ZONEID" ] && {
+	write_log 4 "Could not detect 'zone id' for domain.tld: '$__DOMAIN'"
+	return 127
+}
+
+# read record id for A or AAAA record of host.domain.TLD
+__RUNPROG="$__PRGBASE --request GET '$__URLBASE/zones/$__ZONEID/dns_records?name=$__HOST&type=$__TYPE'"
+cloudflare_transfer || return 1
+# extract record id
+__RECID=$(grep -o '"id":\s*"[^"]*' $DATFILE | grep -o '[^"]*$' | head -1)
+[ -z "$__RECID" ] && {
+	write_log 4 "Could not detect 'record id' for host.domain.tld: '$__HOST'"
+	return 127
+}
+
+# extract current stored IP
+__DATA=$(grep -o '"content":\s*"[^"]*' $DATFILE | grep -o '[^"]*$' | head -1)
+
+# check data
+[ $use_ipv6 -eq 0 ] \
+	&& __DATA=$(printf "%s" "$__DATA" | grep -m 1 -o "$IPV4_REGEX") \
+	|| __DATA=$(printf "%s" "$__DATA" | grep -m 1 -o "$IPV6_REGEX")
+
+# we got data so verify
+[ -n "$__DATA" ] && {
+	# expand IPv6 for compare
+	if [ $use_ipv6 -eq 1 ]; then
+		expand_ipv6 $__IP __IPV6
+		expand_ipv6 $__DATA __DATA
+		[ "$__DATA" = "$__IPV6" ] && {		# IPv6 no update needed
+			write_log 7 "IPv6 at CloudFlare.com already up to date"
+			return 0
+		}
+	else
+		[ "$__DATA" = "$__IP" ] && {		# IPv4 no update needed
+			write_log 7 "IPv4 at CloudFlare.com already up to date"
+			return 0
+		}
+	fi
+}
+
+# update is needed
+# let's build data to send
+# set proxied parameter
+__PROXIED=$(grep -o '"proxied":\s*[^",]*' $DATFILE | grep -o '[^:]*$')
+
+# use file to work around " needed for json
+cat > $DATFILE << EOF
+{"id":"$__ZONEID","type":"$__TYPE","name":"$__HOST","content":"$__IP","ttl":$__TTL,"proxied":$__PROXIED}
+EOF
+
+# let's complete transfer command
+__RUNPROG="$__PRGBASE --request PUT --data @$DATFILE '$__URLBASE/zones/$__ZONEID/dns_records/$__RECID'"
+cloudflare_transfer || return 1
+
+return 0
diff --recursive --unified --new-file --no-dereference orig/files/update_freedns_42_pl.sh src/files/update_freedns_42_pl.sh
--- orig/files/update_freedns_42_pl.sh	1970-01-01 00:00:00.000000000 +0000
+++ src/files/update_freedns_42_pl.sh	2022-10-07 06:31:35.000000000 +0000
@@ -0,0 +1,17 @@
+#.Distributed under the terms of the GNU General Public License (GPL) version 2.0
+#.2018 Michal Lipka <michal at sysadmin dot care>
+local __DUMMY
+local __URL="https://freedns.42.pl/xmlrpc.php"
+[ -z "$username" ] && write_log 14 "Service section not configured correctly! Missing 'username'"
+[ -z "$password" ] && write_log 14 "Service section not configured correctly! Missing 'password'"
+[ $ip_dynamic -eq 1 ] && __IP='\&lt;dynamic\&gt;'
+PROG="$(which curl) -sk"
+write_log 7 "sending update to freedns.42.pl with ip $__IP"
+XMLDATA="<?xml version='1.0'?><methodCall><methodName>xname.updateArecord</methodName><params><param><value><struct><member><name>name</name><value><string>[RECORDNAME]</string></value></member><member><name>zone</name><value><string>[ZONENAME]</string></value></member><member><name>oldaddress</name><value><string>*</string></value></member><member><name>updatereverse</name><value><string>0</string></value></member><member><name>user</name><value><string>[USERNAME]</string></value></member><member><name>ttl</name><value><string>600</string></value></member><member><name>newaddress</name><value><string>[IP]</string></value></member><member><name>password</name><value><string>[PASSWORD]</string></value></member></struct></value></param></params></methodCall>"
+XMLDATA=$(echo $XMLDATA | sed -e "s#\[USERNAME\]#$URL_USER#g" -e "s#\[PASSWORD\]#$URL_PASS#g" \
+-e "s#\[ZONENAME\]#$zone#g" -e "s#\[RECORDNAME\]#$record#g" -e "s#\[IP\]#$__IP#g")
+$PROG -d "$XMLDATA" -o $DATFILE $__URL || return 1
+write_log 7 "'freedns.42.pl' answered:${N}$(cat $DATFILE)"
+grep "<fault>" $DATFILE > /dev/null 2>&1 && return 1
+grep '<name>serial</name>' $DATFILE >/dev/null 2>&1
+return $?
diff --recursive --unified --new-file --no-dereference orig/files/update_godaddy_com_v1.sh src/files/update_godaddy_com_v1.sh
--- orig/files/update_godaddy_com_v1.sh	1970-01-01 00:00:00.000000000 +0000
+++ src/files/update_godaddy_com_v1.sh	2022-10-07 06:31:35.000000000 +0000
@@ -0,0 +1,172 @@
+#!/bin/sh
+#
+#.Distributed under the terms of the GNU General Public License (GPL) version 2.0
+#
+# script for sending updates to godaddy.com
+#.based on GoDaddy.sh v1.0 by Nazar78 @ TeaNazaR.com
+#.2017-2018 Christian Schoenebeck <christian dot schoenebeck at gmail dot com>
+# GoDaddy Documentation at https://developer.godaddy.com/doc
+#
+# This script is parsed by dynamic_dns_functions.sh inside send_update() function
+#
+# using following options from /etc/config/ddns
+# option username - "key" as generated at https://developer.godaddy.com/keys/
+# option password - "secret" as generated at https://developer.godaddy.com/keys/
+# option domain   - "yourdomain.TLD" to update or "hostname@yourdomain.TLD"
+#
+# variable __IP already defined with the ip-address to use for update
+#
+
+# check parameters
+[ -z "$CURL" ] && [ -z "$CURL_SSL" ] && write_log 14 "GoDaddy communication require cURL with SSL support. Please install"
+[ -z "$username" ] && write_log 14 "Service section not configured correctly! Missing key as 'username'"
+[ -z "$password" ] && write_log 14 "Service section not configured correctly! Missing secret as 'password'"
+[ $use_https -eq 0 ] && use_https=1	# force HTTPS
+
+# used variables
+local __HOST __DOMAIN __TYPE __URL __PRGBASE __RUNPROG __DATA __IPV6
+
+# split __HOST __DOMAIN from $domain
+# given data:
+# @example.com for "domain record"
+# host.sub@example.com for a "host record"
+__HOST=$(printf %s "$domain" | cut -d@ -f1)
+__DOMAIN=$(printf %s "$domain" | cut -d@ -f2)
+
+# GoDaddy needs:
+# __DOMAIN = the base domain i.e. example.com
+# __HOST   = host.sub if updating a host record or
+# __HOST   = "@" urlencoded "%40" for a domain record
+[ -z "$__HOST" -o "$__HOST" = "$__DOMAIN" ] && __HOST="%40"
+
+# set record type
+[ $use_ipv6 -eq 0 ] && __TYPE="A" || __TYPE="AAAA"
+
+# now we know the url to use
+# __URL="https://api.ote-godaddy.com/v1/domains/$__DOMAIN/records/$__TYPE/$__HOST"	# api test server
+__URL="https://api.godaddy.com/v1/domains/$__DOMAIN/records/$__TYPE/$__HOST"		# production server
+
+# transfer function to use for godaddy
+# all needed variables are set global here
+# so we can use them directly
+godaddy_transfer() {
+	local __CNT=0
+	local __STATUS __ERR __DEVICE
+	while : ; do
+		write_log 7 "#> $__RUNPROG"
+		__STATUS=$(eval "$__RUNPROG")
+		__ERR=$?			# save communication error
+		[ $__ERR -eq 0 ] && break	# no error break while
+
+		write_log 4 "cURL error: '$__ERR'"
+		write_log 7 "$(cat $ERRFILE)"		# report error
+
+		[ $VERBOSE_MODE -gt 1 ] && {
+			# VERBOSE_MODE > 1 then NO retry
+			write_log 4 "Transfer failed - Verbose Mode: $VERBOSE_MODE - NO retry on error"
+			break
+		}
+
+		__CNT=$(( $__CNT + 1 ))	# increment error counter
+		# if error count > retry_count leave here
+		[ $retry_count -gt 0 -a $__CNT -gt $retry_count ] && \
+			write_log 14 "Transfer failed after $retry_count retries"
+
+		write_log 4 "Transfer failed - retry $__CNT/$retry_count in $RETRY_SECONDS seconds"
+		sleep $RETRY_SECONDS &
+		PID_SLEEP=$!
+		wait $PID_SLEEP	# enable trap-handler
+		PID_SLEEP=0
+	done
+
+	# handle HTTP error
+	[ $__STATUS -ne 200 ] && {
+		write_log 4 "GoDaddy reported an error:"
+		write_log 7 "$(cat $DATFILE)"
+		return 1
+	}
+	return 0
+}
+
+# Build base command to use
+__PRGBASE="$CURL -RsS -w '%{http_code}' -o $DATFILE --stderr $ERRFILE"
+# force network/interface-device to use for communication
+if [ -n "$bind_network" ]; then
+	local __DEVICE
+	network_get_physdev __DEVICE $bind_network || \
+		write_log 13 "Can not detect local device using 'network_get_physdev $bind_network' - Error: '$?'"
+	write_log 7 "Force communication via device '$__DEVICE'"
+	__PRGBASE="$__PRGBASE --interface $__DEVICE"
+fi
+# force ip version to use
+if [ $force_ipversion -eq 1 ]; then
+	[ $use_ipv6 -eq 0 ] && __PRGBASE="$__PRGBASE -4" || __PRGBASE="$__PRGBASE -6"	# force IPv4/IPv6
+fi
+# set certificate parameters
+if [ "$cacert" = "IGNORE" ]; then	# idea from Ticket #15327 to ignore server cert
+	__PRGBASE="$__PRGBASE --insecure"	# but not empty better to use "IGNORE"
+elif [ -f "$cacert" ]; then
+	__PRGBASE="$__PRGBASE --cacert $cacert"
+elif [ -d "$cacert" ]; then
+	__PRGBASE="$__PRGBASE --capath $cacert"
+elif [ -n "$cacert" ]; then		# it's not a file and not a directory but given
+	write_log 14 "No valid certificate(s) found at '$cacert' for HTTPS communication"
+fi
+# disable proxy if no set (there might be .wgetrc or .curlrc or wrong environment set)
+# or check if libcurl compiled with proxy support
+if [ -z "$proxy" ]; then
+	__PRGBASE="$__PRGBASE --noproxy '*'"
+elif [ -z "$CURL_PROXY" ]; then
+	# if libcurl has no proxy support and proxy should be used then force ERROR
+	write_log 13 "cURL: libcurl compiled without Proxy support"
+fi
+# set headers
+__PRGBASE="$__PRGBASE --header 'Authorization: sso-key $username:$password' "
+__PRGBASE="$__PRGBASE --header 'Accept: application/json' "
+__PRGBASE="$__PRGBASE --header 'Content-Type: application/json; charset=utf-8' "
+
+# read data from godaddy.com
+__RUNPROG="$__PRGBASE --request GET $__URL"
+godaddy_transfer || return 1
+
+# HTTP 200 OK, now analyse data and check if update needed
+__DATA=$(sed -r 's/.+data":"(.+)","t.+/\1/g' $DATFILE)
+
+# check data
+[ $use_ipv6 -eq 0 ] \
+	&& __DATA=$(printf "%s" "$__DATA" | grep -m 1 -o "$IPV4_REGEX") \
+	|| __DATA=$(printf "%s" "$__DATA" | grep -m 1 -o "$IPV6_REGEX")
+
+# we got data so verify
+[ -n "$__DATA" ] && {
+	# expand IPv6 for compare
+	if [ $use_ipv6 -eq 1 ]; then
+		expand_ipv6 $__IP __IPV6
+		expand_ipv6 $__DATA __DATA
+		[ "$__DATA" = "$__IPV6" ] && {		# IPv6 no update needed
+			write_log 7 "IPv6 at GoDaddy.com already up to date"
+			return 0
+		}
+	else
+		[ "$__DATA" = "$__IP" ] && {		# IPv4 no update needed
+			write_log 7 "IPv4 at GoDaddy.com already up to date"
+			return 0
+		}
+	fi
+}
+
+# update is needed
+# let's build data to send,
+# use file to work around double quotes '"' needed for json
+cat > $DATFILE << EOF
+[{"data":"$__IP"}]
+EOF
+
+# let's complete transfer command
+__RUNPROG="$__PRGBASE --request PUT --data @$DATFILE $__URL"
+
+godaddy_transfer || return 1
+
+# HTTP 200 OK
+return 0
+
diff --recursive --unified --new-file --no-dereference orig/files/update_no-ip_com.sh src/files/update_no-ip_com.sh
--- orig/files/update_no-ip_com.sh	1970-01-01 00:00:00.000000000 +0000
+++ src/files/update_no-ip_com.sh	2022-10-07 06:31:35.000000000 +0000
@@ -0,0 +1,52 @@
+#
+#.Distributed under the terms of the GNU General Public License (GPL) version 2.0
+#
+# script for sending updates to no-ip.com / noip.com
+#.2014-2015 Christian Schoenebeck <christian dot schoenebeck at gmail dot com>
+#
+# This script is parsed by dynamic_dns_functions.sh inside send_update() function
+#
+# provider did not reactivate records, if no IP change was recognized
+# so we send a dummy (localhost) and a seconds later we send the correct IP addr
+#
+# local __DUMMY
+local __UPDURL="http://[USERNAME]:[PASSWORD]@dynupdate.no-ip.com/nic/update?hostname=[DOMAIN]&myip=[IP]"
+# inside url we need username and password
+[ -z "$username" ] && write_log 14 "Service section not configured correctly! Missing 'username'"
+[ -z "$password" ] && write_log 14 "Service section not configured correctly! Missing 'password'"
+
+# set IP version dependend dummy (localhost)
+# [ $use_ipv6 -eq 0 ] && __DUMMY="127.0.0.1" || __DUMMY="::1"
+
+# lets do DUMMY transfer
+# write_log 7 "sending dummy IP to 'no-ip.com'"
+# __URL=$(echo $__UPDURL | sed -e "s#\[USERNAME\]#$URL_USER#g" -e "s#\[PASSWORD\]#$URL_PASS#g" \
+# 			       -e "s#\[DOMAIN\]#$domain#g" -e "s#\[IP\]#$__DUMMY#g")
+# [ $use_https -ne 0 ] && __URL=$(echo $__URL | sed -e 's#^http:#https:#')
+
+# do_transfer "$__URL" || return 1
+
+# write_log 7 "'no-ip.com' answered:${N}$(cat $DATFILE)"
+# analyse provider answers
+# "good [IP_ADR]"	= successful
+# "nochg [IP_ADR]"	= no change but OK
+# grep -E "good|nochg" $DATFILE >/dev/null 2>&1 || return 1
+
+# lets wait a seconds
+# sleep 1
+
+# now send the correct data
+write_log 7 "sending real IP to 'no-ip.com'"
+__URL=$(echo $__UPDURL | sed -e "s#\[USERNAME\]#$URL_USER#g" -e "s#\[PASSWORD\]#$URL_PASS#g" \
+			       -e "s#\[DOMAIN\]#$domain#g" -e "s#\[IP\]#$__IP#g")
+[ $use_https -ne 0 ] && __URL=$(echo $__URL | sed -e 's#^http:#https:#')
+
+do_transfer "$__URL" || return 1
+
+write_log 7 "'no-ip.com' answered:${N}$(cat $DATFILE)"
+# analyse provider answers
+# "good [IP_ADR]"	= successful
+# "nochg [IP_ADR]"	= no change but OK
+grep -E "good|nochg" $DATFILE >/dev/null 2>&1
+return $?	# "0" if "good" or "nochg" found
+
diff --recursive --unified --new-file --no-dereference orig/files/update_nsupdate.sh src/files/update_nsupdate.sh
--- orig/files/update_nsupdate.sh	1970-01-01 00:00:00.000000000 +0000
+++ src/files/update_nsupdate.sh	2022-10-07 06:31:35.000000000 +0000
@@ -0,0 +1,48 @@
+#
+#.Distributed under the terms of the GNU General Public License (GPL) version 2.0
+#
+# The script directly updates a PowerDNS (or maybe bind server) via nsupdate from bind-client package.
+#.based on github request #957 by Jan Riechers <de at r-jan dot de>
+#.2015 Christian Schoenebeck <christian dot schoenebeck at gmail dot com>
+#
+# This script is parsed by dynamic_dns_functions.sh inside send_update() function
+#
+# using following options from /etc/config/ddns
+# option username   - keyname 
+# option password   - shared secret (base64 encoded)
+# option domain     - full qualified domain to update
+# option dns_server - DNS server to update
+#
+# variable __IP already defined with the ip-address to use for update
+#
+local __TTL=600		#.preset DNS TTL (in seconds)
+local __RRTYPE __PW __TCP
+local __PROG=$(which nsupdate)			# BIND nsupdate ?
+[ -z "$__PROG" ] && __PROG=$(which knsupdate)	# Knot nsupdate ?
+
+[ -z "$__PROG" ]     && write_log 14 "'nsupdate' or 'knsupdate' not installed !"
+[ -z "$username" ]   && write_log 14 "Service section not configured correctly! Missing 'username'"
+[ -z "$password" ]   && write_log 14 "Service section not configured correctly! Missing 'password'"
+[ -z "$dns_server" ] && write_log 14 "Service section not configured correctly! Missing 'dns_server'"
+
+[ $use_ipv6 -ne 0 ] && __RRTYPE="AAAA" || __RRTYPE="A"
+[ $force_dnstcp -ne 0 ] && __TCP="-v" || __TCP=""
+
+# create command file
+cat >$DATFILE <<-EOF
+server $dns_server
+key $username $password
+update del $domain $__RRTYPE
+update add $domain $__TTL $__RRTYPE $__IP
+show
+send
+answer
+quit
+EOF
+
+$__PROG -d $__TCP $DATFILE >$ERRFILE 2>&1
+
+# nsupdate always return success
+write_log 7 "(k)nsupdate reports:${N}$(cat $ERRFILE)"
+
+return 0
diff --recursive --unified --new-file --no-dereference orig/files/update_route53_v1.sh src/files/update_route53_v1.sh
--- orig/files/update_route53_v1.sh	1970-01-01 00:00:00.000000000 +0000
+++ src/files/update_route53_v1.sh	2022-10-07 06:31:35.000000000 +0000
@@ -0,0 +1,95 @@
+#!/bin/sh
+# Distributed under the terms of the GNU General Public License (GPL) version 2.0
+# based on Yuval Adam's route53.sh found at https://github.com/yuvadm/route53-ddns/blob/master/route53.sh
+# 2017 Max Berger <max at berger dot name>
+
+[ -z "${CURL_SSL}" ] && write_log 14 "Amazon AWS Route53 communication require cURL with SSL support. Please install"
+[ -z "{$username}" ] && write_log 14 "Service section not configured correctly! Missing key as 'username'"
+[ -z "${password}" ] && write_log 14 "Service section not configured correctly! Missing secret as 'password'"
+[ -z "${domain}" ] && write_log 14 "Service section not configured correctly! Missing zone id as 'domain'"
+
+ENDPOINT="route53.amazonaws.com"
+RECORD_TTL=300
+RECORD_NAME="${lookup_host}."
+[ ${use_ipv6} -eq 0 ] && RECORD_TYPE="A"
+[ ${use_ipv6} -eq 1 ] && RECORD_TYPE="AAAA"
+RECORD_VALUE="${LOCAL_IP}"
+HOSTED_ZONE_ID="${domain}"
+API_PATH="/2013-04-01/hostedzone/${HOSTED_ZONE_ID}/rrset/"
+
+AWS_ACCESS_KEY_ID="${username}"
+AWS_SECRET_ACCESS_KEY="${password}"
+AWS_REGION='us-east-1'
+AWS_SERVICE='route53'
+
+hash() {
+    msg="$1"
+    echo -en "${msg}" | openssl dgst -sha256 | sed 's/^.* //'
+}
+
+sign_plain() {
+    # Sign message using a plaintext key
+    key="$1"
+    msg="$2"
+    echo -en "${msg}" | openssl dgst -hex -sha256 -hmac "${key}" | sed 's/^.* //'
+}
+
+sign() {
+    # Sign message using a hex formatted key
+    key="$1"
+    msg="$2"
+    echo -en "${msg}" | openssl dgst -hex -sha256 -mac HMAC -macopt "hexkey:${key}" | sed 's/^.* //'
+}
+
+request_body="<?xml version=\"1.0\" encoding=\"UTF-8\"?> \
+<ChangeResourceRecordSetsRequest xmlns=\"https://route53.amazonaws.com/doc/2013-04-01/\"> \
+<ChangeBatch> \
+   <Changes> \
+      <Change> \
+         <Action>UPSERT</Action> \
+         <ResourceRecordSet> \
+            <Name>${RECORD_NAME}</Name> \
+            <Type>${RECORD_TYPE}</Type> \
+            <TTL>${RECORD_TTL}</TTL> \
+            <ResourceRecords> \
+               <ResourceRecord> \
+                  <Value>${RECORD_VALUE}</Value> \
+               </ResourceRecord> \
+            </ResourceRecords> \
+         </ResourceRecordSet> \
+      </Change> \
+   </Changes> \
+</ChangeBatch> \
+</ChangeResourceRecordSetsRequest>"
+
+fulldate="$(date --utc +%Y%m%dT%H%M%SZ)"
+shortdate="$(date --utc +%Y%m%d)"
+signed_headers="host;x-amz-date"
+request_hash="$(hash "${request_body}")"
+canonical_request="POST\n${API_PATH}\n\nhost:route53.amazonaws.com\nx-amz-date:${fulldate}\n\n${signed_headers}\n${request_hash}"
+
+date_key="$(sign_plain "AWS4${AWS_SECRET_ACCESS_KEY}" "${shortdate}")"
+region_key="$(sign "${date_key}" ${AWS_REGION})"
+service_key="$(sign "${region_key}" ${AWS_SERVICE})"
+signing_key="$(sign "${service_key}" aws4_request)"
+
+credential="${shortdate}/${AWS_REGION}/${AWS_SERVICE}/aws4_request"
+sigmsg="AWS4-HMAC-SHA256\n${fulldate}\n${credential}\n$(hash "${canonical_request}")"
+
+signature="$(sign "${signing_key}" "${sigmsg}")"
+
+authorization="AWS4-HMAC-SHA256 Credential=${AWS_ACCESS_KEY_ID}/${credential}, SignedHeaders=${signed_headers}, Signature=${signature}"
+
+ANSWER="$(curl \
+    -X "POST" \
+    -H "Host: route53.amazonaws.com" \
+    -H "X-Amz-Date: ${fulldate}" \
+    -H "Authorization: ${authorization}" \
+    -H "Content-Type: text/xml" \
+    -d "$request_body" \
+    "https://${ENDPOINT}${API_PATH}")"
+write_log 7 "${ANSWER}"
+
+echo "${ANSWER}" | grep -F "Error" >/dev/null && return 1
+echo "${ANSWER}" | grep -F "ChangeInfo" >/dev/null && return 0
+return 2
diff --recursive --unified --new-file --no-dereference orig/getlocalip_sample.sh src/getlocalip_sample.sh
--- orig/getlocalip_sample.sh	2023-11-08 12:46:25.000000000 +0000
+++ src/getlocalip_sample.sh	1970-01-01 00:00:00.000000000 +0000
@@ -1,35 +0,0 @@
-#!/bin/sh
-#
-# sample script for detecting local IP
-# 2014-2015 Christian Schoenebeck <christian dot schoenebeck at gmail dot com>
-#
-# activated inside /etc/config/ddns by setting
-#
-# option ip_source	'script'
-# option ip_script 	'/usr/lib/ddns/getlocalip_sample.sh -6' !!! parameters ALLOWED
-#
-# the script is executed (not parsed) inside get_local_ip() function
-# of /usr/lib/ddns/dynamic_dns_functions.sh
-#
-# useful when this box is the only DDNS client in the network
-# IP adresses of "internal" boxes could be detected with this script
-# so no need to install ddns client on every "internal" box
-# On IPv6 every internal box normally has it's own external IP
-#
-# This script should
-# 	- return the IP address via stdout	echo -n "...."	!!! without line feed
-#	- report errors via stderr		echo "...." >&2
-#	- return an error code ('0' for success)	exit 123
-
-case $1 in
-	-4)	echo -n "8.8.8.8"		# never append linefeed or simular
-		exit 0
-		;;				# IP's of Googles public DNS
-	-6)	echo -n "2001:4860:4860::8888"
-		exit 0
-		;;
-	*)	echo "$0 - Invalid or missing parameter" >&2
-		exit 1
-esac
-echo "Should never come here" >&2
-exit 2
diff --recursive --unified --new-file --no-dereference orig/samples/ddns.config_sample src/samples/ddns.config_sample
--- orig/samples/ddns.config_sample	1970-01-01 00:00:00.000000000 +0000
+++ src/samples/ddns.config_sample	2022-10-07 06:31:35.000000000 +0000
@@ -0,0 +1,314 @@
+#
+#
+# Here you find a description on every parameter supported
+# and used by ddns-scripts and corresponding LuCI application
+#
+# Inside your ddns configuration file (/etc/config/ddns)
+# you might not find some of below described options.
+# This is because you don't need to define options
+# if using there defaults. The LuCI application will delete
+# options that configured to there default values.
+#
+# If you have a working ddns configuration from old ddns-scripts (Version 1.x)
+# everything will function the same with new scripts
+# without any changes to the configuration.
+#
+# If you like to use this file for your configuration then
+# use a copy, because the used software to modify the
+# configuration files will throw away all empty lines
+# and those starting with # (comments).
+#
+
+#####################################################################
+# Global application settings
+#
+config ddns "global"
+
+	###########
+	# set date format to use for display date in logfiles
+	# and LuCI web application.
+	# For codes see man pages of date command.
+	# default: "%F %R" (ISO 8601 format)
+#	option ddns_dateformat "%F %R"
+
+	###########
+	# set run directory to use for .pid and .update files
+	# there will be a separate file for every running service section
+	# default: "/var/run/ddns"
+#	option ddns_rundir "/var/run/ddns"
+
+	###########
+	# set log directory to use for .log files
+	# there will be a separate file for every running service section
+	# default: "/var/log/ddns"
+#	option ddns_logdir "/var/log/ddns"
+
+	###########
+	# set number of lines stored in .log file before auto truncated
+	# default: "250" lines
+#	option ddns_loglines "250"
+
+	###########
+	# Whether to allow to send Private/Special IP's to the DDNS provider
+	# IPv4: 0.x, 10.x, 127.x, 172.16.x-172.31.x, 192.168.x
+	# IPv6: ::, Fxxx:
+	# default: "0"	disabled
+#	option upd_privateip "0"
+
+#####################################################################
+# DDNS service settings
+#
+# for each service you want to serve you need a separate configuration
+# if you need IPv4 and IPv6 you need to setup 2 separate configurations
+# with different names. (i.e. "myddns_ipv4" and "myddns_ipv6")
+# do not use white-spaces or dashes "-" or "@" ":" "!" or
+# other special characters inside name.
+config service "myddns"
+
+	########### Basic settings ########################
+
+	###########
+	# enable/disable this service section
+	# default: "0"	disabled
+	option enabled "0"
+
+	###########
+	# detecting/sending IPv4 or IPv6 address to the DDNS provider
+	# set to "1" if you want to use IPv6
+	# default: "0"	use IPv4
+	option use_ipv6 "0"
+
+	###########
+	# defines the network as defined in /etc/config/network
+	# to be monitored for up/down events to start via hotplug
+	default: "wan"	for IPv4
+	default: "wan6"	for IPv6
+	option interface "wan"
+
+	###########
+	# Next you need to specify the name of the service you are
+	# connecting to "eg. dyndns.org".  The format of the update
+	# urls for several different dynamic dns services is specified
+	# in the "/usr/lib/ddns/services" file for IPv4 and in
+	# "/usr/lib/ddns/service_ipv6" file. This list is hardly complete
+	# as there are many, many different dynamic dns services.
+	# If your service is on the list you can merely specify it with the
+	# "service_name" option.  Otherwise you will need to determine
+	# the format of the url to update with.  You can either add an
+	# entry to the "/usr/lib/ddns/services" or "services_ipv6" file
+	# or specify this with the "update_url" option.
+	# If your ddns provider doesn't work with ddns-scripts because
+	# there are additional parameters or other special thinks to be done,
+	# then you could write your own script to send updates to your ddns provider.
+	# Have a look into /usr/lib/ddns/update_sample.sh
+	# The script is specified in "update_script"
+	# Either set "service_name" or one of "update_url" and "update_script"
+	# default: none
+	option service_name "dyndns.org"
+
+	# sample:
+	# "http://[USERNAME]:[PASSWORD]@members.dyndns.org/nic/update?hostname=[DOMAIN]&myip=[IP]"
+#	option update_url   ""
+
+	# sample:
+	# "/usr/lib/ddns/update_sample.sh"
+#	option update_script   ""
+
+	###########
+	# Keep an eye on providers help pages.
+	#
+	# FQDN of ONE of your defined host at DDNS provider
+	# REQUIRED to verify what the current IP at DNS using nslookup/host command
+	# default: none
+	option lookup_host ""
+
+	# Your DNS name / replace [DOMAIN] in update_url
+	# default: none
+	option domain ""
+
+	# Username of your DDNS service account / replace [USERNAME] in update_url
+	# default: none
+	option username ""
+
+	# Password of your DDNS service account / replace [PASSWORD] in update url
+	# default: none
+	option password ""
+
+	###########
+	# Optional parameters for use inside update_url
+	#
+	# parameter that will be urlencoded before replacement of [PARAMENC] inside update url
+	# default: none
+	option param_enc ""
+
+	# parameter that repace [PARAMOPT] inside update url
+	# default: none
+	option param_opt ""
+
+	###########
+	# use HTTPS for secure communication with you DDNS provider
+	# personally found some providers having problems when not sending
+	# updates via HTTPS. You must not specify "https://" in update_url.
+	# It's modified by the scripts themselves
+	# Needs GNU Wget (with SSL support) or cURL to be installed.
+	# default: "0"	do not use HTTPS
+	option use_https "0"
+
+	# if using HTTPS (see above) the transfer program tries to verify
+	# the providers server certificate. For verification there needs to be
+	# the counterpart on this machine. Specify the path or path/file where
+	# the transfer program can find them. (might need package CA-certificates)
+	# if you don't want to verify servers certificate (insecure) you should
+	# this parameter to "IGNORE" (in capital letters)
+	# default: (none)	path where CA-certificate package is installed
+	option cacert "/etc/ssl/certs"
+
+	###########
+	# for logging and control if everything work fine you can get information inside
+	# system log . Critical Errors are always send to system log.
+	# You can define which information you like to log
+	# 1 == info, notice, warning, errors
+	# 2 == notice, warning, errors
+	# 3 == warning, errors
+	# 4 == errors
+	# default: "0" off
+	option use_syslog  "0"
+
+	###########
+	# for logging and control if everything work fine you can get information inside
+	# log file. You find the file per default in /var/log/ddns/[sectionname].log
+	# The path can be modified for all log files in ddns.global section (see above)
+	# default: "1" on
+	option use_logfile "1"
+
+	########### Advanced settings #####################
+
+	###########
+	# you need to specify how ddns-scripts should detect you current local ip.
+	# the ip_source could be set to "network", "web", "interface" or "script"
+	# the parameters below specifying the additional information needed for
+	# the corresponding ip_spource configuration
+	# default: "network"
+
+	# ip_source "network" additional uses option ip_network and detects the
+	# current local ip on network as defined in /etc/config/network
+	# default: "wan"  using IPv4
+	# default: "wan6" using IPv6
+	option ip_source  "network"
+	option ip_network "wan"
+
+	# ip_source "web" additional uses option ip_url and detects the current
+	# local ip from special web sides that response with the ip address of
+	# calling host. If you are behind a firewall/NAT this is the best option
+	# since none of the local networks or interfaces will have the external ip.
+	# default: "http://checkip.dyndns.com"   using IPv4
+	# default: "http://checkipv6.dyndns.com" using IPv6
+#	option ip_source "web"
+#	option ip_url    "http://checkip.dyndns.com"
+
+	# ip_source "interface" additional uses option ip_interface
+	# ip_source "interface" uses one of the locally installed physical interfaces
+	# to detect independent from network they configured to.
+	# default: none
+#	option ip_source    "interface"
+#	option ip_interface "eth1"
+
+	# ip_source "script" additional uses option ip_script
+	# it's useful if you want to write your own script to detect the
+	# current local ip. put full path into ip_script option.
+	# The script must be executable.
+	# default: none
+#	option ip_source "script"
+#	option ip_script ""
+
+	###########
+	# force_ipversion option will set the "-4" respectively "-6" parameter
+	# on command line of transfer and DNS lookup program.
+	# So the whole communication uses the selected IP version between both ends.
+	# needs GNU Wget or cURL installed for transfer and
+	# BIND's host for DNS lookup.
+	# default: "0" disabled
+	option force_ipversion "0"
+
+	###########
+	# Normally the current (in the internet) registered ip is detected using the
+	# local defined name lookup policies (i.e. /etc/resolve.conf etc.)
+	# Specify here a DNS server to use instead of the defaults.
+	# you can use hostname or ip address
+	# i.e. "google-public-dns-a.google.com"
+	# default: none
+#	option dns_server "google-public-dns-a.google.com"
+
+	# By default every DNS call is made via UDP protocol
+	# Some internet provider offer modems that cache UDP DNS requests.
+	# They also redirect calls to external servers to local.
+	# To force the usage of TCP for DNS requests enable this option
+	# Needs BIND's host program be installed
+	# default: "0" disabled
+#	option force_dnstcp "0"
+
+	###########
+	# If a Proxy is need to access HTTP/HTTPS pages on the WEB
+	# it can be configured here also for sending updates to the
+	# DDNS provider. If you configured use_https='1' above, you
+	# need to setup your HTTPS proxy here, otherwise your
+	# HTTP proxy. !!! You should not detect your current IP
+	# ip_source='web' (see above) because this request is also
+	# send via the configured proxy !!!
+	# Syntax: [user:password@]proxy:port !port is required !
+	# IPv6 address must be in squared brackets "[...]"
+	# default: none
+#	option proxy ''
+
+	###########
+	# In some very special configurations i.e. Multi WAN environment
+	# in a NAT cascade it might be necessary to define
+	# a network to use for communication.
+	# should use option ip_source "web" (see above)
+	# Needs GNU Wget (with SSL support) or cURL to be installed.
+	# GNU Wget will use IP address and cURL the physical device 
+	# of the given network
+	# default: none
+#	option bind_network "wan7"
+
+	########### Timer settings ########################
+
+	###########
+	# defines the time interval to check if local IP has changed
+	# After the first start and first update send, the system will
+	# wait this time before verify if update was successful send.
+	# !!! checks below 5 minutes make no sense because the Internet
+	# needs about 5-10 minutes to sync an IP-change to all DNS servers !!!
+	# accepted unit entry’s: 'seconds' 'minutes' 'hours'
+	# minimum 5 minutes == 300 seconds
+	# default 10 minutes
+	option check_interval	'10'
+	option check_unit	'minutes'
+
+	###########
+	# force to send an update to service provider, if no change was detected.
+	# consult DDNS providers documentation if your DDNS entry might timeout.
+	# accepted unit entry’s: 'minutes' 'hours' 'days'
+	# minimum needs to be greater or equal check interval (see above)
+	# A special setting of '0' is allowed, which forces the script to run once.
+	# It sends an update, verify if update was accepted by DNS
+	# (retry if not) and finish. Useful if you want to start by your own (i.e. cron)
+	# default 3 days == 72 hours
+	option force_interval	'72'
+	option force_unit	'hours'
+
+	###########
+	# if error happen on detecting, sending or updating the
+	# script will retry the relevant action for retry_count times
+	# before stopping script execution.
+	# default: 5
+	option retry_count '5'
+
+	###########
+	# if error happen on detecting, sending or updating the
+	# script will retry the relevant action.
+	# here you define the time to wait before retry is started
+	# accepted unit entry’s: 'seconds' 'minutes'
+	# default: 60 seconds
+	option retry_interval	'60'
+	option retry_unit	'seconds'
diff --recursive --unified --new-file --no-dereference orig/samples/getlocalip_sample.sh src/samples/getlocalip_sample.sh
--- orig/samples/getlocalip_sample.sh	1970-01-01 00:00:00.000000000 +0000
+++ src/samples/getlocalip_sample.sh	2022-10-07 06:31:35.000000000 +0000
@@ -0,0 +1,35 @@
+#!/bin/sh
+#
+# sample script for detecting local IP
+# 2014-2015 Christian Schoenebeck <christian dot schoenebeck at gmail dot com>
+#
+# activated inside /etc/config/ddns by setting
+#
+# option ip_source	'script'
+# option ip_script 	'/usr/lib/ddns/getlocalip_sample.sh -6' !!! parameters ALLOWED
+#
+# the script is executed (not parsed) inside get_local_ip() function
+# of /usr/lib/ddns/dynamic_dns_functions.sh
+#
+# useful when this box is the only DDNS client in the network
+# IP adresses of "internal" boxes could be detected with this script
+# so no need to install ddns client on every "internal" box
+# On IPv6 every internal box normally has it's own external IP
+#
+# This script should
+# 	- return the IP address via stdout	echo -n "...."	!!! without line feed
+#	- report errors via stderr		echo "...." >&2
+#	- return an error code ('0' for success)	exit 123
+
+case $1 in
+	-4)	echo -n "8.8.8.8"		# never append linefeed or simular
+		exit 0
+		;;				# IP's of Googles public DNS
+	-6)	echo -n "2001:4860:4860::8888"
+		exit 0
+		;;
+	*)	echo "$0 - Invalid or missing parameter" >&2
+		exit 1
+esac
+echo "Should never come here" >&2
+exit 2
diff --recursive --unified --new-file --no-dereference orig/samples/update_sample.sh src/samples/update_sample.sh
--- orig/samples/update_sample.sh	1970-01-01 00:00:00.000000000 +0000
+++ src/samples/update_sample.sh	2022-10-07 06:31:35.000000000 +0000
@@ -0,0 +1,41 @@
+# sample script for sending user defined updates
+# 2014-2015 Christian Schoenebeck <christian dot schoenebeck at gmail dot com>
+#
+# activated inside /etc/config/ddns by setting
+#
+# option update_script '/usr/lib/ddns/update_sample.sh'
+#
+# the script is parsed (not executed) inside send_update() function
+# of /usr/lib/ddns/dynamic_dns_functions.sh
+# so you can use all available functions and global variables inside this script
+# already defined in dynamic_dns_updater.sh and dynamic_dns_functions.sh
+#
+# It make sence to define the update url ONLY inside this script
+# because it's anyway unique to the update script
+# otherwise it should work with the default scripts
+#
+# the code here is the copy of the default used inside send_update()
+#
+# tested with spdns.de
+local __URL="http://[USERNAME]:[PASSWORD]@update.spdns.de/nic/update?hostname=[DOMAIN]&myip=[IP]"
+# inside url we need domain, username and password
+[ -z "$domain" ]   && write_log 14 "Service section not configured correctly! Missing 'domain'"
+[ -z "$username" ] && write_log 14 "Service section not configured correctly! Missing 'username'"
+[ -z "$password" ] && write_log 14 "Service section not configured correctly! Missing 'password'"
+
+# do replaces in URL
+__URL=$(echo $__URL |  | sed -e "s#\[USERNAME\]#$URL_USER#g" -e "s#\[PASSWORD\]#$URL_PASS#g" \
+			     -e "s#\[PARAMENC\]#$URL_PENC#g" -e "s#\[PARAMOPT\]#$param_opt#g" \
+			     -e "s#\[DOMAIN\]#$domain#g"     -e "s#\[IP\]#$__IP#g")
+[ $use_https -ne 0 ] && __URL=$(echo $__URL | sed -e 's#^http:#https:#')
+
+do_transfer "$__URL" || return 1
+
+write_log 7 "DDNS Provider answered:\n$(cat $DATFILE)"
+
+# analyse provider answers
+# "good [IP_ADR]"	= successful
+# "nochg [IP_ADR]"	= no change but OK
+grep -i -E "good|nochg" $DATFILE >/dev/null 2>&1
+return $?	# "0" if "good" or "nochg" found
+
diff --recursive --unified --new-file --no-dereference orig/services src/services
--- orig/services	2023-11-08 12:46:52.000000000 +0000
+++ src/services	1970-01-01 00:00:00.000000000 +0000
@@ -1,180 +0,0 @@
-# 44444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444
-#
-# This file contains the update urls for various dynamic dns services.
-# Column one contains the service name, column two contains the update url.
-# within the update url there are 4 variables you can use: [USERNAME],
-# [PASSWORD], [DOMAIN] and [IP].  These are substituted for the username,
-# password, and domain name specified in the /etc/config/ddns file when an
-# update is performed.  The IP is substituted for the current ip address of the
-# router.  These variables are case sensitive, while urls generally are not, so
-# if you need to enter the same text in the url (which seems very unlikely) put
-# that text in lowercase, while the variables should remain in uppercase
-#
-# There are TONS of dynamic dns services out there. There's a huge list of them at:
-# http://www.dmoz.org/Computers/Software/Internet/Servers/Address_Management/Dynamic_DNS_Services/
-# If anyone has time they could update this file to be compatible with a bunch of them
-#
-# !!! Since ddns-scripts Version 2.x the update of IPv6 addresses is also supported
-# !!! This file is used for update of IPv4 adresses only. For IPv6 use services_ipv6
-#
-# !!! Since ddns-scripts Version 2.x the update via provider specific update scripts is supported.
-# !!! This scripts must be located at /usr/lib/ddns directory if defined inside this file.
-# !!! Use only the script name (without path). Sample:
-# !!! "example.com"	"update_sample.sh"
-#
-# !!! Since ddns-scripts Version 2.5.x additional parameters are supported
-# !!! and a given answer on success is checked (ignored by earlier versions)
-# !!! Additional parameters: [PARAMOPT] and [PARAMENC]; [PARAMENC] is send urlencoded
-#
-# Line syntax: "service" [TAB] "update_url" [TAB] "answer"
-# "service"	name used as "option service_name" inside /etc/config/ddns
-# "update_url"	update url as given by the provider; custom urls should not saved here
-# "answer"	single words inside providers answer string; use "|" to combine "or"
-#
-# 44444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444
-#
-#.cloudflare.com-v4	!!! Please install additional package "ddns-scripts_cloudflare.com-v4"
-#.FreeDNS.42.pl 	!!! Please install additional package "ddns-scripts_freedns_42_pl"
-#.godaddy.com-v1	!!! Please install additional package "ddns-scripts_godaddy.com-v1"
-#.no-ip.com / noip.com	!!! Please install additional package "ddns-scripts_no-ip_com"
-#.route53-v1		!!! Please install additional package "ddns-scripts_route53-v1"
-
-"3322.org"		"http://[USERNAME]:[PASSWORD]@members.3322.org/dyndns/update?system=dyndns&hostname=[DOMAIN]&myip=[IP]"
-
-"able.or.kr"		"http://able.or.kr/ddns/src/update.php?hostname=[DOMAIN]&myip=[IP]&ddnsuser=[USERNAME]&pwd=[PASSWORD]"
-
-"afraid.org-basicauth"	"https://[USERNAME]:[PASSWORD]@freedns.afraid.org/nic/update?hostname=[DOMAIN]&myip=[IP]"
-"afraid.org-keyauth"	"https://freedns.afraid.org/dynamic/update.php?[PASSWORD]&address=[IP]"
-"afraid.org-v2-basic"	"https://[USERNAME]:[PASSWORD]@sync.afraid.org/u/?h=[DOMAIN]&ip=[IP]"
-"afraid.org-v2-token"	"https://sync.afraid.org/u/[PASSWORD]/?address=[IP]"
-
-"all-inkl.com"		"http://[USERNAME]:[PASSWORD]@dyndns.kasserver.com/?myip=[IP]"
-
-"changeip.com"		"http://[USERNAME]:[PASSWORD]@nic.changeip.com/nic/update?u=[USERNAME]&p=[PASSWORD]&cmd=update&hostname=[DOMAIN]&ip=[IP]"	"Successful"
-
-"core-networks.de"	"http://[USERNAME]:[PASSWORD]@dyndns.core-networks.de/?hostname=[DOMAIN]&myip=[IP]&keepipv6=1"	"good"
-
-"ddns.com.br"		"http://[DOMAIN]:[PASSWORD]@members.ddns.com.br/nic/update?hostname=[DOMAIN]&myip=[IP]"
-
-# "ddnss.de"		"http://[USERNAME]:[PASSWORD]@ip4.ddnss.de/upd.php?host=[DOMAIN]&ip=[IP]"	"good|nochg"
-"ddnss.de"		"http://ip4.ddnss.de/upd.php?user=[USERNAME]&pwd=[PASSWORD]&host=[DOMAIN]&ip=[IP]"	"good|nochg"
-
-"ddo.jp"		"http://free.ddo.jp/dnsupdate.php?dn=[DOMAIN]&pw=[PASSWORD]&ip=[IP]"
-
-"desec.io"		"http://update.dedyn.io/?username=[USERNAME]&password=[PASSWORD]&hostname=[DOMAIN]&myipv4=[IP]"	"good|nochg"
-
-"dhis.org"		"http://[USERNAME]:[PASSWORD]@is.dhis.org/"
-
-"dnsdynamic.org"	"http://[USERNAME]:[PASSWORD]@www.dnsdynamic.org/api/?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
-
-"dnsever.com"		"http://[USERNAME]:[PASSWORD]@dyna.dnsever.com/update.php?host[[DOMAIN]]"
-
-"dnsexit.com"		"http://update.dnsexit.com/RemoteUpdate.sv?login=[USERNAME]&password=[PASSWORD]&host=[DOMAIN]&myip=[IP]"
-
-"dnshome.de"		"http://[USERNAME]:[PASSWORD]@www.dnshome.de/dyndns.php?hostname=[DOMAIN]&ip=[IP]"
-
-"dnsmadeeasy.com"	"http://cp.dnsmadeeasy.com/servlet/updateip?username=[USERNAME]&password=[PASSWORD]&id=[DOMAIN]&ip=[IP]"	"success|ip-same"
-
-"dnsmax.com"		"http://update.dnsmax.com/update/?username=[USERNAME]&password=[PASSWORD]&resellerid=1&clientname=openwrt&clientversion=8.09&protocolversion=2.0&updatehostname=[DOMAIN]&ip=[IP]"
-
-"dnsomatic.com"		"http://[USERNAME]:[PASSWORD]@updates.dnsomatic.com/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
-
-"dnspark.com"		"http://[USERNAME]:[PASSWORD]@control.dnspark.com/api/dynamic/update.php?hostname=[DOMAIN]&ip=[IP]"	"ok|nochange"
-
-"do.de"			"http://ddns.do.de/?myip=[IP]&hostname=[DOMAIN]&username=[USERNAME]&password=[PASSWORD]"	"good|nochg"
-
-"domopoli.de"		"http://[USERNAME]:[PASSWORD]@http://dyndns.domopoli.de/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
-
-"dtdns.com"		"http://www.dtdns.com/api/autodns.cfm?id=[DOMAIN]&pw=[PASSWORD]&ip=[IP]"
-
-"duckdns.org"		"http://www.duckdns.org/update?domains=[DOMAIN]&token=[PASSWORD]&ip=[IP]"	"OK"
-
-"duiadns.net"		"http://ip.duiadns.net/dynamic.duia?host=[DOMAIN]&password=[PASSWORD]&ip4=[IP]"
-
-"dy.fi"			"http://[USERNAME]:[PASSWORD]@www.dy.fi/nic/update?hostname=[DOMAIN]"	"good|nochg"
-
-"dyndns.it"		"http://[USERNAME]:[PASSWORD]@update.dyndns.it/nic/update?system=dyndns&hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
-
-"dyn.com"		"http://[USERNAME]:[PASSWORD]@members.dyndns.org/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
-"dyndns.org"		"http://[USERNAME]:[PASSWORD]@members.dyndns.org/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
-
-"dyndnss.net"		"http://www.dyndnss.net/?user=[USERNAME]&pass=[PASSWORD]&domain=[DOMAIN]&updater=other"
-
-"dynsip.org"		"http://[USERNAME]:[PASSWORD]@dynsip.org/nic/update?hostname=[DOMAIN]&myip=[IP]"
-
-"dyns.net"		"http://www.dyns.net/postscript011.php?username=[USERNAME]&password=[PASSWORD]&host=[DOMAIN]&ip=[IP]"	"200"
-
-"dynu.com"		"http://api.dynu.com/nic/update?hostname=[DOMAIN]&myip=[IP]&username=[USERNAME]&password=[PASSWORD]"
-
-"dynv6.com"		"http://dynv6.com/api/update?hostname=[DOMAIN]&token=[PASSWORD]&ipv4=[IP]"	"updated|unchanged"
-
-"easydns.com"		"http://[USERNAME]:[PASSWORD]@api.cp.easydns.com/dyn/generic.php?hostname=[DOMAIN]&myip=[IP]"	"OK|NOERROR"
-
-"editdns.net"		"http://dyndns-free.editdns.net/api/dynLinux.php?p=[PASSWORD]&r=[DOMAIN]"
-
-"goip.de"		"http://www.goip.de/setip?username=[USERNAME]&password=[PASSWORD]&subdomain=[DOMAIN]&ip=[IP]"
-
-"google.com"		"http://[USERNAME]:[PASSWORD]@domains.google.com/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
-
-"he.net"		"http://[DOMAIN]:[PASSWORD]@dyn.dns.he.net/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
-
-"joker.com"		"http://svc.joker.com/nic/update?username=[USERNAME]&password=[PASSWORD]&myip=[IP]&hostname=[DOMAIN]"	"good|nochg"
-
-"loopia.se"		"http://[USERNAME]:[PASSWORD]@dns.loopia.se/XDynDNSServer/XDynDNS.php?system=custom&hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
-
-"mydns.jp"		"http://www.mydns.jp/directip.html?MID=[USERNAME]&PWD=[PASSWORD]&IPV4ADDR=[IP]"
-
-"myip.co.ua"		"http://[USERNAME]:[PASSWORD]@myip.co.ua/update?hostname=[DOMAIN]&myip=[IP]"	"good"
-
-"myonlineportal.net"	"http://[USERNAME]:[PASSWORD]@myonlineportal.net/updateddns?hostname=[DOMAIN]&ip=[IP]"	"good|nochg"
-
-"mythic-beasts.com"	"http://dnsapi4.mythic-beasts.com/?domain=[USERNAME]&password=[PASSWORD]&command=REPLACE%20[DOMAIN]%2060%20A%20DYNAMIC_IP&origin=."
-
-"namecheap.com"		"http://dynamicdns.park-your-domain.com/update?host=[USERNAME]&domain=[DOMAIN]&password=[PASSWORD]&ip=[IP]"
-
-"nettica.com"		"http://www.nettica.com/Domain/Update.aspx?U=[USERNAME]&PC=[PASSWORD]&FQDN=[DOMAIN]&N=[IP]"
-
-"no-ip.pl"		"http://[USERNAME]:[PASSWORD]@update.no-ip.pl/?hostname=[DOMAIN]"
-
-"now-dns.com"		"https://[USERNAME]:[PASSWORD]@now-dns.com/update?hostname=[DOMAIN]"	"good|nochg"
-
-"nsupdate.info"		"http://[USERNAME]:[PASSWORD]@ipv4.nsupdate.info/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
-
-"nubem.com"		"http://[USERNAME]:[PASSWORD]@nubem.com/nic/update?hostname=[DOMAIN]&myip=[IP]"
-
-"opendns.com"		"http://[USERNAME]:[PASSWORD]@updates.opendns.com/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
-
-"oray.com"		"http://[USERNAME]:[PASSWORD]@ddns.oray.com/ph/update?hostname=[DOMAIN]&myip=[IP]"
-
-"ovh.com"		"http://[USERNAME]:[PASSWORD]@www.ovh.com/nic/update?system=dyndns&hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
-
-"regfish.de"		"http://dyndns.regfish.de/?fqdn=[DOMAIN]&forcehost=1&authtype=secure&token=[PASSWORD]&ipv4=[IP]"	"success|100|101"
-
-"schokokeks.org"	"http://[USERNAME]:[PASSWORD]@dyndns.schokokeks.org/nic/update?myip=[IP]"	"good|nochg"
-
-"selfhost.de"		"http://carol.selfhost.de/update?username=[USERNAME]&password=[PASSWORD]&myip=[IP]&hostname=1"	"good|nochg|200|204"
-
-"sitelutions.com"	"http://www.sitelutions.com/dnsup?user=[USERNAME]&pass=[PASSWORD]&id=[DOMAIN]&ip=[IP]"	"success"
-
-"spdyn.de"		"http://[USERNAME]:[PASSWORD]@update.spdyn.de/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
-
-"strato.com"		"http://[USERNAME]:[PASSWORD]@dyndns.strato.com/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
-
-"system-ns.com"		"http://system-ns.com/api?type=dynamic&command=set&domain=[DOMAIN]&token=[PASSWORD]&ip=[IP]"	"0"
-
-"thatip.com"		"http://update.dnsmax.com/update/?username=[USERNAME]&password=[PASSWORD]&resellerid=2&clientname=openwrt&clientversion=8.09&protocolversion=2.0&updatehostname=[DOMAIN]&ip=[IP]"
-
-"twodns.de"		"http://[USERNAME]:[PASSWORD]@update.twodns.de/update?hostname=[DOMAIN]&ip=[IP]"
-
-"udmedia.de"		"http://[USERNAME]:[PASSWORD]@www.udmedia.de/nic/update?myip=[IP]"
-
-"variomedia.de" 	"http://[USERNAME]:[PASSWORD]@dyndns.variomedia.de/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
-
-"xlhost.de"		"http://[USERNAME]:[PASSWORD]@nsupdate.xlhost.de/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
-
-"zerigo.com"		"http://update.zerigo.com/dynamic?user=[USERNAME]&password=[PASSWORD]&host=[DOMAIN]&ip=[IP]"	"ok"
-
-"zoneedit.com"		"http://[USERNAME]:[PASSWORD]@dynamic.zoneedit.com/auth/dynamic.html?host=[DOMAIN]&dnsto=[IP]"
-
-"zzzz.io"		"http://zzzz.io/api/v1/update/[DOMAIN]/?token=[PASSWORD]&ip=[IP]"	"Updated|No change"
-
diff --recursive --unified --new-file --no-dereference orig/services_ipv6 src/services_ipv6
--- orig/services_ipv6	2023-11-08 12:46:52.000000000 +0000
+++ src/services_ipv6	1970-01-01 00:00:00.000000000 +0000
@@ -1,103 +0,0 @@
-# 66666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666
-#
-# This file contains the update urls for various dynamic dns services.
-# Column one contains the service name, column two contains the update url.
-# within the update url there are 4 variables you can use: [USERNAME],
-# [PASSWORD], [DOMAIN] and [IP].  These are substituted for the username,
-# password, and domain name specified in the /etc/config/ddns file when an
-# update is performed.  The IP is substituted for the current ip address of the
-# router.  These variables are case sensitive, while urls generally are not, so
-# if you need to enter the same text in the url (which seems very unlikely) put
-# that text in lowercase, while the variables should remain in uppercase
-#
-# There are TONS of dynamic dns services out there. There's a huge list of them at:
-# http://www.dmoz.org/Computers/Software/Internet/Servers/Address_Management/Dynamic_DNS_Services/
-# If anyone has time they could update this file to be compatible with a bunch of them
-#
-# !!! Since ddns-scripts Version 2.x the update of IPv6 addresses is also supported
-# !!! This file is used for update of IPv6 adresses only. For IPv4 use services
-#
-# !!! Since ddns-scripts Version 2.x the update via provider specific update scripts is supported.
-# !!! This scripts must be located at /usr/lib/ddns directory if defined inside this file.
-# !!! Use only the script name (without path). Sample:
-# !!! "example.com"	"update_sample.sh"
-#
-# !!! Since ddns-scripts Version 2.5.x additional parameters are supported
-# !!! and a given answer on success is checked (ignored by earlier versions)
-# !!! Additional parameters: [PARAMOPT] and [PARAMENC]; [PARAMENC] is send urlencoded
-#
-# Line syntax: "service" [TAB] "update_url" [TAB] "answer"
-# "service"	name used as "option service_name" inside /etc/config/ddns
-# "update_url"	update url as given by the provider; custom urls should not saved here
-# "answer"	words inside providers answer string; use "|" to combine "or"
-#
-# 66666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666
-#
-#.cloudflare.com-v4	!!! Please install additional package "ddns-scripts_cloudflare.com-v4"
-#.godaddy.com-v1	!!! Please install additional package "ddns-scripts_godaddy.com-v1"
-#.no-ip.com / noip.com	!!! Please install additional package "ddns-scripts_no-ip_com"
-#.route53-v1		!!! Please install additional package "ddns-scripts_route53-v1"
-
-"afraid.org-basicauth"	"https://[USERNAME]:[PASSWORD]@freedns.afraid.org/nic/update?hostname=[DOMAIN]&myip=[IP]"
-"afraid.org-keyauth"	"https://freedns.afraid.org/dynamic/update.php?[PASSWORD]&address=[IP]"
-"afraid.org-v2-basic"	"https://[USERNAME]:[PASSWORD]@v6.sync.afraid.org/u/?h=[DOMAIN]&ip=[IP]"
-"afraid.org-v2-token"	"https://v6.sync.afraid.org/u/[PASSWORD]/?address=[IP]"
-
-"all-inkl.com"		"http://[USERNAME]:[PASSWORD]@dyndns.kasserver.com/?myip=[IP]"
-
-"core-networks.de"	"http://[USERNAME]:[PASSWORD]@dyndns.core-networks.de/?hostname=[DOMAIN]&myip=[IP]&keepipv4=1"	"good"
-
-# "ddnss.de"		"http://[USERNAME]:[PASSWORD]@ip6.ddnss.de/upd.php?host=[DOMAIN]&ip6=[IP]"	"good|nochg"
-"ddnss.de"		"http://ip6.ddnss.de/upd.php?user=[USERNAME]&pwd=[PASSWORD]&host=[DOMAIN]&ip6=[IP]"	"good|nochg"
-
-"desec.io"		"http://update.dedyn.io/?username=[USERNAME]&password=[PASSWORD]&hostname=[DOMAIN]&myipv6=[IP]"	"good|nochg"
-
-"dhis.org"		"http://[USERNAME]:[PASSWORD]@is.dhis.org/"
-
-"dnshome.de"		"http://[USERNAME]:[PASSWORD]@www.dnshome.de/dyndns.php?hostname=[DOMAIN]&ip6=[IP]"
-
-"do.de"			"http://ddns.do.de/?myip=[IP]&hostname=[DOMAIN]&username=[USERNAME]&password=[PASSWORD]"	"good|nochg"
-
-"duckdns.org"		"http://www.duckdns.org/update?domains=[DOMAIN]&token=[PASSWORD]&ipv6=[IP]"	"OK"
-
-"duiadns.net"		"http://ip.duiadns.net/dynamic.duia?host=[DOMAIN]&password=[PASSWORD]&ip6=[IP]"
-
-"dyn.com"		"http://[USERNAME]:[PASSWORD]@members.dyndns.org/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
-"dyndns.org"		"http://[USERNAME]:[PASSWORD]@members.dyndns.org/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
-
-"dynu.com"    		"http://api.dynu.com/nic/update?hostname=[DOMAIN]&myipv6=[IP]&username=[USERNAME]&password=[PASSWORD]"
-
-"dynv6.com"		"http://dynv6.com/api/update?hostname=[DOMAIN]&token=[PASSWORD]&ipv6=[IP]"	"updated|unchanged"
-
-"goip.de"		"http://www.goip.de/setip?username=[USERNAME]&password=[PASSWORD]&subdomain=[DOMAIN]&ip6=[IP]"
-
-"google.com"		"http://[USERNAME]:[PASSWORD]@domains.google.com/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
-
-"he.net"		"http://[DOMAIN]:[PASSWORD]@dyn.dns.he.net/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
-
-"loopia.se"		"http://[USERNAME]:[PASSWORD]@dns.loopia.se/XDynDNSServer/XDynDNS.php?system=custom&hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
-
-"mydns.jp"		"http://www.mydns.jp/directip.html?MID=[USERNAME]&PWD=[PASSWORD]&IPV6ADDR=[IP]"
-
-"myonlineportal.net"	"http://[USERNAME]:[PASSWORD]@myonlineportal.net/updateddns?hostname=[DOMAIN]&ip6=[IP]"	"good|nochg"
-
-"mythic-beasts.com"	"http://dnsapi6.mythic-beasts.com/?domain=[USERNAME]&password=[PASSWORD]&command=REPLACE%20[DOMAIN]%2060%20AAAA%20DYNAMIC_IP&origin=."
-
-"no-ip.pl"		"http://[USERNAME]:[PASSWORD]@update.no-ip.pl/?hostname=[DOMAIN]"
-
-"now-dns.com"		"https://[USERNAME]:[PASSWORD]@now-dns.com/update?hostname=[DOMAIN]"	"good|nochg"
-
-"nsupdate.info"		"http://[USERNAME]:[PASSWORD]@ipv6.nsupdate.info/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
-
-"regfish.de"		"http://dyndns.regfish.de/?fqdn=[DOMAIN]&forcehost=1&authtype=secure&token=[PASSWORD]&ipv6=[IP]"	"success|100|101"
-
-"spdyn.de"		"http://[USERNAME]:[PASSWORD]@update.spdyn.de/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
-
-"udmedia.de"		"http://[USERNAME]:[PASSWORD]@www.udmedia.de/nic/update?myip=[IP]"
-
-"variomedia.de"		"http://[USERNAME]:[PASSWORD]@dyndns.variomedia.de/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
-
-"zerigo.com"		"http://update.zerigo.com/dynamic?user=[USERNAME]&password=[PASSWORD]&host=[DOMAIN]&ip=[IP]"	"ok"
-
-"zzzz.io"		"http://zzzz.io/api/v1/update/[DOMAIN]/?token=[PASSWORD]&type=aaaa&ip=[IP]"	"Updated|No change"
-
diff --recursive --unified --new-file --no-dereference orig/update_cloudflare_com_v4.sh src/update_cloudflare_com_v4.sh
--- orig/update_cloudflare_com_v4.sh	2023-11-08 12:46:52.000000000 +0000
+++ src/update_cloudflare_com_v4.sh	1970-01-01 00:00:00.000000000 +0000
@@ -1,193 +0,0 @@
-#!/bin/sh
-#
-#.Distributed under the terms of the GNU General Public License (GPL) version 2.0
-#
-# script for sending updates to cloudflare.com
-#.based on Ben Kulbertis cloudflare-update-record.sh found at http://gist.github.com/benkulbertis
-#.and on George Johnson's cf-ddns.sh found at https://github.com/gstuartj/cf-ddns.sh
-#.2016-2018 Christian Schoenebeck <christian dot schoenebeck at gmail dot com>
-# CloudFlare API documentation at https://api.cloudflare.com/
-#
-# This script is parsed by dynamic_dns_functions.sh inside send_update() function
-#
-# using following options from /etc/config/ddns
-# option username  - your cloudflare e-mail
-# option password  - cloudflare api key, you can get it from cloudflare.com/my-account/
-# option domain    - "hostname@yourdomain.TLD"	# syntax changed to remove split_FQDN() function and tld_names.dat.gz
-#
-# The proxy status would not be changed by this script. Please change it in Cloudflare dashboard manually. 
-#
-# variable __IP already defined with the ip-address to use for update
-#
-
-# check parameters
-[ -z "$CURL" ] && [ -z "$CURL_SSL" ] && write_log 14 "Cloudflare communication require cURL with SSL support. Please install"
-[ -z "$username" ] && write_log 14 "Service section not configured correctly! Missing key as 'username'"
-[ -z "$password" ] && write_log 14 "Service section not configured correctly! Missing secret as 'password'"
-[ $use_https -eq 0 ] && use_https=1	# force HTTPS
-
-# used variables
-local __HOST __DOMAIN __TYPE __URLBASE __PRGBASE __RUNPROG __DATA __IPV6 __ZONEID __RECID __PROXIED
-local __URLBASE="https://api.cloudflare.com/client/v4"
-
-# split __HOST __DOMAIN from $domain
-# given data:
-# @example.com for "domain record"
-# host.sub@example.com for a "host record"
-__HOST=$(printf %s "$domain" | cut -d@ -f1)
-__DOMAIN=$(printf %s "$domain" | cut -d@ -f2)
-
-# Cloudflare v4 needs:
-# __DOMAIN = the base domain i.e. example.com
-# __HOST   = the FQDN of record to modify
-# i.e. example.com for the "domain record" or host.sub.example.com for "host record"
-
-# handling domain record then set __HOST = __DOMAIN
-[ -z "$__HOST" ] && __HOST=$__DOMAIN
-# handling host record then rebuild fqdn host@domain.tld => host.domain.tld
-[ "$__HOST" != "$__DOMAIN" ] && __HOST="${__HOST}.${__DOMAIN}"
-
-# set record type
-[ $use_ipv6 -eq 0 ] && __TYPE="A" || __TYPE="AAAA"
-
-# transfer function to use for godaddy
-# all needed variables are set global here
-# so we can use them directly
-cloudflare_transfer() {
-	local __CNT=0
-	local __ERR
-	while : ; do
-		write_log 7 "#> $__RUNPROG"
-		eval "$__RUNPROG"
-		__ERR=$?			# save communication error
-		[ $__ERR -eq 0 ] && break	# no error break while
-
-		write_log 3 "cURL Error: '$__ERR'"
-		write_log 7 "$(cat $ERRFILE)"		# report error
-
-		[ $VERBOSE_MODE -gt 1 ] && {
-			# VERBOSE_MODE > 1 then NO retry
-			write_log 4 "Transfer failed - Verbose Mode: $VERBOSE_MODE - NO retry on error"
-			break
-		}
-
-		__CNT=$(( $__CNT + 1 ))	# increment error counter
-		# if error count > retry_count leave here
-		[ $retry_count -gt 0 -a $__CNT -gt $retry_count ] && \
-			write_log 14 "Transfer failed after $retry_count retries"
-
-		write_log 4 "Transfer failed - retry $__CNT/$retry_count in $RETRY_SECONDS seconds"
-		sleep $RETRY_SECONDS &
-		PID_SLEEP=$!
-		wait $PID_SLEEP	# enable trap-handler
-		PID_SLEEP=0
-	done
-
-	# check for error
-	grep -q '"success":true' $DATFILE || {
-		write_log 4 "CloudFlare reported an error:"
-		write_log 7 "$(cat $DATFILE)"		# report error
-		return 1	# HTTP-Fehler
-	}
-}
-
-# Build base command to use
-__PRGBASE="$CURL -RsS -o $DATFILE --stderr $ERRFILE"
-# force network/interface-device to use for communication
-if [ -n "$bind_network" ]; then
-	local __DEVICE
-	network_get_physdev __DEVICE $bind_network || \
-		write_log 13 "Can not detect local device using 'network_get_physdev $bind_network' - Error: '$?'"
-	write_log 7 "Force communication via device '$__DEVICE'"
-	__PRGBASE="$__PRGBASE --interface $__DEVICE"
-fi
-# force ip version to use
-if [ $force_ipversion -eq 1 ]; then
-	[ $use_ipv6 -eq 0 ] && __PRGBASE="$__PRGBASE -4" || __PRGBASE="$__PRGBASE -6"	# force IPv4/IPv6
-fi
-# set certificate parameters
-if [ "$cacert" = "IGNORE" ]; then	# idea from Ticket #15327 to ignore server cert
-	__PRGBASE="$__PRGBASE --insecure"	# but not empty better to use "IGNORE"
-elif [ -f "$cacert" ]; then
-	__PRGBASE="$__PRGBASE --cacert $cacert"
-elif [ -d "$cacert" ]; then
-	__PRGBASE="$__PRGBASE --capath $cacert"
-elif [ -n "$cacert" ]; then		# it's not a file and not a directory but given
-	write_log 14 "No valid certificate(s) found at '$cacert' for HTTPS communication"
-fi
-# disable proxy if not set (there might be .wgetrc or .curlrc or wrong environment set)
-# or check if libcurl compiled with proxy support
-if [ -z "$proxy" ]; then
-	__PRGBASE="$__PRGBASE --noproxy '*'"
-elif [ -z "$CURL_PROXY" ]; then
-	# if libcurl has no proxy support and proxy should be used then force ERROR
-	write_log 13 "cURL: libcurl compiled without Proxy support"
-fi
-# set headers
-__PRGBASE="$__PRGBASE --header 'X-Auth-Email: $username' "
-__PRGBASE="$__PRGBASE --header 'X-Auth-Key: $password' "
-__PRGBASE="$__PRGBASE --header 'Content-Type: application/json' "
-# __PRGBASE="$__PRGBASE --header 'Accept: application/json' "
-
-# read zone id for registered domain.TLD
-__RUNPROG="$__PRGBASE --request GET '$__URLBASE/zones?name=$__DOMAIN'"
-cloudflare_transfer || return 1
-# extract zone id
-__ZONEID=$(grep -o '"id":"[^"]*' $DATFILE | grep -o '[^"]*$' | head -1)
-[ -z "$__ZONEID" ] && {
-	write_log 4 "Could not detect 'zone id' for domain.tld: '$__DOMAIN'"
-	return 127
-}
-
-# read record id for A or AAAA record of host.domain.TLD
-__RUNPROG="$__PRGBASE --request GET '$__URLBASE/zones/$__ZONEID/dns_records?name=$__HOST&type=$__TYPE'"
-cloudflare_transfer || return 1
-# extract record id
-__RECID=$(grep -o '"id":"[^"]*' $DATFILE | grep -o '[^"]*$' | head -1)
-[ -z "$__RECID" ] && {
-	write_log 4 "Could not detect 'record id' for host.domain.tld: '$__HOST'"
-	return 127
-}
-
-# extract current stored IP
-__DATA=$(grep -o '"content":"[^"]*' $DATFILE | grep -o '[^"]*$' | head -1)
-
-# check data
-[ $use_ipv6 -eq 0 ] \
-	&& __DATA=$(printf "%s" "$__DATA" | grep -m 1 -o "$IPV4_REGEX") \
-	|| __DATA=$(printf "%s" "$__DATA" | grep -m 1 -o "$IPV6_REGEX")
-
-# we got data so verify
-[ -n "$__DATA" ] && {
-	# expand IPv6 for compare
-	if [ $use_ipv6 -eq 1 ]; then
-		expand_ipv6 $__IP __IPV6
-		expand_ipv6 $__DATA __DATA
-		[ "$__DATA" = "$__IPV6" ] && {		# IPv6 no update needed
-			write_log 7 "IPv6 at CloudFlare.com already up to date"
-			return 0
-		}
-	else
-		[ "$__DATA" = "$__IP" ] && {		# IPv4 no update needed
-			write_log 7 "IPv4 at CloudFlare.com already up to date"
-			return 0
-		}
-	fi
-}
-
-# update is needed
-# let's build data to send
-# set proxied parameter
-__PROXIED=$(grep -o '"proxied":[^",]*' $DATFILE | grep -o '[^:]*$')
-
-# use file to work around " needed for json
-cat > $DATFILE << EOF
-{"id":"$__ZONEID","type":"$__TYPE","name":"$__HOST","content":"$__IP","proxied":$__PROXIED}
-EOF
-
-# let's complete transfer command
-__RUNPROG="$__PRGBASE --request PUT --data @$DATFILE '$__URLBASE/zones/$__ZONEID/dns_records/$__RECID'"
-cloudflare_transfer || return 1
-
-return 0
-
diff --recursive --unified --new-file --no-dereference orig/update_freedns_42_pl.sh src/update_freedns_42_pl.sh
--- orig/update_freedns_42_pl.sh	2023-11-08 12:46:52.000000000 +0000
+++ src/update_freedns_42_pl.sh	1970-01-01 00:00:00.000000000 +0000
@@ -1,17 +0,0 @@
-#.Distributed under the terms of the GNU General Public License (GPL) version 2.0
-#.2018 Michal Lipka <michal at sysadmin dot care>
-local __DUMMY
-local __URL="https://freedns.42.pl/xmlrpc.php"
-[ -z "$username" ] && write_log 14 "Service section not configured correctly! Missing 'username'"
-[ -z "$password" ] && write_log 14 "Service section not configured correctly! Missing 'password'"
-[ $ip_dynamic -eq 1 ] && __IP='\&lt;dynamic\&gt;'
-PROG="$(which curl) -sk"
-write_log 7 "sending update to freedns.42.pl with ip $__IP"
-XMLDATA="<?xml version='1.0'?><methodCall><methodName>xname.updateArecord</methodName><params><param><value><struct><member><name>name</name><value><string>[RECORDNAME]</string></value></member><member><name>zone</name><value><string>[ZONENAME]</string></value></member><member><name>oldaddress</name><value><string>*</string></value></member><member><name>updatereverse</name><value><string>0</string></value></member><member><name>user</name><value><string>[USERNAME]</string></value></member><member><name>ttl</name><value><string>600</string></value></member><member><name>newaddress</name><value><string>[IP]</string></value></member><member><name>password</name><value><string>[PASSWORD]</string></value></member></struct></value></param></params></methodCall>"
-XMLDATA=$(echo $XMLDATA | sed -e "s#\[USERNAME\]#$URL_USER#g" -e "s#\[PASSWORD\]#$URL_PASS#g" \
--e "s#\[ZONENAME\]#$zone#g" -e "s#\[RECORDNAME\]#$record#g" -e "s#\[IP\]#$__IP#g")
-$PROG -d "$XMLDATA" -o $DATFILE $__URL || return 1
-write_log 7 "'freedns.42.pl' answered:${N}$(cat $DATFILE)"
-grep "<fault>" $DATFILE > /dev/null 2>&1 && return 1
-grep '<name>serial</name>' $DATFILE >/dev/null 2>&1
-return $?
diff --recursive --unified --new-file --no-dereference orig/update_godaddy_com_v1.sh src/update_godaddy_com_v1.sh
--- orig/update_godaddy_com_v1.sh	2023-11-08 12:46:52.000000000 +0000
+++ src/update_godaddy_com_v1.sh	1970-01-01 00:00:00.000000000 +0000
@@ -1,172 +0,0 @@
-#!/bin/sh
-#
-#.Distributed under the terms of the GNU General Public License (GPL) version 2.0
-#
-# script for sending updates to godaddy.com
-#.based on GoDaddy.sh v1.0 by Nazar78 @ TeaNazaR.com
-#.2017-2018 Christian Schoenebeck <christian dot schoenebeck at gmail dot com>
-# GoDaddy Documentation at https://developer.godaddy.com/doc
-#
-# This script is parsed by dynamic_dns_functions.sh inside send_update() function
-#
-# using following options from /etc/config/ddns
-# option username - "key" as generated at https://developer.godaddy.com/keys/
-# option password - "secret" as generated at https://developer.godaddy.com/keys/
-# option domain   - "yourdomain.TLD" to update or "hostname@yourdomain.TLD"
-#
-# variable __IP already defined with the ip-address to use for update
-#
-
-# check parameters
-[ -z "$CURL" ] && [ -z "$CURL_SSL" ] && write_log 14 "GoDaddy communication require cURL with SSL support. Please install"
-[ -z "$username" ] && write_log 14 "Service section not configured correctly! Missing key as 'username'"
-[ -z "$password" ] && write_log 14 "Service section not configured correctly! Missing secret as 'password'"
-[ $use_https -eq 0 ] && use_https=1	# force HTTPS
-
-# used variables
-local __HOST __DOMAIN __TYPE __URL __PRGBASE __RUNPROG __DATA __IPV6
-
-# split __HOST __DOMAIN from $domain
-# given data:
-# @example.com for "domain record"
-# host.sub@example.com for a "host record"
-__HOST=$(printf %s "$domain" | cut -d@ -f1)
-__DOMAIN=$(printf %s "$domain" | cut -d@ -f2)
-
-# GoDaddy needs:
-# __DOMAIN = the base domain i.e. example.com
-# __HOST   = host.sub if updating a host record or
-# __HOST   = "@" urlencoded "%40" for a domain record
-[ -z "$__HOST" -o "$__HOST" = "$__DOMAIN" ] && __HOST="%40"
-
-# set record type
-[ $use_ipv6 -eq 0 ] && __TYPE="A" || __TYPE="AAAA"
-
-# now we know the url to use
-# __URL="https://api.ote-godaddy.com/v1/domains/$__DOMAIN/records/$__TYPE/$__HOST"	# api test server
-__URL="https://api.godaddy.com/v1/domains/$__DOMAIN/records/$__TYPE/$__HOST"		# production server
-
-# transfer function to use for godaddy
-# all needed variables are set global here
-# so we can use them directly
-godaddy_transfer() {
-	local __CNT=0
-	local __STATUS __ERR __DEVICE
-	while : ; do
-		write_log 7 "#> $__RUNPROG"
-		__STATUS=$(eval "$__RUNPROG")
-		__ERR=$?			# save communication error
-		[ $__ERR -eq 0 ] && break	# no error break while
-
-		write_log 4 "cURL error: '$__ERR'"
-		write_log 7 "$(cat $ERRFILE)"		# report error
-
-		[ $VERBOSE_MODE -gt 1 ] && {
-			# VERBOSE_MODE > 1 then NO retry
-			write_log 4 "Transfer failed - Verbose Mode: $VERBOSE_MODE - NO retry on error"
-			break
-		}
-
-		__CNT=$(( $__CNT + 1 ))	# increment error counter
-		# if error count > retry_count leave here
-		[ $retry_count -gt 0 -a $__CNT -gt $retry_count ] && \
-			write_log 14 "Transfer failed after $retry_count retries"
-
-		write_log 4 "Transfer failed - retry $__CNT/$retry_count in $RETRY_SECONDS seconds"
-		sleep $RETRY_SECONDS &
-		PID_SLEEP=$!
-		wait $PID_SLEEP	# enable trap-handler
-		PID_SLEEP=0
-	done
-
-	# handle HTTP error
-	[ $__STATUS -ne 200 ] && {
-		write_log 4 "GoDaddy reported an error:"
-		write_log 7 "$(cat $DATFILE)"
-		return 1
-	}
-	return 0
-}
-
-# Build base command to use
-__PRGBASE="$CURL -RsS -w '%{http_code}' -o $DATFILE --stderr $ERRFILE"
-# force network/interface-device to use for communication
-if [ -n "$bind_network" ]; then
-	local __DEVICE
-	network_get_physdev __DEVICE $bind_network || \
-		write_log 13 "Can not detect local device using 'network_get_physdev $bind_network' - Error: '$?'"
-	write_log 7 "Force communication via device '$__DEVICE'"
-	__PRGBASE="$__PRGBASE --interface $__DEVICE"
-fi
-# force ip version to use
-if [ $force_ipversion -eq 1 ]; then
-	[ $use_ipv6 -eq 0 ] && __PRGBASE="$__PRGBASE -4" || __PRGBASE="$__PRGBASE -6"	# force IPv4/IPv6
-fi
-# set certificate parameters
-if [ "$cacert" = "IGNORE" ]; then	# idea from Ticket #15327 to ignore server cert
-	__PRGBASE="$__PRGBASE --insecure"	# but not empty better to use "IGNORE"
-elif [ -f "$cacert" ]; then
-	__PRGBASE="$__PRGBASE --cacert $cacert"
-elif [ -d "$cacert" ]; then
-	__PRGBASE="$__PRGBASE --capath $cacert"
-elif [ -n "$cacert" ]; then		# it's not a file and not a directory but given
-	write_log 14 "No valid certificate(s) found at '$cacert' for HTTPS communication"
-fi
-# disable proxy if no set (there might be .wgetrc or .curlrc or wrong environment set)
-# or check if libcurl compiled with proxy support
-if [ -z "$proxy" ]; then
-	__PRGBASE="$__PRGBASE --noproxy '*'"
-elif [ -z "$CURL_PROXY" ]; then
-	# if libcurl has no proxy support and proxy should be used then force ERROR
-	write_log 13 "cURL: libcurl compiled without Proxy support"
-fi
-# set headers
-__PRGBASE="$__PRGBASE --header 'Authorization: sso-key $username:$password' "
-__PRGBASE="$__PRGBASE --header 'Accept: application/json' "
-__PRGBASE="$__PRGBASE --header 'Content-Type: application/json; charset=utf-8' "
-
-# read data from godaddy.com
-__RUNPROG="$__PRGBASE --request GET $__URL"
-godaddy_transfer || return 1
-
-# HTTP 200 OK, now analyse data and check if update needed
-__DATA=$(sed -r 's/.+data":"(.+)","t.+/\1/g' $DATFILE)
-
-# check data
-[ $use_ipv6 -eq 0 ] \
-	&& __DATA=$(printf "%s" "$__DATA" | grep -m 1 -o "$IPV4_REGEX") \
-	|| __DATA=$(printf "%s" "$__DATA" | grep -m 1 -o "$IPV6_REGEX")
-
-# we got data so verify
-[ -n "$__DATA" ] && {
-	# expand IPv6 for compare
-	if [ $use_ipv6 -eq 1 ]; then
-		expand_ipv6 $__IP __IPV6
-		expand_ipv6 $__DATA __DATA
-		[ "$__DATA" = "$__IPV6" ] && {		# IPv6 no update needed
-			write_log 7 "IPv6 at GoDaddy.com already up to date"
-			return 0
-		}
-	else
-		[ "$__DATA" = "$__IP" ] && {		# IPv4 no update needed
-			write_log 7 "IPv4 at GoDaddy.com already up to date"
-			return 0
-		}
-	fi
-}
-
-# update is needed
-# let's build data to send,
-# use file to work around double quotes '"' needed for json
-cat > $DATFILE << EOF
-[{"data":"$__IP"}]
-EOF
-
-# let's complete transfer command
-__RUNPROG="$__PRGBASE --request PUT --data @$DATFILE $__URL"
-
-godaddy_transfer || return 1
-
-# HTTP 200 OK
-return 0
-
diff --recursive --unified --new-file --no-dereference orig/update_no-ip_com.sh src/update_no-ip_com.sh
--- orig/update_no-ip_com.sh	2023-11-08 12:46:52.000000000 +0000
+++ src/update_no-ip_com.sh	1970-01-01 00:00:00.000000000 +0000
@@ -1,52 +0,0 @@
-#
-#.Distributed under the terms of the GNU General Public License (GPL) version 2.0
-#
-# script for sending updates to no-ip.com / noip.com
-#.2014-2015 Christian Schoenebeck <christian dot schoenebeck at gmail dot com>
-#
-# This script is parsed by dynamic_dns_functions.sh inside send_update() function
-#
-# provider did not reactivate records, if no IP change was recognized
-# so we send a dummy (localhost) and a seconds later we send the correct IP addr
-#
-local __DUMMY
-local __UPDURL="http://[USERNAME]:[PASSWORD]@dynupdate.no-ip.com/nic/update?hostname=[DOMAIN]&myip=[IP]"
-# inside url we need username and password
-[ -z "$username" ] && write_log 14 "Service section not configured correctly! Missing 'username'"
-[ -z "$password" ] && write_log 14 "Service section not configured correctly! Missing 'password'"
-
-# set IP version dependend dummy (localhost)
-[ $use_ipv6 -eq 0 ] && __DUMMY="127.0.0.1" || __DUMMY="::1"
-
-# lets do DUMMY transfer
-write_log 7 "sending dummy IP to 'no-ip.com'"
-__URL=$(echo $__UPDURL | sed -e "s#\[USERNAME\]#$URL_USER#g" -e "s#\[PASSWORD\]#$URL_PASS#g" \
-			       -e "s#\[DOMAIN\]#$domain#g" -e "s#\[IP\]#$__DUMMY#g")
-[ $use_https -ne 0 ] && __URL=$(echo $__URL | sed -e 's#^http:#https:#')
-
-do_transfer "$__URL" || return 1
-
-write_log 7 "'no-ip.com' answered:${N}$(cat $DATFILE)"
-# analyse provider answers
-# "good [IP_ADR]"	= successful
-# "nochg [IP_ADR]"	= no change but OK
-grep -E "good|nochg" $DATFILE >/dev/null 2>&1 || return 1
-
-# lets wait a seconds
-sleep 1
-
-# now send the correct data
-write_log 7 "sending real IP to 'no-ip.com'"
-__URL=$(echo $__UPDURL | sed -e "s#\[USERNAME\]#$URL_USER#g" -e "s#\[PASSWORD\]#$URL_PASS#g" \
-			       -e "s#\[DOMAIN\]#$domain#g" -e "s#\[IP\]#$__IP#g")
-[ $use_https -ne 0 ] && __URL=$(echo $__URL | sed -e 's#^http:#https:#')
-
-do_transfer "$__URL" || return 1
-
-write_log 7 "'no-ip.com' answered:${N}$(cat $DATFILE)"
-# analyse provider answers
-# "good [IP_ADR]"	= successful
-# "nochg [IP_ADR]"	= no change but OK
-grep -E "good|nochg" $DATFILE >/dev/null 2>&1
-return $?	# "0" if "good" or "nochg" found
-
diff --recursive --unified --new-file --no-dereference orig/update_nsupdate.sh src/update_nsupdate.sh
--- orig/update_nsupdate.sh	2023-11-08 12:46:52.000000000 +0000
+++ src/update_nsupdate.sh	1970-01-01 00:00:00.000000000 +0000
@@ -1,48 +0,0 @@
-#
-#.Distributed under the terms of the GNU General Public License (GPL) version 2.0
-#
-# The script directly updates a PowerDNS (or maybe bind server) via nsupdate from bind-client package.
-#.based on github request #957 by Jan Riechers <de at r-jan dot de>
-#.2015 Christian Schoenebeck <christian dot schoenebeck at gmail dot com>
-#
-# This script is parsed by dynamic_dns_functions.sh inside send_update() function
-#
-# using following options from /etc/config/ddns
-# option username   - keyname 
-# option password   - shared secret (base64 encoded)
-# option domain     - full qualified domain to update
-# option dns_server - DNS server to update
-#
-# variable __IP already defined with the ip-address to use for update
-#
-local __TTL=600		#.preset DNS TTL (in seconds)
-local __RRTYPE __PW __TCP
-local __PROG=$(which nsupdate)			# BIND nsupdate ?
-[ -z "$__PROG" ] && __PROG=$(which knsupdate)	# Knot nsupdate ?
-
-[ -z "$__PROG" ]     && write_log 14 "'nsupdate' or 'knsupdate' not installed !"
-[ -z "$username" ]   && write_log 14 "Service section not configured correctly! Missing 'username'"
-[ -z "$password" ]   && write_log 14 "Service section not configured correctly! Missing 'password'"
-[ -z "$dns_server" ] && write_log 14 "Service section not configured correctly! Missing 'dns_server'"
-
-[ $use_ipv6 -ne 0 ] && __RRTYPE="AAAA" || __RRTYPE="A"
-[ $force_dnstcp -ne 0 ] && __TCP="-v" || __TCP=""
-
-# create command file
-cat >$DATFILE <<-EOF
-server $dns_server
-key $username $password
-update del $domain $__RRTYPE
-update add $domain $__TTL $__RRTYPE $__IP
-show
-send
-answer
-quit
-EOF
-
-$__PROG -d $__TCP $DATFILE >$ERRFILE 2>&1
-
-# nsupdate always return success
-write_log 7 "(k)nsupdate reports:${N}$(cat $ERRFILE)"
-
-return 0
diff --recursive --unified --new-file --no-dereference orig/update_route53_v1.sh src/update_route53_v1.sh
--- orig/update_route53_v1.sh	2023-11-08 12:46:52.000000000 +0000
+++ src/update_route53_v1.sh	1970-01-01 00:00:00.000000000 +0000
@@ -1,97 +0,0 @@
-#!/bin/sh
-#.Distributed under the terms of the GNU General Public License (GPL) version 2.0
-#.based on Yuval Adam's route53.sh found at https://github.com/yuvadm/route53-ddns/blob/master/route53.sh
-#.2017 Max Berger <max at berger dot name>
-[ -z "$CURL_SSL" ] && write_log 14 "Amazon AWS Route53 communication require cURL with SSL support. Please install"
-[ -z "$username" ] && write_log 14 "Service section not configured correctly! Missing key as 'username'"
-[ -z "$password" ] && write_log 14 "Service section not configured correctly! Missing secret as 'password'"
-[ -z "$domain" ] && write_log 14 "Service section not configured correctly! Missing zone id as 'domain'"
-
-set -euo pipefail
-IFS=$'\n\t'
-
-ENDPOINT="route53.amazonaws.com"
-RECORD_TTL=300
-RECORD_NAME="$lookup_host".
-[ $use_ipv6 -eq 0 ] && RECORD_TYPE="A"
-[ $use_ipv6 -eq 1 ] && RECORD_TYPE="AAAA"
-RECORD_VALUE="$LOCAL_IP"
-HOSTED_ZONE_ID="$domain"
-API_PATH="/2013-04-01/hostedzone/${HOSTED_ZONE_ID}/rrset/"
-
-AWS_ACCESS_KEY_ID="$username"
-AWS_SECRET_ACCESS_KEY="$password"
-AWS_REGION='us-east-1'
-AWS_SERVICE='route53'
-
-hash() {
-    msg=$1
-    echo -en "$msg" | openssl dgst -sha256 | sed 's/^.* //'
-}
-
-sign_plain() {
-    # Sign message using a plaintext key
-    key=$1
-    msg=$2
-    echo -en "$msg" | openssl dgst -hex -sha256 -hmac "$key" | sed 's/^.* //'
-}
-
-sign() {
-    # Sign message using a hex formatted key
-    key=$1
-    msg=$2
-    echo -en "$msg" | openssl dgst -hex -sha256 -mac HMAC -macopt "hexkey:${key}" | sed 's/^.* //'
-}
-
-request_body="<?xml version=\"1.0\" encoding=\"UTF-8\"?> \
-<ChangeResourceRecordSetsRequest xmlns=\"https://route53.amazonaws.com/doc/2013-04-01/\"> \
-<ChangeBatch> \
-   <Changes> \
-      <Change> \
-         <Action>UPSERT</Action> \
-         <ResourceRecordSet> \
-            <Name>${RECORD_NAME}</Name> \
-            <Type>${RECORD_TYPE}</Type> \
-            <TTL>${RECORD_TTL}</TTL> \
-            <ResourceRecords> \
-               <ResourceRecord> \
-                  <Value>${RECORD_VALUE}</Value> \
-               </ResourceRecord> \
-            </ResourceRecords> \
-         </ResourceRecordSet> \
-      </Change> \
-   </Changes> \
-</ChangeBatch> \
-</ChangeResourceRecordSetsRequest>"
-
-fulldate=$(date --utc +%Y%m%dT%H%M%SZ)
-shortdate=$(date --utc +%Y%m%d)
-signed_headers="host;x-amz-date"
-request_hash=$(hash "$request_body")
-canonical_request="POST\n${API_PATH}\n\nhost:route53.amazonaws.com\nx-amz-date:${fulldate}\n\n${signed_headers}\n${request_hash}"
-
-date_key=$(sign_plain "AWS4${AWS_SECRET_ACCESS_KEY}" "${shortdate}")
-region_key=$(sign "$date_key" $AWS_REGION)
-service_key=$(sign "$region_key" $AWS_SERVICE)
-signing_key=$(sign "$service_key" aws4_request)
-
-credential="${shortdate}/${AWS_REGION}/${AWS_SERVICE}/aws4_request"
-sigmsg="AWS4-HMAC-SHA256\n${fulldate}\n${credential}\n$(hash "$canonical_request")"
-
-signature=$(sign "$signing_key" "$sigmsg")
-
-authorization="AWS4-HMAC-SHA256 Credential=${AWS_ACCESS_KEY_ID}/${credential}, SignedHeaders=${signed_headers}, Signature=${signature}"
-
-ANSWER=$(curl \
-    -X "POST" \
-    -H "Host: route53.amazonaws.com" \
-    -H "X-Amz-Date: ${fulldate}" \
-    -H "Authorization: ${authorization}" \
-    -H "Content-Type: text/xml" \
-    -d "$request_body" \
-    "https://${ENDPOINT}${API_PATH}")
-write_log 7 "${ANSWER}"
-
-echo ${ANSWER} | grep Error >/dev/null && return 1
-echo ${ANSWER} | grep ChangeInfo >/dev/null && return 0
-return 2
diff --recursive --unified --new-file --no-dereference orig/update_sample.sh src/update_sample.sh
--- orig/update_sample.sh	2023-11-08 12:46:52.000000000 +0000
+++ src/update_sample.sh	1970-01-01 00:00:00.000000000 +0000
@@ -1,41 +0,0 @@
-# sample script for sending user defined updates
-# 2014-2015 Christian Schoenebeck <christian dot schoenebeck at gmail dot com>
-#
-# activated inside /etc/config/ddns by setting
-#
-# option update_script '/usr/lib/ddns/update_sample.sh'
-#
-# the script is parsed (not executed) inside send_update() function
-# of /usr/lib/ddns/dynamic_dns_functions.sh
-# so you can use all available functions and global variables inside this script
-# already defined in dynamic_dns_updater.sh and dynamic_dns_functions.sh
-#
-# It make sence to define the update url ONLY inside this script
-# because it's anyway unique to the update script
-# otherwise it should work with the default scripts
-#
-# the code here is the copy of the default used inside send_update()
-#
-# tested with spdns.de
-local __URL="http://[USERNAME]:[PASSWORD]@update.spdns.de/nic/update?hostname=[DOMAIN]&myip=[IP]"
-# inside url we need domain, username and password
-[ -z "$domain" ]   && write_log 14 "Service section not configured correctly! Missing 'domain'"
-[ -z "$username" ] && write_log 14 "Service section not configured correctly! Missing 'username'"
-[ -z "$password" ] && write_log 14 "Service section not configured correctly! Missing 'password'"
-
-# do replaces in URL
-__URL=$(echo $__URL |  | sed -e "s#\[USERNAME\]#$URL_USER#g" -e "s#\[PASSWORD\]#$URL_PASS#g" \
-			     -e "s#\[PARAMENC\]#$URL_PENC#g" -e "s#\[PARAMOPT\]#$param_opt#g" \
-			     -e "s#\[DOMAIN\]#$domain#g"     -e "s#\[IP\]#$__IP#g")
-[ $use_https -ne 0 ] && __URL=$(echo $__URL | sed -e 's#^http:#https:#')
-
-do_transfer "$__URL" || return 1
-
-write_log 7 "DDNS Provider answered:\n$(cat $DATFILE)"
-
-# analyse provider answers
-# "good [IP_ADR]"	= successful
-# "nochg [IP_ADR]"	= no change but OK
-grep -i -E "good|nochg" $DATFILE >/dev/null 2>&1
-return $?	# "0" if "good" or "nochg" found
-
